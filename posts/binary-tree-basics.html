<!DOCTYPE html>
<html lang=en>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="二叉树12345class Node&lt;T&gt;&#123;    T val;    Node left;    Node right;&#125; 二叉树的遍历144. 二叉树的前序遍历 - 力扣（LeetCode）94. 二叉树的中序遍历 - 力扣（LeetCode）145. 二叉树的后序遍历 - 力扣（LeetCode） 递归, 迭代, Morris -&gt; 实现二叉树的先序、中">
<meta property="og:type" content="article">
<meta property="og:title" content="Binary Tree Fundamentals">
<meta property="og:url" content="https://blog.210222.xyz/posts/binary-tree-basics">
<meta property="og:site_name" content="LANDFILL">
<meta property="og:description" content="二叉树12345class Node&lt;T&gt;&#123;    T val;    Node left;    Node right;&#125; 二叉树的遍历144. 二叉树的前序遍历 - 力扣（LeetCode）94. 二叉树的中序遍历 - 力扣（LeetCode）145. 二叉树的后序遍历 - 力扣（LeetCode） 递归, 迭代, Morris -&gt; 实现二叉树的先序、中">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715237.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715310.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203122319982.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121522264.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121710824.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121905335.png">
<meta property="article:published_time" content="2022-03-12T09:12:00.000Z">
<meta property="article:modified_time" content="2025-02-09T16:40:37.847Z">
<meta property="article:author" content="exit.">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715237.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Binary Tree Fundamentals</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="LANDFILL" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body class="max-width mx-auto px3 ltr">    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/be-a-programmer"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/life-in-kitchen"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://blog.210222.xyz/posts/binary-tree-basics"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.210222.xyz/posts/binary-tree-basics&text=Binary Tree Fundamentals"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://blog.210222.xyz/posts/binary-tree-basics&is_video=false&description=Binary Tree Fundamentals"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Binary Tree Fundamentals&body=Check out this article: https://blog.210222.xyz/posts/binary-tree-basics"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://blog.210222.xyz/posts/binary-tree-basics&name=Binary Tree Fundamentals&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://blog.210222.xyz/posts/binary-tree-basics&t=Binary Tree Fundamentals"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text">迭代遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Morris-Traversal"><span class="toc-number">2.3.</span> <span class="toc-text">Morris Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81BST"><span class="toc-number">3.1.</span> <span class="toc-text">验证BST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81CBT"><span class="toc-number">4.1.</span> <span class="toc-text">验证CBT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">判断是否为满二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.1.</span> <span class="toc-text">判断是否为平衡树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">7.</span> <span class="toc-text">最低公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">查找后继节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%88%B6%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.1.</span> <span class="toc-text">有父指针的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1"><span class="toc-number">8.2.</span> <span class="toc-text">二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">折纸问题</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Binary Tree Fundamentals
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">exit.</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-03-12T09:12:00.000Z" itemprop="datePublished">2022-03-12</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Notes/">Notes</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Algorithm/" rel="tag">Algorithm</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt;&#123;</span><br><span class="line">    T val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p>
<p>递归, 迭代, Morris -&gt; 实现二叉树的先序、中序、后序遍历。</p>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>递归序。每次递归调用结束会返回到当前方法的调用处。</p>
<p>序是根节点在的位置。根的相对位置决定序。</p>
<ul>
<li>先序遍历：对于每一颗子树来说。都是<strong>根左右</strong>的顺序。</li>
<li>中序遍历：<strong>左根右</strong> </li>
<li>后序遍历：<strong>左右根</strong></li>
</ul>
<p>递归序。每次递归调用结束会返回到当前方法的调用处。<br>第一次进入节点root。第一次进入方法。<br>递归调用root.left。递归结束会回到原方法<br>递归调用root.right。递归结束会回到原方法</p>
<p>所以会三次进入当前调用方法的栈。</p>
<ul>
<li>先序遍历：就是在第一次进入方法的时候打印</li>
<li>中序遍历：就是在第二次进入方法的时候打印</li>
<li>后序遍历：就是在第三次进入方法的时候打印<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 递归方式遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeRecurTraversal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// println可以换成任意方法调用，来操作节点</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left);</span><br><span class="line">        postorder(root.right);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>所有的递归都可以改写成非递归。<br>因为递归是程序语言在隐式地帮你压栈。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/58400144">什么样的编程语言会不支持递归呢？ - 知乎</a><br><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化 - 阮一峰的网络日志</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6963679314101403679#heading-22">Java尾递归 - 掘金</a></p>
<blockquote>
<p> Java在编译器层面没有优化尾递归调用<br> <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/272061/why-doesnt-java-have-optimization-for-tail-recursion-at-all">Why doesn’t Java have optimization for tail-recursion at all? </a><br>As explained by Brian Goetz (Java Language Architect at Oracle) in this <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=2y5Pv4yN0b0&amp;t=1h02m18s">video</a>:<br>“in jdk classes […] there are a number of security sensitive methods that rely on counting stack frames between jdk library code and calling code to figure out who’s calling them.”</p>
<p>Anything that changed the number of frames on the stack would break this and would cause an error. He admits this was a stupid reason, and so the JDK developers have since replaced this mechanism.</p>
<p>He further then mentions that it’s not a priority, but that tail recursion will eventually get done.</p>
<p>N.B. This applies to HotSpot and the OpenJDK, other VMs may vary.</p>
<p><a target="_blank" rel="noopener" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E6%80%BB%E7%BB%93">第 4 章: 柯里化（curry） · 函数式编程指北</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6134278/does-java-support-currying">functional programming - Does Java support Currying? - Stack Overflow</a></p>
</blockquote>
<p>使用栈实现。<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019076869">Stack，ArrayDeque，LinkedList的区别 - SegmentFault 思否</a><br>Java不要使用Stack，Deprecated。使用Deque。</p>
<ul>
<li>先序遍历</li>
</ul>
<ol>
<li>如果头不为空。初始化栈。压入栈。</li>
<li>如果栈不为空，<ol>
<li>每次从栈中弹出一个节点cur。</li>
<li>打印(处理)cur</li>
<li>如果有右节点。push。如果有左节点push</li>
</ol>
</li>
<li>当栈空时，处理结束</li>
</ol>
<ul>
<li>中序遍历</li>
</ul>
<ol>
<li>如果头不为空。初始化栈。压入栈。</li>
<li>如果栈不为空，或者root不为null<ol>
<li>root不为空，push，把左边节点都push。</li>
<li>直到root为空。就开始弹出节点。每弹出一个节点就打印值。</li>
<li>然后去到右边节点。继续处理这个节点的左边界。</li>
</ol>
</li>
<li>直到栈空了，并且root为null<br>先左再头。再去到右树的先左再头。不断循环。</li>
</ol>
<ul>
<li>后序遍历</li>
</ul>
<ol>
<li>如果头不为空 初始化两个栈，压入栈。</li>
<li>如果栈不为空，<ol>
<li>每次从栈中弹出一个节点cur。</li>
<li>push到另一个辅助栈</li>
<li>如果有左节点。push。如果有右节点push</li>
</ol>
</li>
<li>依次弹出第二个栈中的元素。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TraversalOfBinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt;&#123;</span><br><span class="line">        T val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(T val)&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(T val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">          <span class="built_in">this</span>.val = val;</span><br><span class="line">          <span class="built_in">this</span>.left = left;</span><br><span class="line">          <span class="built_in">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">            stack.push(root);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                System.out.println(root.val)</span><br><span class="line">                <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当左边遍历到根节点时，就开始处理右边节点的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.push(root);</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = stack.pop();</span><br><span class="line">                    System.out.println(root.val);</span><br><span class="line">                    root = root.right;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Morris traversal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">            Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line">            stack1.push(root);</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                root = stack1.pop();</span><br><span class="line">                stack2.push(root);</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack1.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack1.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack2.isEmpty()) &#123;</span><br><span class="line">                System.out.println(stack2.pop().val)</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Morris-Traversal"><a href="#Morris-Traversal" class="headerlink" title="Morris Traversal"></a>Morris Traversal</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris - 知乎</a></p>
<p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为<strong>O(1)</strong> 的精妙算法。  </p>
<p>morris遍历利用的是树的叶节点左右孩子为空（<strong>树的大量空闲指针</strong>），实现空间开销的极限缩减。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">线索二叉树 - 维基百科，自由的百科全书</a></p>
<p><strong>记作当前节点为cur。</strong></p>
<ol>
<li>如果cur无左孩子，cur向右移动（cur=cur.right）</li>
<li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<ol>
<li>如果mostright的right指针指向null，让其指向cur，cur向左移动（cur=cur.left）</li>
<li>如果mostright的right指针指向cur，让其指向null，cur向右移动（cur=cur.right）</li>
</ol>
</li>
<li>cur为null时遍历结束</li>
</ol>
<p>实现以上的原则，即实现了morris遍历。<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715237.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715310.png" alt=""></p>
<p>一个节点如果有左树，能够回到该节点两次。没有左树的节点只能到达一次。</p>
<p>如果左树上的mostright如果指向null，就是第一次来到当前节点。<br>如果左树上的mostright如果指向 cur，就是第二次来到当前节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MorrisTraversal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        TreeNode mostRight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cur为null时，遍历结束</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="comment">// 如果左子树为空，则跳过以下分支，直接向右移动</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 向右移动，找到most right。如果之前修改过这个mostright，则到第二个条件也要停止</span></span><br><span class="line">                <span class="keyword">while</span>(mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right!=cur)&#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  有指针指向空，则是第一次来到cur</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="comment">// 进行下一次while</span></span><br><span class="line">                    <span class="comment">//continue;</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mostRight.right =<span class="literal">null</span>;<span class="comment">// 第二次来到cur</span></span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur = cur.right;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<br>遍历所有节点的mostright，最多是遍历两边，因此时间复杂度仍然是O(N)。</p>
<p>递归：</p>
<ul>
<li>先序遍历：就是在第一次进入方法的时候打印</li>
<li>中序遍历：就是在第二次进入方法的时候打印</li>
<li>后序遍历：就是在第三次进入方法的时候打印</li>
</ul>
<p>Morris:<br>先序遍历：</p>
<ol>
<li>如果一个节点只能到达一次，直接打印</li>
<li>如果一个节点能到达两次，第一次打印。</li>
</ol>
<p>中序遍历：</p>
<ol>
<li>如果一个节点只能到达一次，直接打印</li>
<li>如果一个节点能到达两次，第二次打印。</li>
</ol>
<p>后序遍历：</p>
<ol>
<li>只能到达一次的节点不打印</li>
<li>第二次到达节点，逆序打印左树的有边界mostright</li>
<li>所有节点遍历完之后，单独逆序打印整个树的右边界</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// cur表示当前节点，mostRight表示cur的左孩子的最右节点</span></span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur有左孩子，找到cur左子树最右节点</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight的右孩子指向空，让其指向cur，cur向左移动</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.println(cur.value);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mostRight的右孩子指向cur，让其指向空，cur向右移动</span></span><br><span class="line">                mostRight.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有左树的节点，直接打印</span></span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisIn</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="comment">// 用continue能节省几行代码， </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第二次来到该节点的时候打印</span></span><br><span class="line">                mostRight.right = <span class="literal">null</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mostRight.right != null 和没有左子树的情况都要执行</span></span><br><span class="line">        <span class="comment">// 能回到两次的节点，当第二次量到达的时候，也就是mostRight.right != null时打印</span></span><br><span class="line">        <span class="comment">// 没有左树也会打印（只经过一遍的节点）</span></span><br><span class="line">        System.out.print(cur.value);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPost</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">           mostRight = cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                   mostRight = mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                   mostRight.right = cur;</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                   printEdge(cur.left);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 整个while结束之后</span></span><br><span class="line">       printEdge(head);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 逆序打印。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span>reverseEdge(node);</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span> )&#123;</span><br><span class="line">           System.out.println(cur.value);</span><br><span class="line">           cur =cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 打印完。再调整回去</span></span><br><span class="line">       reverseEdge(tail);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单链表的反转。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseEdge</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">           next = node.right;</span><br><span class="line">           node.right = pre;</span><br><span class="line">           pre = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>递归，迭代：<br>时间复杂度: 都是O(N)，要经过每一个节点<br>空间复杂度: 在二叉树退化成链表的时候最差是O(N)，平均状况是O(logn)</p>
<p>Morris遍历：<br>时间复杂度: 是O(N)<br>空间复杂度：O(1)</p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树的深度优先遍历 ：先序遍历<br>二叉树的宽度优先遍历 ：队列。      -&gt;   层序遍历。<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要逐层打印</span></span><br><span class="line"><span class="comment">输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">输出：[[3],[9,20],[15,7]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">拓展：最大宽度 -&gt; 还是可以用刚才的方法 </span></span><br><span class="line"><span class="comment">最大宽度在哪一层？-&gt; 要维护一个层数的变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// 每一层都需要一个新的</span></span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 只有当一层遍历完。才进入下一层。</span></span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root = queue.poll();</span><br><span class="line">            tmp.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(N) 节点进出队列一次<br>空间复杂度：叶子节点层，需要存 N/2个节点。空间复杂度为O(N)</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p> Binary search tree -&gt; BST<br> 若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值； 它的左、右子树也分别为二叉排序树</p>
<h3 id="验证BST"><a href="#验证BST" class="headerlink" title="验证BST"></a>验证BST</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a><br>判断是否为BST: 中序遍历 -&gt; 如果是升序的。就是BST</p>
<p>记录上一次 处理的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">preVal</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span> (!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; preVal)&#123;</span><br><span class="line">            preVal = Long.valueOf(root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度：O(N)<br>空间复杂度：O(N)</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>Complete binary tree<br>若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树</p>
<h3 id="验证CBT"><a href="#验证CBT" class="headerlink" title="验证CBT"></a>验证CBT</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验 - 力扣（LeetCode）</a><br>基于层序遍历<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203122319982.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCBT</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            root = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 就是为了减少代码量。要频繁用到</span></span><br><span class="line">            left = root.left;</span><br><span class="line">            right = root.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断false的两种情况。</span></span><br><span class="line">            <span class="comment">// 1. 左空右不空。2. 已经到达叶节点，叶节点却还有子节点</span></span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)) </span><br><span class="line">            || (isLeaf &amp;&amp; (left != <span class="literal">null</span> || right != <span class="literal">null</span>)) </span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 一旦遇到一个节点的存在节点不满的情况。当前节点一定是倒数第二层节点，</span></span><br><span class="line">            <span class="comment">// 其之后的节点全是叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span>)&#123;</span><br><span class="line">                isLeaf = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 整个遍历完。返回true;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p><strong>Full Binary Tree</strong>( 或Perfect Binary Tree)</p>
<ul>
<li>所有internal node都有两个子节点；</li>
<li>所有leaf node具有相同的level(或相同的height)。</li>
<li>若一棵Full Binary Tree的leaf node之level为nn，整棵樹共有$2^n−1$個node。</li>
</ul>
<p>另一种定义：二叉树的每个 节点恰好有 0 或 2 个子结点。</p>
<h3 id="判断是否为满二叉树"><a href="#判断是否为满二叉树" class="headerlink" title="判断是否为满二叉树"></a>判断是否为满二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="type">int</span> nodes;</span><br><span class="line">        Info(<span class="type">int</span> h, <span class="type">int</span> n)&#123;</span><br><span class="line">            <span class="built_in">this</span>.height = h;</span><br><span class="line">            <span class="built_in">this</span>.nodes = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFullBinaryTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">root</span> <span class="operator">=</span> isFull(root);</span><br><span class="line">        <span class="keyword">return</span> root.nodes == (<span class="number">1</span> &lt;&lt; root.height - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">isFull</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> isFull(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> isFull(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(left.height, right.height) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nodes</span> <span class="operator">=</span> left.nodes + right.nodes + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>对于任意的子树，其左右子树的高度差都&lt;=1</p>
<h3 id="判断是否为平衡树"><a href="#判断是否为平衡树" class="headerlink" title="判断是否为平衡树"></a>判断是否为平衡树</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度 - 力扣（LeetCode）</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode）</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReturnEntry</span>&#123;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="type">boolean</span> isBalanced;</span><br><span class="line"></span><br><span class="line">        ReturnEntry(<span class="type">int</span> height, <span class="type">boolean</span> isBalanced)&#123;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">            <span class="built_in">this</span>.isBalanced = isBalanced;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isBalancedTree(root).isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方法 -&gt; 树形DP 如何把子树 信息传递。</span></span><br><span class="line">    <span class="keyword">public</span> ReturnEntry <span class="title function_">isBalancedTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnEntry</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReturnEntry</span> <span class="variable">left</span> <span class="operator">=</span> isBalancedTree(root.left);</span><br><span class="line">        <span class="type">ReturnEntry</span> <span class="variable">right</span> <span class="operator">=</span> isBalancedTree(root.right);</span><br><span class="line"></span><br><span class="line">        height = Math.max(left.height, right.height) + <span class="number">1</span>;</span><br><span class="line">        isBalanced = left.isBalanced &amp;&amp; right.isBalanced</span><br><span class="line">        &amp;&amp; Math.abs(left.height - right.height) &lt;= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnEntry</span>(height, isBalanced);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化版</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(l - r)&lt;=<span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树深度的计算。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剪枝。如果左子树是不平衡的，就提前返回了。而计算深度是全部都要算一遍。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// -1 表示非平衡</span></span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次递归返回深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：</p>
<ol>
<li>先序遍历 + 深度。递归<ol>
<li>时间复杂度 O(NlogN) 需要计算每一颗子树的深度。logN 层。 每层最多N节点。最少(N+1)/2</li>
<li>空间复杂度 O(N) 递归深度。退化成链表的情况。</li>
</ol>
</li>
<li>后续遍历 + 剪枝<ol>
<li>时间复杂度 O(N) 。减少了很多重复计算。最多遍历N个节点</li>
<li>空间复杂度  O(N) </li>
</ol>
</li>
</ol>
<h2 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>方法一 使用额外空间：</p>
<ol>
<li>使用HashMap记录每个节点的父节点。</li>
<li>然后从n1往上遍历。加入一个set中。</li>
<li>然后从n2往上遍历。检查set中是否包含n2 往上的路径。</li>
</ol>
<p>递归：<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121522264.png" alt="lca"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode n1, TreeNode n2)</span>&#123;</span><br><span class="line">        <span class="comment">// 结束递归的条件</span></span><br><span class="line">        <span class="comment">// 只要当节点遇到n1 n2时才会向上返回值。否则都是返回空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == n1 || root == n2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, n1, n2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, n1, n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left, right都不为空。说明n1,n2分别在当前节点的左右子树上，当前节点为最低公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个为空，返回非空的那个。两个都为空，则返回空。</span></span><br><span class="line">        <span class="comment">// 有一边为空。说明n1, n2在同一侧子树上。必然为 n1/n2 是 n2/n1的祖先的情况。</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="查找后继节点"><a href="#查找后继节点" class="headerlink" title="查找后继节点"></a>查找后继节点</h2><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121710824.png" alt=""></p>
<h3 id="有父指针的二叉树"><a href="#有父指针的二叉树" class="headerlink" title="有父指针的二叉树"></a>有父指针的二叉树</h3><p>求一个二叉树中一个节点的后继节点（后继节点是中序遍历后的集合每个元素的下一个元素）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode parent;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span>&#123;</span><br><span class="line">        <span class="comment">// 右子树不为空</span></span><br><span class="line">        <span class="keyword">if</span>(p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftmost</span> <span class="operator">=</span> p.right;</span><br><span class="line">            <span class="keyword">while</span>(leftmost.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                leftmost = leftmost.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> leftmost;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p.parent != <span class="literal">null</span> &amp;&amp; p.parent.left != p)&#123;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉搜索树-1"><a href="#二叉搜索树-1" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/successor-lcci/">面试题 04.06. 后继者 - 力扣（LeetCode）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode p)</span>&#123;</span><br><span class="line">        <span class="comment">// 使用一个cur指针 记录最后一次向左转的节点。即为没有右子树情况下的后继节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从根节点遍历找到p</span></span><br><span class="line">        <span class="keyword">while</span>(root.val != p.val)&#123;</span><br><span class="line">            <span class="comment">// 如果向右拐找到p cur不变。</span></span><br><span class="line">            <span class="keyword">if</span>(p.val &gt; root.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="comment">// 如果过程中向左拐了，要更新cur</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = root;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环结束时。root指向p</span></span><br><span class="line">        <span class="comment">// 如果右子树存在。则找出右子树上的leftmost。没有右子树。则返回cur</span></span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找到右子树的leftmost</span></span><br><span class="line">            root = root.right;</span><br><span class="line">            <span class="keyword">while</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两题的区别在于：</p>
<ul>
<li>二叉搜索树能通过val从root找到p</li>
<li>普通二叉树则需要通过parent指针来向上溯源。</li>
</ul>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#_&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(root.val + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> serialize(root.left);</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> serialize(root.right);</span><br><span class="line">        data.append(left).append(right);</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;#&quot;</span>.equals(arr[i]))&#123;</span><br><span class="line">                queue.add(<span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                queue.add(Integer.valueOf(arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reconTree(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reconTree</span><span class="params">(Queue&lt;Integer&gt; data)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> data.poll();</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        root.left = reconTree(data);</span><br><span class="line">        root.right = reconTree(data);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure><br>复杂度：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<h2 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h2><blockquote>
<p>纸条对折。 从纸条的上方按顺序打印折痕方向</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121905335.png" alt=""><br>左子树都是凹，右子树都是凸<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">printFoldLine</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">// 根节点为对折一次产生的凹折痕</span></span><br><span class="line">        print(n, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n表示对折次数。i为当前对折的次数。down表示折痕为凹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">boolean</span> down)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print(n, i + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(down ? <span class="string">&quot;down&quot;</span> : <span class="string">&quot;up&quot;</span>);</span><br><span class="line"></span><br><span class="line">        print(n, i + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text">迭代遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Morris-Traversal"><span class="toc-number">2.3.</span> <span class="toc-text">Morris Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81BST"><span class="toc-number">3.1.</span> <span class="toc-text">验证BST</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.</span> <span class="toc-text">完全二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81CBT"><span class="toc-number">4.1.</span> <span class="toc-text">验证CBT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">满二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">判断是否为满二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">6.1.</span> <span class="toc-text">判断是否为平衡树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">7.</span> <span class="toc-text">最低公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">查找后继节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%88%B6%E6%8C%87%E9%92%88%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.1.</span> <span class="toc-text">有父指针的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1"><span class="toc-number">8.2.</span> <span class="toc-text">二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">折纸问题</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://blog.210222.xyz/posts/binary-tree-basics"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.210222.xyz/posts/binary-tree-basics&text=Binary Tree Fundamentals"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://blog.210222.xyz/posts/binary-tree-basics&is_video=false&description=Binary Tree Fundamentals"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Binary Tree Fundamentals&body=Check out this article: https://blog.210222.xyz/posts/binary-tree-basics"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://blog.210222.xyz/posts/binary-tree-basics&title=Binary Tree Fundamentals"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://blog.210222.xyz/posts/binary-tree-basics&name=Binary Tree Fundamentals&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://blog.210222.xyz/posts/binary-tree-basics&t=Binary Tree Fundamentals"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2019-2025
    exit.
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-TK27SZJN7L"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-TK27SZJN7L');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'paranoiddemon/blog';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-light';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
