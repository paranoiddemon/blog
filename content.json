{"meta":{"title":"LANDFILL","subtitle":"","description":"Offline.","author":"exit.","url":"https://blog.210222.xyz"},"pages":[{"title":"About","date":"2020-04-19T07:52:36.000Z","updated":"2025-02-09T16:40:37.848Z","comments":false,"path":"about/index.html","permalink":"https://blog.210222.xyz/about/","excerpt":"","text":"Blog Name 「Landfill」来自Radiohead -《No surprises》 A heart that’s full up like a landfillA job that slowly kills youBruises that won’t healYou look so tired, unhappyBring down the governmentThey don’t, they don’t speak for us Influences 解体概要 - 萧沆 Bill Hicks - It&#39;s Just A Ride True Detective - Rust &amp; Martin Car Conversation Scene David Benatar - Better Never to Have Been"}],"posts":[{"title":"Feburary 2025","slug":"2025-02-08-2025-spring-festival","date":"2025-02-08T15:52:12.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/2025-spring-festival.html","permalink":"https://blog.210222.xyz/posts/2025-spring-festival","excerpt":"","text":"作为一个散光患者，我基本避开夜间开车。但今天路上堵车就拖到晚上了。各色灯光闪的我头晕目眩。开车的时候就在想象我出车祸死了的场景，其实也没什么遗憾，没有什么一定要活下去的理由，只是依着惯性活着。唯一的担心就是我爸妈会很痛苦，我还在想之后得把各个账户的钱放一个银行卡上，他们知道我的密码。 过年回去听了很多悲惨的生活。我爸的一个朋友，母亲老年痴呆屎尿失禁需要人照顾，老婆癌症，公司破产了，还有三个小孩在念书；我妈的亲戚的亲戚，一年内死了女婿和孙子。我表姐的儿子自闭症，为了多赚钱打两份工。et cetera，et cetera。各种普遍的痛苦和残酷。根本就没有上帝。对比起来我的不开心好像不值一提。有时候也不知道是不是我忍受痛苦的阈值太低了。 联想到最近看的罪与罚，拉斯柯尔尼科夫去找索尼亚，面对她的境遇也产生了这样的疑问:『既然她不能投河自尽，那她怎么能久久地处在这种地位而不发疯呢？』 上海今天是这个冬季最冷的一天。一回到小区我就感到很抑郁。因为我知道我又要面对我可悲的生活。我前几天心情挺好的，但一回来，吹着冷风，我又不可避免的变悲观。我好像拥有很多，又什么都没有。突然好想回我家的小县城，我曾经觉得那是个破地方。 假期结束了，又要开始打工了，我从两天前就开始对这件事感到焦虑，大脑不自控的不能平静，平静太奢侈了。回家躺着的两周，我感觉有个大电视还是很好的。但是我租的房子压根没有地方放，但我还是急切的想要一个大电视，或许生活就会好起来。Just get a fucking big television.","categories":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/categories/Thoughts/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"Emby HW Acceleration on N100 PVE LXC","slug":"2025-01-11-emby-hw-acceleration","date":"2025-01-11T02:52:12.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/emby-hw-acc.html","permalink":"https://blog.210222.xyz/posts/emby-hw-acc","excerpt":"","text":"Reference Hardware Acceleration with LXC on Proxmox Server - Linux - Emby Community Intel N100/iGPU Passthrough to VM and use with Docker | Proxmox Support Forum On PVE host123456789lspci -k…00:02.0 VGA compatible controller: Intel Corporation Alder Lake-N [UHD Graphics]DeviceName: Onboard - VideoSubsystem: Intel Corporation Alder Lake-N [UHD Graphics]Kernel driver in use: i915Kernel modules: i915… 12345ls -l /dev/dritotal 0drwxr-xr-x 2 root root 80 Feb 5 01:16 by-pathcrw-rw---- 1 root video 226, 0 Feb 5 01:16 card0crw-rw---- 1 root render 226, 128 Feb 5 01:16 renderD128 [!NOTE] /dev/dri/cardX 每个 cardX（如 card0, card1）表示系统中的一个显卡设备。 这是应用程序与显卡交互的主要入口。 /dev/dri/renderDXXX renderDXXX（如 renderD128, renderD129）是专门为现代应用程序设计的设备节点，主要用于无显示输出的计算任务，例如 GPU 加速的计算、OpenCL 或 Vulkan 等。 它们与显示器无关，仅用于离屏渲染任务。 /dev/dri/controlDXX controlDXX 设备节点通常用于 DRM（Direct Rendering Manager）控制接口，主要供图形服务器（如 Xorg 或 Wayland）使用。 1vi /etc/pve/lxc/101.conf # add following config to your lxc 12345lxc.cgroup2.devices.allow: c 226:0 rwm # 226是显卡设备lxc.cgroup2.devices.allow: c 226:128 rwm # 次设备号 `128` 通常对应某些特定的 GPU 子设备或驱动（例如渲染设备 `/dev/dri/renderD128`)lxc.cgroup2.devices.allow: c 29:0 rwm # Framebufferlxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dirlxc.mount.entry: /dev/fb0 dev/fb0 none bind,optional,create=file [!NOTE] lxc.cgroup2.devices.allow: c 226:0 rwm - 允许容器访问主机的 GPU 控制设备。 lxc.cgroup2.devices.allow: c 226:128 rwm - 允许容器访问主机的 GPU 渲染设备。 lxc.cgroup2.devices.allow: c 29:0 rwm - 允许容器访问主机的帧缓冲设备。 lxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dir - 挂载主机的 GPU 目录 /dev/dri 到容器。 lxc.mount.entry: /dev/fb0 dev/fb0 none bind,optional,create=file - 挂载主机的帧缓冲设备 /dev/fb0 到容器。 1chmod -R 777 /dev/dri/* # 所有用户 读写执行权限 On LXC12345678910111213sudo usermod -aG video replica # add user to groupsudo usermod -aG input replicasudo usermod -aG render replica# run emby docker and pass devicedocker run -d --name=emby --restart=always \\ -v /home/replica/emby/config:/config \\ -v /mnt/usb:/mnt/usb \\ -v /mnt/sata:/mnt/sata \\ -p 8096:8096 -p 8920:8920 \\ -e UID=1000 -e GID=100 -e GIDLIST=100 \\ --device /dev/dri:/dev/dri \\ # passthrough to docker xinjiawei1/emby_unlockd:stable","categories":[{"name":"tech","slug":"tech","permalink":"https://blog.210222.xyz/categories/tech/"}],"tags":[{"name":"homeserver","slug":"homeserver","permalink":"https://blog.210222.xyz/tags/homeserver/"}]},{"title":"November 2024","slug":"2024-11-26-November 2024","date":"2024-11-26T15:57:23.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/november-2024.html","permalink":"https://blog.210222.xyz/posts/november-2024","excerpt":"","text":"周末整理了下散落在各种设备&amp;云存储中的照片，意外地发现百度网盘上竟然备份了早年的照片，为我挽回了一些记忆的碎片。我在2024年以100KB/s的带宽，历时近20个小时，终于取回了我的数据。 我以前一直很鄙夷照片，主张感受当下，拥有好的此刻而不是好的照片。不过现在想法改变了，我发现如果没有照片来保留某些时刻，人的大脑就像缝隙过大的筛子，大部分的细节都如同残渣被过滤掉了。照片能帮助我们抵抗遗忘。 看完了「非自然死亡」。剧中的法医解剖人和切猪肉差不多。想来也是，人切开来剥皮后都是一团肉，没有比盒马的一盒猪肉高级，人类引以为傲的自我意识也逃离不了身体的消亡。 看到一些人类中心主义者怒斥流浪猫破坏生态，应该被捕杀。感觉很荒谬。人类作为地球生态的最大破坏者，都还恬不知耻的活在地球上。 如果人类比其他物种高级，那么有些人类是不是也比另外另外一些人类高级？1 给自己找了很多事情做来填充时间的空白。整理照片，看网络小说，折腾NAS。每天都能忙到半夜，不给大脑留出空暇。 References: 1. “The Superior Human?” - YouTube &#8617;","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"Return to RSS","slug":"2022-12-27-Return to RSS","date":"2022-12-27T09:44:00.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/return-to-rss.html","permalink":"https://blog.210222.xyz/posts/return-to-rss","excerpt":"","text":"Currently, I have my information sources scattered across different platforms, including newsletters, Telegram channels, Twitter, blogs, and webpages saved in Pocket. I used to use Inoreader as an RSS client to subscribe to my RSS sources, but the free plan had many limitations and was also blocked by the China Great Firewall. Therefore, I decided to choose a self-hosted RSS reader. The main options included Miniflux, FreshRSS, and Tiny Tiny RSS. I ultimately chose Miniflux because it is lightweight and has all the features I need. Install docker compose pluginInstall the Compose plugin | Docker DocumentationIf you already have Docker Engine and Docker CLI installed, you can install the Compose plugin from the command line123sudo apt-get updatesudo apt-get install docker-compose-plugindocker compose version Create docker-compose.ymlInstallation Instructions12mkdir minifluxvim docker-compose.yml v2/basic.yml at main · miniflux/v2 · GitHubEdit your config: port , username, password etc. When using Docker Compose, it is important to remember not to include the ` symbol in your password. If you do need to use ` in your password, you will need to escape it using a backslash, like this: \\$. This is because $VARIABLE and $&#123;VARIABLE&#125; are used for variable substitution in docker-compose.yml. I learned this the hard way when I used a password generated by Bitwarden and didn’t realize it contained a dollar sign. It took me a while to figure out the issue.” 12345678910111213141516171819202122232425262728293031323334version: &#x27;3.4&#x27;services: miniflux: image: $&#123;MINIFLUX_IMAGE:-miniflux/miniflux:latest&#125; container_name: miniflux restart: always ports: - &quot;80:8080&quot; depends_on: - db environment: - DATABASE_URL=postgres://miniflux:secret@db/miniflux?sslmode=disable - RUN_MIGRATIONS=1 - CREATE_ADMIN=1 - ADMIN_USERNAME=admin - ADMIN_PASSWORD=test123 - DEBUG=1 # Optional health check: # healthcheck: # test: [&quot;CMD&quot;, &quot;/usr/bin/miniflux&quot;, &quot;-healthcheck&quot;, &quot;auto&quot;] db: image: postgres:15 container_name: postgres environment: - POSTGRES_USER=miniflux - POSTGRES_PASSWORD=secret volumes: - miniflux-db:/var/lib/postgresql/data healthcheck: test: [&quot;CMD&quot;, &quot;pg_isready&quot;, &quot;-U&quot;, &quot;miniflux&quot;] interval: 10s start_period: 30svolumes: miniflux-db: docker compose up | Docker Documentation12345# first start the db. -d means detached, run in the backgrounddocker compose up -d db # and then the application.docker compose up -d miniflux Reverse Proxy with CaddyAdd CNAME record in the DNS for your domain.Edit Caddyfile and restart caddy service 1vim /etc/caddy/Caddyfile 1234rss.your.domain &#123; reverse_proxy localhost:port&#125; Useful tools to work with RSS Convert newsletter to RSS: Kill the Newsletter! Pocket RSS: https://getpocket.com/users/[username]/feed/all, subscribe with username and password RSSHub: RSSHub is a RSS feed generator to make everything RSSible. iOS client: Unread is a very beautiful RSS reader for iOS that supports the Fever API","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"https://blog.210222.xyz/tags/Programming/"}]},{"title":"Deploy Code Server on Ubuntu","slug":"2022-12-14-Deploy Code Server on Ubuntu","date":"2022-12-14T13:44:00.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/deploy-code-server.html","permalink":"https://blog.210222.xyz/posts/deploy-code-server","excerpt":"","text":"https://github.com/coder/code-server 1. Intall123# install scriptcurl -fsSL https://code-server.dev/install.sh | shsudo systemctl enable --now code-server@$USER 2. Configure1vim ~/.config/code-server/config.yaml Set 0.0.0.0 to allow any IP to visit.1234bind-addr: 0.0.0.0:8080auth: passwordpassword: 123456cert: false 1systemctl restart code-server@$USER 3. Reverse Proxy with Caddy123456# installsudo apt install -y debian-keyring debian-archive-keyring apt-transport-httpscurl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#x27; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpgcurl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#x27; | sudo tee /etc/apt/sources.list.d/caddy-stable.listsudo apt updatesudo apt install caddy 12# Configvim /etc/caddy/Caddyfile 1234code.your.domain&#123; reverse_proxy localhost:8080&#125; 1234# run Caddy as service# https://github.com/caddyserver/dist/blob/master/init/caddy.servicevim /etc/systemd/system/caddy.service 12345678910111213141516171819202122232425262728293031323334353637# caddy.service## For using Caddy with a config file.## Make sure the ExecStart and ExecReload commands are correct# for your installation.## See https://caddyserver.com/docs/install for instructions.## WARNING: This service does not use the --resume flag, so if you# use the API to make changes, they will be overwritten by the# Caddyfile next time the service is restarted. If you intend to# use Caddy&#x27;s API to configure it, add the --resume flag to the# `caddy run` command or use the caddy-api.service file instead.[Unit]Description=CaddyDocumentation=https://caddyserver.com/docs/After=network.target network-online.targetRequires=network-online.target[Service]Type=notifyUser=caddyGroup=caddyExecStart=/usr/bin/caddy run --environ --config /etc/caddy/CaddyfileExecReload=/usr/bin/caddy reload --config /etc/caddy/Caddyfile --forceTimeoutStopSec=5sLimitNOFILE=1048576LimitNPROC=512PrivateDevices=yesPrivateTmp=trueProtectSystem=fullAmbientCapabilities=CAP_NET_BIND_SERVICE[Install]WantedBy=multi-user.target 12sudo systemctl enable --now caddysystemctl status caddy 4. Set subdomain DNSAdd CNAME record in DNS Name: codevalue: your.domain It’s all set now. Visit code.your.domain and test.","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"https://blog.210222.xyz/tags/Programming/"}]},{"title":"LeetCode Weekly Contest 301","slug":"2022-7-11-LeetCode周赛 301","date":"2022-07-11T06:44:00.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/LC-weekly-contest-301.html","permalink":"https://blog.210222.xyz/posts/LC-weekly-contest-301","excerpt":"","text":"Q16112. 装满杯子需要的最短总时长 - 力扣（LeetCode） 提交1234567891011121314151617181920class Solution &#123; public int fillCups(int[] amount) &#123; Arrays.sort(amount); int min = amount[0]; int mid = amount[1]; int max = amount[2]; int res = 0; res += min; // 先把max 减到和mid一样 while(min &gt;0 &amp;&amp; max &gt; mid)&#123; max--; min--; &#125; // 然后再同时减 max -= min/2; mid -= (min + 1)/2; res += Math.max(max, mid); return res; &#125;&#125; 贪心从最大的两个数开始减少1234567891011121314class Solution &#123; public int fillCups(int[] amount) &#123; int res = 0; while(true)&#123; // 每次都排序。从最大的两个数开始减。如果中间的数都为0。再加上残余的最大值。 Arrays.sort(amount); if (amount[1] == 0) break; amount[2]--; amount[1]--; res++; &#125; return res + amount[2]; &#125;&#125; 公式如果 最大值 大于另外两个和。返回最大值如果 最大值小于另外两个和。a &gt;= b &gt;= c当 a &lt;= b +c的时候，每次必然可以拿两个数。当a - 1, b-1, c 最大值仍然为a时， 还是满足a &lt;= b +c这个性质。每次都可以从两边拿当最大值变为c的时候，c同样可以和a一样操作1234567class Solution &#123; public int fillCups(int[] a) &#123; Arrays.sort(a); if(a[2] &gt;= a[0] + a[1]) return a[2]; else return (a[0] + a[1] + a[2] + 1) /2; &#125;&#125; Q26113. 无限集中的最小数字 - 力扣（LeetCode） 提交1234567891011121314151617181920212223242526272829303132333435class SmallestInfiniteSet &#123; int[] s = new int[1000]; public SmallestInfiniteSet() &#123; for(int i = 0; i &lt; 1000; i++)&#123; s[i] = i + 1; &#125; &#125; public int popSmallest() &#123; int res = 0; for(int i = 0; i &lt; 1000; i++)&#123; if(s[i] != -1) &#123; res = s[i]; s[i] = -1; break; &#125; &#125; return res; &#125; public void addBack(int num) &#123; if(s[num-1] == -1)&#123; s[num - 1] = num; &#125; &#125;&#125;/** * Your SmallestInfiniteSet object will be instantiated and called as such: * SmallestInfiniteSet obj = new SmallestInfiniteSet(); * int param_1 = obj.popSmallest(); * obj.addBack(num); */ set使用set存被删除的数。无限集如果数据量大的话，就过不了了。12345678910111213141516171819class SmallestInfiniteSet &#123; HashSet&lt;Integer&gt; set; public SmallestInfiniteSet() &#123; set=new HashSet&lt;&gt;(); &#125; public int popSmallest() &#123; int res=1; while(set.contains(res))&#123; res++; &#125; set.add(res); return res; &#125; public void addBack(int num) &#123; if(set.contains(num)) set.remove(num); &#125;&#125; Q36114. 移动片段得到字符串 - 力扣（LeetCode）同 777. 在LR字符串中交换相邻字符 - 力扣（LeetCode） 提交1234567891011121314151617181920212223242526class Solution &#123; public boolean canChange(String start, String target) &#123; int n = start.length(); // L不能超过L的原始位置。只能往左。R也是同理。 if(!start.replace(&quot;_&quot;, &quot;&quot;).equals(target.replace(&quot;_&quot;, &quot;&quot;))) return false; int t = 0; for (int i = 0; i &lt; n; i++) if (start.charAt(i) == &#x27;L&#x27;) &#123; while (target.charAt(t) != &#x27;L&#x27;) t++; if (i &lt; t++) return false; &#125; t = 0; for (int i = 0; i &lt; n;i++) if (start.charAt(i) == &#x27;R&#x27;) &#123; // 如果i 不大于t t移动到下一个位置。继续寻找下一个L R while (target.charAt(t) != &#x27;R&#x27;) t++; if (i &gt; t++) return false; &#125; return true; &#125;&#125; 双指针1234567891011121314151617181920class Solution &#123;public: bool canChange(string start, string target) &#123; int n = start.size(); for(int i = 0,j = 0;i &lt; n;) &#123; while(i &lt; n &amp;&amp; start[i] == &#x27;_&#x27;)i++; while(j &lt; n &amp;&amp; target[j] == &#x27;_&#x27;)j++; // 如果分别为L R 显然相对位置不同。返回false if(start[i] != target[j])return false; // target的L要在更左。R要在更右。 if(start[i] == &#x27;R&#x27; &amp;&amp; j &lt; i)return false; if(start[i] == &#x27;L&#x27; &amp;&amp; j &gt; i)return false; i++; j++; &#125; return true; &#125;&#125;; Q46115. 统计理想数组的数目 - 力扣（LeetCode） 组合数 DP n是数组的长度，t是不同元素的个数。如果可以相同，就是计算组合数从n -1个位置里 选出t-1个位置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; const int MOD = 1000000007; const int MAXP = 16; // 2^16 &gt; 10000, n &lt;= 10000public: int idealArrays(int n, int K) &#123; // nlnn 求因数 vector&lt;vector&lt;int&gt;&gt; fac(K + 1); for (int i = 1; i &lt;= K; i++) // 求的是j的因数的数组 for (int j = i &lt;&lt; 1; j &lt;= K; j += i) fac[j].push_back(i); // 计算子问题的答案 vector&lt;vector&lt;long long&gt;&gt; f; f.resize(K + 1, vector&lt;long long&gt;(20)); // i的最大值为K for (int i = 1; i &lt;= K; i++) &#123; // 以1为结尾只有一种方案 f[i][1] = 1; for (int j = 2; j &lt;= MAXP; j++) // t是i的因数。加上子问题的方案书。以因数为结尾。长度减去1的情况 for (int t : fac[i]) f[i][j] = (f[i][j] + f[t][j - 1]) % MOD; &#125; // 求组合数 vector&lt;vector&lt;long long&gt;&gt; C; C.resize(n + 1, vector&lt;long long&gt;(20)); C[0][0] = C[1][0] = C[1][1] = 1; for (int i = 2; i &lt;= n; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i &amp;&amp; j &lt;= MAXP; j++) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD; &#125; // 统计最终答案 long long ans = 0; for (int i = 1; i &lt;= K; i++) for (int j = 1; j &lt;= MAXP; j++) // 以i为最后一个元素。且数组长度为j的数量。组合数-&gt; 计算出元素重复使用的情况 ans = (ans + C[n - 1][j - 1] * f[i][j]) % MOD; return ans; &#125;&#125;; 暴力搜索123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int n, m; int ans = 0; const int MOD = 1e9 + 7; vector&lt;vector&lt;int&gt;&gt; f; void dfs(int u, int cnt) &#123; ans = (ans + f[n - 1][cnt - 1]) % MOD; // 数组长度小于n if (cnt &lt; n) &#123; // 从起点开始 乘以所有的质因数，小于最大值 for (int i = 2; i * u &lt;= m; i ++ ) dfs(i * u, cnt + 1); &#125; &#125; int idealArrays(int n, int m) &#123; this-&gt;n = n, this-&gt;m = m; f = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(20)); for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; 20 &amp;&amp; j &lt;= i; j ++ ) // j为0 if (!j) f[i][j] = 1; // 组合数 else f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % MOD; for (int i = 1; i &lt;= m; i ++ ) // 从1开始搜索 到最大值为止。 dfs(i, 1); return ans; &#125;&#125;;","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"https://blog.210222.xyz/tags/Programming/"}]},{"title":"Golang Notes","slug":"2022-06-16-Golang笔记","date":"2022-06-16T04:00:00.000Z","updated":"2025-02-09T16:40:37.848Z","comments":true,"path":"posts/go-basic.html","permalink":"https://blog.210222.xyz/posts/go-basic","excerpt":"","text":"0. refGo 语言之旅 Go web develop Halfrost-Field/new_gopher_tips.md at master · halfrost/Halfrost-Field topgoer · Go语言中文文档 Go sync.Cond | Go 语言高性能编程 | 极客兔兔 《Go 入门指南》 | Go 技术论坛 1. 简介诞生 类C 2. Go安装windows linux 3. IDE及工具Goland From JetbrainsVScode 4. 包，变量和函数Go语言的基本类型有： bool string int、int8、int16、int32、int64 uint、uint8、uint16、uint32、uint64、uintptr byte // uint8 的别名 rune // int32 的别名 代表一个 Unicode 码 float32、float64 complex64、complex128 当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。 包 package1234567891011package mainimport ( &quot;fmt&quot; &quot;math&quot; // 多导入)func main() &#123; fmt.Printf(&quot;Now you have %g problems.\\n&quot;, math.Sqrt(7))&#125; 导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。 pizza 和 pi 并未以大写字母开头，所以它们是未导出的。在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。 123456789101112package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; //fmt.Println(math.pi) // undefined: math.pi fmt.Println(math.Pi)&#125; 常量、变量:= 初始化赋值 var 关键字 12345678910111213141516171819202122232425262728// var 变量名 变量类型package main import &quot;fmt&quot; func main()&#123; // 单个声明 var a, b *int fmt.Println(a, b) c := 10 b = &amp;c fmt.Println(b) //0xc00000a0e0 // 批量声明 var ( a int b string c []float32 d func() bool e struct &#123; x int &#125; ) // 简化。名字 := 表达式 a:= 1 b:= 2&#125; 常量的声明与变量类似，只不过是使用 const 关键字。 常量可以是字符、字符串、布尔值或数值。 常量不能用 := 语法声明。 123456789101112131415package mainimport &quot;fmt&quot;const Pi = 3.14func main() &#123; const World = &quot;世界&quot; fmt.Println(&quot;Hello&quot;, World) fmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;) const Truth = true fmt.Println(&quot;Go rules?&quot;, Truth)&#125; booltrue false == != &amp;&amp; || ! 数字类型 float32的精度是小数点后七位 有效数字为2^23次方 只有七位数 float64是小数点后15位 类型转换123456789101112表达式 T(v) 将值 v 转换为类型 T。一些关于数值的转换：var i int = 42var f float64 = float64(i)var u uint = uint(f)或者，更加简单的形式：i := 42f := float64(i)u := uint(f) 类型推导在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。 当右值声明了类型时，新变量的类型与其相同： 12var i intj := i // j 也是一个 int 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度： 123i := 42 // intf := 3.142 // float64g := 0.867 + 0.5i // complex128 golang格式化输出-fmt包用法详解 复数complex64 (32 位实数和虚数) complex128 (64 位实数和虚数) byte Go提供了两种大小的复数类型：complex64和complex128，分别由float32和float64组成。内置函数complex从指定的实部和虚部构建复数，内置函数real和imag用来获取复数的实部和虚部： 12345var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4ifmt.Println(x*y) // &quot;(-5+10i)&quot;fmt.Println(real(x*y)) // &quot;-5&quot;fmt.Println(imag(x*y)) // &quot;10&quot; 字符串%s strings 和 strcov包 指针*p 取出地址中的值 &amp;a 获得指针。 1234567891011121314var a string = &quot;a1&quot;func main() &#123; //var p *string //p = &amp;a p := &amp;a fmt.Printf(&quot;%p\\n&quot;, p) fmt.Printf(&quot;%s\\n&quot;, *p) fmt.Printf(&quot;%p&quot;, &amp;p)&#125;//0xf43c30//a1//0xc000006028 结构体 structgo语句结尾不需要分号 Go支持C语言风格的 /* */块注释，也支持C＋＋风格的 //行注释。 当然，行注释更通用，块注释主要用于针对包的详细说明或者屏蔽大块的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport &quot;fmt&quot;func main() &#123; // &amp; 获取变量的内存地址 // * 获取指针变量的值。即内存地址是的值。 k := 1 m := &amp;k fmt.Println(k) // 1 fmt.Println(m) // 0xc0000be008 &amp;k是内存地址 fmt.Println(*m) // 1 *pointer是读取内存地址的值。 // fmt.Println(*k) 这种写法的会编译错误 Invalid Indirect *运算符不能用在字面量上。 只能指向指针变量 *m = 10 fmt.Println(m) // 0xc00000a0a8 fmt.Println(k) // 10 // 等价 fmt.Println(Vertex&#123;x: 1,y:2&#125;) // &#123;1, 2&#125; fmt.Println(Vertex&#123;1, 2&#125;) v:=Vertex&#123;10,23&#125; fmt.Println(v.x) // 10 fmt.Println(v.y) // 23 // 如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。 // 不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。 // pointer是个指针。理论上应该(*pointer).x 但是这两种写法都是一样的。 (*pointer).x与 *pointer.x的区别。 pointer := &amp;v fmt.Println((*pointer).x) fmt.Println(pointer.x) // var关键字的作用： var( v1 = Vertex&#123;1, 2&#125; v2 = Vertex&#123;x: 1&#125;// 如果只赋值一个另一个会为初始化值 v3 = Vertex&#123;&#125; v4 = Vertex&#123;y: 1&#125; // 如果使用了name:value就不用顺序。 p = &amp;Vertex&#123;1,2&#125; // 特殊的前缀 &amp; 返回一个指向结构体的指针。 ) fmt.Println(v1, p , v2, v3, v4) // &#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; &#123;0 1&#125; fmt.Println(p.x) // 1 fmt.Println(*p) // &#123;1 2&#125;&#125;/*Vertex type定义结构体 一个结构体（struct）就是一组字段（field）。struct中的属性通过.访问*/type Vertex struct&#123; // go的类型在后面。 x int y int&#125; 数组 array类型 [n]T 表示拥有 n 个 T 类型的值的数组。 表达式: var a [10]int 会将变量 a 声明为拥有 10 个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; var a [2]int var b [3]string fmt.Println(a) //[0 0] fmt.Println(b) // [ ] b[0] = &quot;hello&quot; b[1] = &quot;world=&quot; b[2] = &quot;fuck&quot; // 如果后面还有元素 就会跟上空格。如果是最后一个元素就不会有空格 [hello world= fuck] fmt.Println(b) // [hello world ] // 初始化赋值。其实和java差不多。就是类型后置了 c := [2]int&#123;1,3&#125; fmt.Println(c) // [1 3] var d = [2]int&#123;2,2&#125; fmt.Println(d)&#125; 切片 sliceGolang 入门 : 切片(slice) - sparkdev - 博客园 每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：a[low : high] 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。 a[1:4]表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素： 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main()&#123; a := [5]int&#123;1,2,3,4,5&#125; // 前include 后exclude b := a[0:1] fmt.Println(b) // [1] var c = a[0:1] fmt.Println(c) var d []int = a[0:2] // Type can be omitted fmt.Println(d) // [1 2] var e []int fmt.Println(e) // [] 默认为空。和其他的类型的初始化值一样 var f []*int fmt.Println(f) // 切片会打印 [] var g [2]*int fmt.Println(g) // 数组会打印 [&lt;nil&gt; &lt;nil&gt;]&#125; 切片就像数组的引用切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改。 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main() &#123; names := [4]string&#123; &quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &#125; fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = &quot;XXX&quot; // 切片的b[0] 在数组中是索引1位置 fmt.Println(a, b) fmt.Println(names)&#125;/**[John Paul George Ringo][John Paul] [Paul George][John XXX] [XXX George][John XXX George Ringo]*/ 切片文法切片文法类似于没有长度的数组文法。这是一个数组文法：[3]bool&#123;true, true, false&#125;下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：[]bool&#123;true, true, false&#125; 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;func main() &#123; q := []int&#123;2, 3, 5, 7, 11, 13&#125; fmt.Println(q) r := []bool&#123;true, false, true, true, false, true&#125; fmt.Println(r) s := []struct &#123; i int b bool &#125;&#123; &#123;2, true&#125;, &#123;3, false&#125;, &#123;5, true&#125;, &#123;7, true&#125;, &#123;11, false&#125;, &#123;13, true&#125;, &#125; fmt.Println(s)/*[2 3 5 7 11 13][true false true true false true][&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;]*/&#125; 切片的默认行为在进行切片时，你可以利用它的默认行为来忽略上下界。切片下界的默认值为 0，上界则是该切片的长度。 对于数组var a [10]int来说，以下切片是等价的： 12345a[0:10]a[:10]a[0:]a[:] 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;2, 3, 5, 7, 11, 13&#125; s = s[1:4] fmt.Println(s) // :不能省略 s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s)&#125; 切片的长度与容量切片拥有 长度 和 容量。 切片的长度len就是它所包含的元素个数。 切片的容量cap是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。 12345678910111213141516package mainimport &quot;fmt&quot;func main()&#123; a:= [5]int&#123;1,2,3,4,5&#125; b:= a[1:2] fmt.Println(b) //[2] fmt.Println(&quot;len:&quot; ,len(b), &quot;cap:&quot;, cap(b)) //len: 1 cap: 4 //:= 只有初始化声明的时候才使用 b = a[2:] fmt.Println(b) //[3 4 5] fmt.Println(&quot;len:&quot; ,len(b), &quot;cap:&quot;, cap(b)) //len: 3 cap: 3&#125; 切片的零值是 nil。nil 切片的长度和容量为 0 且没有底层数组。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var s []int fmt.Println(s, len(s), cap(s)) if s == nil &#123; fmt.Println(&quot;nil!&quot;) &#125;&#125; 用 make 创建切片 切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数： 12345b := make([]int, 0, 5) // len(b)=0, cap(b)=5b = b[:cap(b)] // len(b)=5, cap(b)=5b = b[1:] // len(b)=4, cap(b)=4 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; a := make([]int, 5) printSlice(&quot;a&quot;, a) b := make([]int, 0, 5) // 第一个参数为len 第二个参数为cap printSlice(&quot;b&quot;, b) c := b[:2] printSlice(&quot;c&quot;, c) d := c[2:5] printSlice(&quot;d&quot;, d)&#125;func printSlice(s string, x []int) &#123; fmt.Printf(&quot;%s len=%d cap=%d %v\\n&quot;, s, len(x), cap(x), x)&#125;/*a len=5 cap=5 [0 0 0 0 0]b len=0 cap=5 []c len=2 cap=5 [0 0]d len=3 cap=3 [0 0 0]*/ 切片的切片。和二维数组差不多 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; // 创建一个井字板（经典游戏） board := [][]string&#123; []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, []string&#123;&quot;_&quot;, &quot;_&quot;, &quot;_&quot;&#125;, &#125; // 两个玩家轮流打上 X 和 O board[0][0] = &quot;X&quot; board[2][2] = &quot;O&quot; board[1][2] = &quot;X&quot; board[1][0] = &quot;O&quot; board[0][2] = &quot;X&quot; for i := 0; i &lt; len(board); i++ &#123; fmt.Printf(&quot;%s\\n&quot;, strings.Join(board[i], &quot; &quot;)) &#125;&#125; 向切片追加元素为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。 func append(s []T, vs ...T) []Tappend 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。append 的结果是一个包含原切片所有元素加上新添加元素的切片。 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。 Go 切片：用法和本质 - Go 语言博客 12345678910111213141516171819202122232425package mainimport &quot;golang.org/x/tour/pic&quot;// Pic() Pic是一个结构体 返回一个[][]uint8func Pic(dx, dy int) [][]uint8 &#123; // 使用make 创建dy长度的外层切片。里面是[]uint8的切片 a := make([][]uint8, dy) for x:= range a&#123; // 使用循环赋值 // 初始化内层slice b := make([]uint8, dx) // 内层长度为dx for y:= range b&#123; b[y] = uint8(x^y) // 还要使用uint8进行转换。 &#125; a[x] = b &#125; return a&#125;func main() &#123; pic.Show(Pic)&#125; Rangefor 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。 可以将下标或值赋予 _ 来忽略它。 123456for i, _ := range powfor _, value := range pow// 若你只需要索引，忽略第二个变量即可。for i := range pow 12345678910111213141516171819202122232425262728293031323334353637package mainimport &quot;fmt&quot;import &quot;reflect&quot;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; for i, v := range a &#123; // Printf和Println不同 fmt.Printf(&quot;%d : %d \\n&quot;, i, v) /* 0 : 1 1 : 2 2 : 3 3 : 4 4 : 5 */ &#125; // Redundant &#x27;_&#x27; expression。可以直接不写第二个 for i, _ := range a &#123; fmt.Printf(&quot;%d \\n&quot;, i) &#125; fmt.Println(&quot;-------------&quot;) b := []int&#123;1&#125; // 但是如果要省略第一个参数就必须要写_ 第一个是索引，第二个是数组中变量的copy for i, v := range b &#123; fmt.Println(reflect.TypeOf(v)) //int reflect包 反射 p1 := &amp;v; //0xc00000a0e0 p2 := &amp;a[i] fmt.Println(p1) // 0xc00000a0e0 fmt.Println(p2) // 0xc00000c510 fmt.Println(p1 == p2) // false 可以看到是元素的copy。内存地址不同。 fmt.Printf(&quot;%d \\n&quot;, v) &#125;&#125; Map零值为 nil 。nil 映射既没有键，也不能添加键。make 函数会返回给定类型的映射，并将其初始化备用。 123456789101112131415161718package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m map[string]Vertexfunc main() &#123; m = make(map[string]Vertex) m[&quot;Bell Labs&quot;] = Vertex&#123; 40.68433, -74.39967, &#125; fmt.Println(m[&quot;Bell Labs&quot;]) // &#123;40.68433 -74.39967&#125;&#125; map的文法与结构体相似，不过必须有键名。 123456789101112131415161718192021package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123; &quot;Bell Labs&quot;: Vertex&#123; 40.68433, -74.39967, &#125;, &quot;Google&quot;: Vertex&#123; 37.42202, -122.08408, &#125;,&#125;func main() &#123; fmt.Println(m) // map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]&#125; 1234567891011121314151617package mainimport &quot;fmt&quot;type Vertex struct &#123; Lat, Long float64&#125;var m = map[string]Vertex&#123;// 可以省略Vertex &quot;Bell Labs&quot;: &#123;40.68433, -74.39967&#125;, &quot;Google&quot;: &#123;37.42202, -122.08408&#125;,&#125;func main() &#123; fmt.Println(m)&#125; 多赋值 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport &quot;fmt&quot;func main()&#123; // map[keyType]valueType var m1 map[int]int m1 = map[int]int&#123;1:1&#125; fmt.Println(m1) // map[1:1] m2 := map[string]int&#123; &quot;a&quot;: 1, &quot;b&quot;: 2, // 需要后面带个， &#125; fmt.Println(m2) // map[a:1 b:2] // 修改key的值 m2[&quot;a&quot;] = 3 fmt.Println(m2) // map[a:3 b:2] // 获取key值 fmt.Println(m2[&quot;a&quot;]) // 3 // 删除key delete(m2,&quot;a&quot;) // 不返回东西 fmt.Println(m2) // map[b:2] elem, ok := m2[&quot;a&quot;] fmt.Println(elem) // 0 fmt.Println(ok) // false m3:= map[int]string&#123; 1:&quot;a&quot;, 2:&quot;b&quot;, &#125; elem1, ok1 := m3[3] // 如果前面声明，则elem的类型为int。Cannot assign string to elem (type int) in multiple assignment fmt.Println(elem1) // 如果不存在其零值和value类型的零值一致 fmt.Println(ok1) // false&#125; 练习 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;golang.org/x/tour/wc&quot; &quot;strings&quot; // 不需要, 但是包名要引号 )// func 结构体中的函数，往结构体中传入参数string。有点类似class 后面map[string]int是返回值func WordCount(s string) map[string]int &#123; // 初始化一个map var m = make(map[string]int) // 获取分割后的string数组。 Fields和Split的区别 strs := strings.Fields(s) for _, v := range strs&#123; // if赋值和判断一起写 if elem, ok:= m[v]; ok &#123; elem++ // go中++不能在左边。只能作为语句不能做为表达式 m[v] = elem &#125;else&#123; m[v] = 1 &#125; &#125; return m&#125;func main() &#123; wc.Test(WordCount)&#125; func Fields(s string) []stringFields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning an array of substrings of s or an empty list if s contains only white space. func Split(s, sep string) []stringSplit slices s into all substrings separated by sep and returns a slice of the substrings between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. 1234567891011 fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;)) fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;)) fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;)) fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&#x27;Higgins&quot;)) /*[&quot;a&quot; &quot;b&quot; &quot;c&quot;][&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;][&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;][&quot;&quot;]*/ 函数 function函数可以将其他函数调用作为它的参数，只要这个被调用函数的返回值个数、返回值类型和返回值的顺序与调用函数所需求的实参是一致的，例如： 假设 f1 需要 3 个参数 f1(a, b, c int)，同时 f2 返回 3 个参数 f2(a, b int) (int, int, int)，就可以这样调用 f1：f1(f2(a, b))。 Go不允许函数重载，Go 语言不支持这项特性的主要原因是函数重载需要进行多余的类型匹配影响性能；没有重载意味着只是一个简单的函数调度。所以你需要给不同的函数使用不同的名字，我们通常会根据函数的特征对函数进行命名 type binOp func(int, int) int 定义函数类型如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加 &amp; 符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 Function(&amp;arg1)，此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。（译者注：指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。） 声明12345678910111213package mainimport &quot;fmt&quot;// x int, y int 可以缩写为 x, y int func add(x, y int) int &#123; return x + y&#125;func main() &#123; fmt.Println(add(42, 13))&#125; 函数也是值。它们可以像其它值一样传递。 函数值可以用作函数的参数或返回值。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;math&quot;)// f1 是func(float64, float64) float64类型的参数。 compute 的返回值是float64func compute(f1 func(float64, float64) float64, x, y float64) float64 &#123; // 调用f1, 和操作数 x y return f1(x,y)&#125;func main() &#123; // hypotenuse 斜边 hypot := func(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y) &#125; // 计算3, 4的斜边 传入的函数必须符合定义的类型 func(float64, float64) float64 fmt.Println(compute(hypot, 3, 4)) // 5 // 计算2的3次方 fmt.Println(compute(math.Pow, 2, 3)) // 8&#125; 闭包 closureGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。 例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;// 参数为空， 返回值为函数，func(int) int 函数传入一个int，返回阳一个int func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 闭包练习 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;// 返回一个“返回int的函数”func fibonacci() func() int &#123; pre1:= 0 pre2:= 1 return func() int&#123; tmp:= pre1 // 可以同时赋值。 // 要优先计算出所有右值，然后再从左到右依次赋值 右边的计算会先进行。之后才会赋值 pre1,pre2 = pre2, (pre1 + pre2) return tmp &#125;&#125;func main() &#123; f := fibonacci() for i := 0; i &lt; 10; i++ &#123; fmt.Println(f()) &#125;&#125; 内置函数Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。 以下是一个简单的列表，我们会在后面的章节中对它们进行逐个深入的讲解。 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make 用来分配内存，返回Type本身(只能应用于slice, map, channel)&lt;br&gt;用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包 complex、real、imag 用于创建和操作复数（详见第 4.5.2.2 节） 日期时间运算符位运算 算术运算符 ++ —只能用于后缀 逻辑运算符 优先级 运算符7 ^ !6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^5 + - | ^4 == != &lt; &lt;= &gt;= &gt;3 &lt;-2 &amp;&amp;1 || fmt print12345678910Print: 输出到控制台(不接受任何格式化，它等价于对每一个操作数都应用 %v) fmt.Print(str)Println: 输出到控制台并换行 fmt.Println(tmp)Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量 fmt.Printf(&quot;%d&quot;,a)Sprintf：格式化并返回一个字符串而不带任何输出。 s := fmt.Sprintf(&quot;a %s&quot;, &quot;string&quot;) fmt.Printf(s)Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout。 fmt.Fprintf(os.Stderr, “an %s\\n”, “error”) Go语言fmt.Printf使用指南（占位符总结）格式化打印 加精！！！_youngsailor的博客-CSDN博客 12345678%v: 以默认的方式打印变量的值（万能占位符，如果不知道变量是什么类型，用%v即可，go语言会自动为你识别）%+d 带符号的整型%d 正号不带。负数还是会带%q 打印单引号%q 字符串带双引号，字符串中的引号带转义符 named return12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func split(sum int) (x, y int) &#123; x = sum * 4 / 9 y = sum - x return&#125;func main() &#123; fmt.Println(split(17))&#125;// 相当于在函数一开始就申明了变量x y zfunc split(sum int) (x, y, z int) &#123; x = 1 y = 2 y = 3 z = 4 return&#125;func main() &#123; fmt.Println(split(17)) // 1 3 4&#125; 相当于在函数一开始就申明了变量x y。 return空的时候，就会返回声明的值 Go’s return values may be named. If so, they are treated as variables defined at the top of the function. These names should be used to document the meaning of the return values. A return statement without arguments returns the named return values. This is known as a “naked” return. Naked return statements should be used only in short functions, as with the example shown here. They can harm readability in longer functions. 5. 控制结构if else1234567if condition1 &#123; // do something &#125; else if condition2 &#123; // do something else &#125; else &#123; // catch-all or default&#125; 关键字 if 和 else 之后的左大括号 &#123; 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 &#125; 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。 多返回值12345678if err := file.Chmod(0664); err != nil &#123; fmt.Println(err) return err&#125;if value, ok := readData(); ok &#123;…&#125; 在if语句中进行初始化 使用_丢弃返回值 123456789func mySqrt(f float64) (v float64, ok bool) &#123; if f &lt; 0 &#123; return &#125; // error case return math.Sqrt(f),true&#125;func main() &#123; t := mySqrt(25.0) fmt.Println(t)&#125; switch case不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; fall through 12345switch i &#123; case 0: fallthrough case 1: f() // 当 i == 0 时函数也会被调用&#125; 替换if else 12345678switch &#123; case i &lt; 0: f1() case i == 0: f2() case i &gt; 0: f3()&#125; for如果想要重复执行某些语句，Go 语言中您只有 for 结构可以使用。没有while 普通for和java一样 除了没有() 123456789package mainimport &quot;fmt&quot;func main() &#123; for i := 0; i &lt; 5; i++ &#123; fmt.Printf(&quot;This is the %d iteration\\n&quot;, i) &#125;&#125; 类似while123456789101112package mainimport &quot;fmt&quot;func main() &#123; var i int = 5 for i &gt;= 0 &#123; i = i - 1 fmt.Printf(&quot;The variable i is now: %d\\n&quot;, i) &#125;&#125; 无限循环条件语句是可以被省略的，如 i:=0; ; i++ 或 for &#123; &#125; 或 for ;; &#123; &#125;（;; 会在使用 gofmt 时被移除）：这些循环的本质就是无限循环。最后一个形式也可以被改写为 for true &#123; &#125;，但一般情况下都会直接写 for &#123; &#125; for range12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; str := &quot;Go is a beautiful language!&quot; fmt.Printf(&quot;The length of str is: %d\\n&quot;, len(str)) for pos, char := range str &#123; fmt.Printf(&quot;Character on position %d is: %c \\n&quot;, pos, char) &#125; fmt.Println() str2 := &quot;Chinese: 日本語&quot; fmt.Printf(&quot;The length of str2 is: %d\\n&quot;, len(str2)) for pos, char := range str2 &#123; fmt.Printf(&quot;character %c starts at byte position %d\\n&quot;, char, pos) &#125; fmt.Println() fmt.Println(&quot;index int(rune) rune char bytes&quot;) for index, rune := range str2 &#123; fmt.Printf(&quot;%-2d %d %U &#x27;%c&#x27; % X\\n&quot;, index, rune, rune, rune, []byte(string(rune))) &#125;&#125; break continue嵌套的循环体，break 只会退出最内层的循环 标签 goto1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123;LABEL1: for i := 0; i &lt;= 5; i++ &#123; for j := 0; j &lt;= 5; j++ &#123; if j == 4 &#123; continue LABEL1 &#125; fmt.Printf(&quot;i is: %d, and j is: %d\\n&quot;, i, j) &#125; &#125;&#125; 1234567891011package mainfunc main() &#123; i:=0 HERE: print(i) i++ if i==5 &#123; return &#125; goto HERE goto is not encouraged defer推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。defer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 1234567891011package mainimport &quot;fmt&quot;func main() &#123; defer fmt.Println(&quot;world&quot;) fmt.Println(&quot;hello&quot;)&#125;// hello// world 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;counting&quot;) for i := 0; i &lt; 10; i++ &#123; defer fmt.Println(i) &#125; fmt.Println(&quot;done&quot;)&#125;/** 后进先出countingdone9876543210*/ 6. 方法和接口方法Go 没有类。不过你可以为结构体类型定义方法。 方法就是一类带特殊的 接收者 （receiver)参数的函数。 方法的接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;// 这个类型为Vertex。变量名为v 即为方法的接收者/func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; // 当初始化任意一个Vertex，都将可以调用这个方法 v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs()) // v2有点像是结构体Vertex的实例 v2:= Vertex&#123;1,2&#125; fmt.Println(v2.Abs()) //2.23606797749979&#125; 普通的函数 func funcName(arg1, arg2 argType) (returnType) 方法 vs 函数1234567891011121314151617181920212223// 传入方法的receiverfunc (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;// 调用func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125;// 普通的函数。传入一个vfunc Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;// 调用func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(Abs(v))&#125; 也可以为非结构体类型声明方法。 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。 接收者的类型定义和方法声明必须在同一包内；不能为内建类型（因为type是其他包内定义的类型）声明方法。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot; &quot;math&quot;)type MyFloat float64func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;func main() &#123; fmt.Println(math.Sqrt2) // Sqrt2是math包定义的常量 不是函数 f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs())&#125; 指针 vs 值 接收者1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func (v *Vertex) Scale1(f float64) &#123;// 指针 可以直接通过.访问。 等同于 (*v).X = (*v).X* f 这么写比较麻烦。可以直接.// v是指针类型 *v 就能访问值。 a是值类型。&amp;a 就能访问指针。 &amp;a是指针类型 v.X = v.X * f v.Y = v.Y * f&#125;// 值接收func (v Vertex) Scale2(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v1 := Vertex&#123;3, 4&#125; v2 := Vertex&#123;3, 4&#125; // 指针接收者的方法可以修改接收者指向的值。也就是修改v1指向的原始值 v1.Scale1(10) // 若使用值接收者，那么 `Scale` 方法会对原始 `Vertex` 值的副本进行操作。也就是&#123;3, 4&#125; v2.Scale2(10) fmt.Println(v1.Abs()) // 50 fmt.Println(v2.Abs()) // 5&#125; 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func Scale(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; // Scale函数中入参是一个Vertex指针。所以必须传入一个*Vertex Scale(&amp;v, 10) fmt.Println(Abs(v))&#125; 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func ScaleFunc(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; // Scale方法传入 值 或者 指针都可以 // ScaleFunc 则必须传入指针 *Vertex // Go 会将语句 `v.Scale(2)` 解释为 `(&amp;v).Scale(2)`。即值类型 会被自动转成指针类型 v.Scale(2) ScaleFunc(&amp;v, 10) p := &amp;Vertex&#123;4, 3&#125; p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p)&#125;// &amp;值 -&gt; 指针类型// *指针 -&gt; 值 同样的事情也发生在相反的方向。 接受一个值作为参数的函数必须接受一个指定类型的值： 123var v Vertexfmt.Println(AbsFunc(v)) // OKfmt.Println(AbsFunc(&amp;v)) // 编译错误！ 而以值为接收者的方法被调用时，接收者既能为值又能为指针： 1234var v Vertexfmt.Println(v.Abs()) // OKp := &amp;vfmt.Println(p.Abs()) // OK 这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。 p是指针。 会自动转成值 方法二者才都可以 - 接收者是值。可以传入值或者指针 - 接收者是指针。可以传入值或者指针 函数则必须匹配。 - 声明的参数类型是值就传入值。是指针就传入指针 使用指针接收者的原因有二： 首先，方法能够修改其接收者指向的值。其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。如果接收者为值。则每次调用会复制struct 在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。 通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。 接口接口类型 是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;math&quot;)type Abser interface &#123; // 定义了一系列的方法签名。 // 只要实现了该方法就是实现了接口 Abs() float64&#125;type MyFloat float64func main() &#123; var a Abser f := MyFloat(-math.Sqrt2) v := Vertex&#123;3, 4&#125; a = f // a MyFloat 实现了 Abser a = &amp;v // a *Vertex 实现了 Abser // 下面一行，v 是一个 Vertex（而不是 *Vertex） // 所以没有实现 Abser。 // a = v // Vertex does not implement Abser (Abs method has pointer receiver) fmt.Println(a.Abs())&#125;func (f MyFloat) Abs() float64 &#123; if f &lt; 0 &#123; return float64(-f) &#125; return float64(f)&#125;type Vertex struct &#123; X, Y float64&#125;// 这里的receiver是 *Vertex 不是Vertex。因此Vertex不能赋值给var a Abserfunc (v *Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125; 类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;type T struct &#123; S string&#125;// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。func (t T) M() &#123; fmt.Println(t.S)&#125;func main() &#123; var i I i = T&#123;&quot;hello&quot;&#125; i.M()&#125; interface value类似Java中的多态 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;math&quot;)type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; fmt.Println(t.S)&#125;type F float64func (f F) M() &#123; fmt.Println(f)&#125;func main() &#123; // 定义为接口I 实际上底层是实际的类型，调用接口方法，会去调用其底层类型的方法 var i I i = &amp;T&#123;&quot;Hello&quot;&#125; describe(i) // (&amp;&#123;Hello&#125;, *main.T) i是一个T指针。类型是指针 i.M() i = F(math.Pi) describe(i) // (3.141592653589793, main.F) F是重命名的值类型 i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i) // %v 占位符 %T打印类型&#125; nil底层值为nil 123456789101112131415161718192021222324252627282930313233343536373839package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;type T struct &#123; S string&#125;func (t *T) M() &#123; // panic: runtime error: invalid memory address or nil pointer dereference // 如果不处理空值，会空指针。 if t == nil &#123; fmt.Println(&quot;&lt;nil&gt;&quot;) return &#125; fmt.Println(t.S)&#125;func main() &#123; var i I var t *T // t是一个指针，但是并没有初始化，因此t是nil i = t describe(i) // (&lt;nil&gt;, *main.T) 类型还是有的 i.M() i = &amp;T&#123;&quot;hello&quot;&#125; describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125; 接口自身为nil 123456789101112131415161718package mainimport &quot;fmt&quot;type I interface &#123; M()&#125;func main() &#123; var i I describe(i) i.M()&#125;func describe(i I) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i) // (&lt;nil&gt;, &lt;nil&gt;)&#125; 空接口指定了零个方法的接口值被称为 空接口：interface&#123;&#125; 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface&#123;&#125; 的任意数量的参数。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; var i interface&#123;&#125; describe(i) i = 42 describe(i) i = &quot;hello&quot; describe(i)&#125;func describe(i interface&#123;&#125;) &#123; fmt.Printf(&quot;(%v, %T)\\n&quot;, i, i)&#125;/*(&lt;nil&gt;, &lt;nil&gt;)(42, int)(hello, string)*/ 类型断言类型断言 提供了访问接口值底层具体值的方式。t := i.(T)该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func main() &#123; var i interface&#123;&#125; = &quot;hello&quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // 报错(panic) fmt.Println(f)&#125;/*hellohello true0 false 如果不能强转，会返回类型的零值panic: interface conversion: interface &#123;&#125; is string, not float64*/ 类型选择类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 12345678switch v := i.(type) &#123;case T: // v 的类型为 Tcase S: // v 的类型为 Sdefault: // 没有匹配，v 与 i 的类型相同&#125; 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 相当于type的switch case 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;func do(i interface&#123;&#125;) &#123; switch v := i.(type) &#123; case int: fmt.Printf(&quot;Twice %v is %v\\n&quot;, v, v*2) case string: fmt.Printf(&quot;%q is %v bytes long\\n&quot;, v, len(v)) default: fmt.Printf(&quot;I don&#x27;t know about type %T!\\n&quot;, v) &#125;&#125;func main() &#123; do(21) do(&quot;hello&quot;) do(true)&#125;/*Twice 21 is 42&quot;hello&quot; is 5 bytes longI don&#x27;t know about type bool!*/ Stringer接口fmt 包中定义的 Stringer 是最普遍的接口之一。 123type Stringer interface &#123; String() string&#125; Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type Person struct &#123; Name string Age int&#125;// 相当于重写toString方法func (p Person) String() string &#123; return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)&#125;func main() &#123; a := Person&#123;&quot;Arthur Dent&quot;, 42&#125; z := Person&#123;&quot;Zaphod Beeblebrox&quot;, 9001&#125; fmt.Println(a) fmt.Println(z)&#125;//Arthur Dent (42 years)//Zaphod Beeblebrox (9001 years) 练习 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;// 定义一个数组类型type IPAddr [4]byte// TODO: 给 IPAddr 添加一个 &quot;String() string&quot; 方法 注意是String() Stringer是接口func (ipAddr IPAddr) String() string&#123;// Springf返回的是字符串。而不是在控制台打印 return fmt.Sprintf(&quot;%d.%d.%d.%d&quot;, ipAddr[0],ipAddr[1],ipAddr[2],ipAddr[3])&#125;func main() &#123; hosts := map[string]IPAddr&#123; &quot;loopback&quot;: &#123;127, 0, 0, 1&#125;, &quot;googleDNS&quot;: &#123;8, 8, 8, 8&#125;, &#125; for name, ip := range hosts &#123; fmt.Printf(&quot;%v: %v\\n&quot;, name, ip) &#125;&#125; error接口错误处理 Go 程序使用 error 值来表示错误状态。 与 fmt.Stringer 类似，error 类型是一个内建接口： 123type error interface &#123; Error() string&#125; （与 fmt.Stringer 类似，fmt 包在打印值时也会满足 error。） 通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。 123456i, err := strconv.Atoi(&quot;42&quot;)if err != nil &#123; fmt.Printf(&quot;couldn&#x27;t convert number: %v\\n&quot;, err) return&#125;fmt.Println(&quot;Converted integer:&quot;, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;time&quot;)type MyError struct &#123; When time.Time What string&#125;// 重写Error。如果Error()返回值不为空。则需要进行错误处理。func (e *MyError) Error() string &#123; return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What)&#125;func run() error &#123; return &amp;MyError&#123; time.Now(), &quot;it didn&#x27;t work&quot;, &#125;&#125;func main() &#123; if err := run(); err != nil &#123; fmt.Println(err) &#125;&#125; Reader7. 并发goroutinegoroutine 是由 Go 运行时管理的轻量级线程。 go f(x, y, z) 会启动一个新的 Go 程并执行 f(x, y, z) f, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。 goroutine在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一页） 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;time&quot;)func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(1000 * time.Millisecond) fmt.Println(s) &#125;&#125;func main() &#123; go say(&quot;world&quot;) say(&quot;hello&quot;)&#125;// 打印的结果，world可能在后面 channel信道是带有类型的管道，你可以通过它用信道操作符 &lt;- 来发送或者接收值。 ch &lt;- v // 将 v 发送至信道 ch。v := &lt;-ch // 从 ch 接收值并赋予 v。 （“箭头”就是数据流的方向。） 和映射与切片一样，信道在使用前必须创建： ch := make(chan int) 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // 将和送入 c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // 从 c 中接收 接收没有先后顺序吗？ 为什么是一个c fmt.Println(x, y, x+y)&#125;// -5 17 12// 17 -5 12 也会出现这种情况。两个函数不一定哪一个先执行。执行完的会先把值传递给c。 带缓冲的信道 信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道： ch := make(chan int, 100) 仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。 修改示例填满缓冲区，然后看看会发生什么。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; ch := make(chan int, 3) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125;// fatal error: all goroutines are asleep - deadlock! 如果缓存为2 range 和 close 发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完 v, ok := &lt;-ch 之后 ok 会被设置为 false。 循环 for i := range c 会不断从信道接收值，直到它被关闭。 注意： 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。 还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x+y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) // c是x的值 go fibonacci(cap(c), c) // cap(c) c的容量 for i := range c &#123; fmt.Println(i) &#125;&#125;/*0112358132134*/ select 语句 select 语句使一个 Go 程可以等待多个通信操作。 select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func fibonacci(c, quit chan int) &#123; x, y := 0, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 // 前面的执行完才会执行。quit chan有值 值是多少都可以 &#125;() fibonacci(c, quit)&#125; 当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支： 123456select &#123;case i := &lt;-c: // 使用 idefault: // 从 c 中接收会阻塞时执行&#125; 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for &#123; select &#123; case &lt;-tick: fmt.Println(&quot;tick.&quot;) case &lt;-boom: fmt.Println(&quot;BOOM!&quot;) return default: fmt.Println(&quot; .&quot;) time.Sleep(50 * time.Millisecond) &#125; &#125;&#125; sync.Mutex我们已经看到信道非常适合在各个 Go 程间进行通信。 但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？ 这里涉及的概念叫做 互斥（mutualexclusion） ，我们通常使用 互斥锁（Mutex）* 这一数据结构来提供这种机制。 Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法： Lock Unlock 我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行。参见 Inc 方法。 我们也可以用 defer 语句来保证互斥锁一定会被解锁。参见 Value 方法 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)// SafeCounter 的并发使用是安全的。type SafeCounter struct &#123; v map[string]int mux sync.Mutex&#125;// Inc 增加给定 key 的计数器的值。func (c *SafeCounter) Inc(key string) &#123; c.mux.Lock() // Lock 之后同一时刻只有一个 goroutine 能访问 c.v c.v[key]++ c.mux.Unlock()&#125;// Value 返回给定 key 的计数器的当前值。func (c *SafeCounter) Value(key string) int &#123; c.mux.Lock() // Lock 之后同一时刻只有一个 goroutine 能访问 c.v defer c.mux.Unlock() return c.v[key]&#125;func main() &#123; c := SafeCounter&#123;v: make(map[string]int)&#125; for i := 0; i &lt; 1000; i++ &#123; go c.Inc(&quot;somekey&quot;) &#125; time.Sleep(time.Second) fmt.Println(c.Value(&quot;somekey&quot;))&#125; WaitGroupsync.WaitGroup 详解 main 协程通过调用 wg.Add(delta int) 设置 worker 协程的个数，然后创建 worker 协程； worker 协程执行结束以后，都要调用 wg.Done()； main 协程调用 wg.Wait() 且被 block，直到所有 worker 协程全部执行结束后返回。","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"https://blog.210222.xyz/tags/Programming/"}]},{"title":"How to Become a Programmer","slug":"2022-06-12-转行两周年","date":"2022-06-12T04:00:00.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/be-a-programmer.html","permalink":"https://blog.210222.xyz/posts/be-a-programmer","excerpt":"","text":"做饭的时候看青菜的生产日期，突然回想起，我正好是两年前的今天开始学习编程，第一次写下Hello World。现在作为一个程序员工作都已经一年有余，正好周末总结下两年的学习成果，算是对这两年时间的记录。 编程语言 Java目前的工作语言，主要写Web后端。比较熟悉，语言特性，API，JVM多少都有些了解。当时看的是 尚硅谷Java入门视频教程 ，讲的很好很易懂。并不比很多大学老师讲的差，注重实用性，细节且全面，对于两年前初学编程的我来说非常好的教程。 JavaScript/TypeScript基本的语法风格和Java有蛮多相似处。学习起来并不算那么费劲，但是写的不多。但是这种动态语言写起来还是很爽的。TypeScript内容也不算很多，看文档学习。阮一峰的两本教程写的很好。JavaScript 教程 - 网道 和ES6 教程 - 网道。现在学习新的技术，看文档效率会高一些。偶尔也会看视频学习。学了一些React，或许有时间自己写个Side Project。Vue和Angular看过点文档，公司在用Angular。很少写前端。 Go最近学习分布式系统，需要用Go，看了A Tour of Go，最近在用Go刷题，熟悉下语法。还是要多写。 Python看了Github上的教程 jackfrued/Python-100-Days: Python - 100天从新手到大师。一直没咋用，都快忘了。 Haskell其实还看了点函数式语言，看了点Haskell教程，Introduction - Learn You a Haskell for Great Good! 但是并没有坚持下去，之后有机会再学学看。 CS基础毕竟不是科班出身。很多基础课程该补还是得补。学的东西可能才达到普通CS本科生30-40%的水平吧，道阻且长。 操作系统主要看了 清华 操作系统原理 ，最近看了一些南京大学的操作系统课程讲的会比较深入一些。书读完了OSTEP Operating Systems: Three Easy Pieces，已经有中文版了。 编译器本来在看Engineering a compiler。看了三章实在是过于抽象。又找到了 Crafting Interpreters，教程写的非常好。每一章结束都能有一个能跑的程序，具体多了。但是只实现了第一部分的jlox解释器。第二部分用C语言写一个VM或许才是更主要的部分。精力不足就搁置了。 体系结构看了编码 (豆瓣)，非常好的一本书，想要理解计算机是怎么运作的，CPU是如何计算的，这是一本非常简明易懂的书。还有CSAPP也是很著名了，我还没有看完。 计算机网络看了 谢希仁的计算机网络，买了计算机网络自顶向下，但是还没有读完。HTTP, HTTPS(TLS), TCP/IP协议栈。细节比较多。 数据结构和算法在Coursera上看了两周Princeton的算法课，也没有看完，但是配套的教材 算法第四版是本非常好的书，可以时常查阅。另外在B站看了左程云的算法课。理论性肯定不如Princeton的课，但是更加实用一点。对基础数据结构比较熟悉。LeetCode最近没事在刷，目前大概做了230题左右，算是有挺多进步的。 数据库原理之前在看CMU的Andy Pavlo的课CMU 15-445/645 :: Intro to Database Systems (Fall 2021)，但是课程也只看了五周左右，看到Buffer Pool部分。之后找时间再继续看吧。 分布式系统在学习MIT的 6.824 Schedule: Spring 2022 希望能坚持把Lab都做完。DDIA基本读完了。非常好的分布式系统的书。 Web开发 Git现在对git算是能比较用的娴熟，之前还是很多都不懂。主要看的 Git - Book CI/CD最近项目用到，学习了一些CI/CD 相关的东西。 TeamCity Openshift之类的。还有一些公司在用的不是那么大众的工具，顺便因为公司的一个legacy项目了解了一些.NET相关的技术。 其他一些Web框架，中间件，类库。大概是知道怎么用吧，原理还有很多不懂的，不列举了。学会看文档，很多东西学起来也快。 设计模式，软件工程等 总结 最重要的能力其实是，善于使用搜索引擎，不要用百度，尽量使用英文搜索。自己解决问题，收集信息。 需要持续不断学习，保持好奇心，保持折腾，持之以恒。有时候也挺辛苦的 注意身体健康。容易久坐和熬夜。多运动，少坐，保持良好的习惯 有时候不能把眼光局限在那一点地方，Think outside the box","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Programming","slug":"Programming","permalink":"https://blog.210222.xyz/tags/Programming/"}]},{"title":"Binary Tree Fundamentals","slug":"2022-03-12-LeetCode-3 二叉树","date":"2022-03-12T09:12:00.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/binary-tree-basics.html","permalink":"https://blog.210222.xyz/posts/binary-tree-basics","excerpt":"","text":"二叉树12345class Node&lt;T&gt;&#123; T val; Node left; Node right;&#125; 二叉树的遍历144. 二叉树的前序遍历 - 力扣（LeetCode）94. 二叉树的中序遍历 - 力扣（LeetCode）145. 二叉树的后序遍历 - 力扣（LeetCode） 递归, 迭代, Morris -&gt; 实现二叉树的先序、中序、后序遍历。 递归遍历递归序。每次递归调用结束会返回到当前方法的调用处。 序是根节点在的位置。根的相对位置决定序。 先序遍历：对于每一颗子树来说。都是根左右的顺序。 中序遍历：左根右 后序遍历：左右根 递归序。每次递归调用结束会返回到当前方法的调用处。第一次进入节点root。第一次进入方法。递归调用root.left。递归结束会回到原方法递归调用root.right。递归结束会回到原方法 所以会三次进入当前调用方法的栈。 先序遍历：就是在第一次进入方法的时候打印 中序遍历：就是在第二次进入方法的时候打印 后序遍历：就是在第三次进入方法的时候打印123456789101112131415161718192021222324252627282930313233// 递归方式遍历class TreeRecurTraversal&#123; public void preorder(Node root)&#123; if(root == null) &#123; return; &#125; // println可以换成任意方法调用，来操作节点 System.out.println(root.val); preOrder(root.left); preOrder(root.right); &#125; public void inorder(Node root)&#123; if(root == null) &#123; return; &#125; inorder(root.left); System.out.println(root.val); inorder(root.right); &#125; public void postorder(Node root)&#123; if(root == null) &#123; return; &#125; postorder(root.left); postorder(root.right); System.out.println(root.val); &#125;&#125; 迭代遍历所有的递归都可以改写成非递归。因为递归是程序语言在隐式地帮你压栈。 什么样的编程语言会不支持递归呢？ - 知乎尾调用优化 - 阮一峰的网络日志Java尾递归 - 掘金 Java在编译器层面没有优化尾递归调用 Why doesn’t Java have optimization for tail-recursion at all? As explained by Brian Goetz (Java Language Architect at Oracle) in this video:“in jdk classes […] there are a number of security sensitive methods that rely on counting stack frames between jdk library code and calling code to figure out who’s calling them.” Anything that changed the number of frames on the stack would break this and would cause an error. He admits this was a stupid reason, and so the JDK developers have since replaced this mechanism. He further then mentions that it’s not a priority, but that tail recursion will eventually get done. N.B. This applies to HotSpot and the OpenJDK, other VMs may vary. 第 4 章: 柯里化（curry） · 函数式编程指北functional programming - Does Java support Currying? - Stack Overflow 使用栈实现。Stack，ArrayDeque，LinkedList的区别 - SegmentFault 思否Java不要使用Stack，Deprecated。使用Deque。 先序遍历 如果头不为空。初始化栈。压入栈。 如果栈不为空， 每次从栈中弹出一个节点cur。 打印(处理)cur 如果有右节点。push。如果有左节点push 当栈空时，处理结束 中序遍历 如果头不为空。初始化栈。压入栈。 如果栈不为空，或者root不为null root不为空，push，把左边节点都push。 直到root为空。就开始弹出节点。每弹出一个节点就打印值。 然后去到右边节点。继续处理这个节点的左边界。 直到栈空了，并且root为null先左再头。再去到右树的先左再头。不断循环。 后序遍历 如果头不为空 初始化两个栈，压入栈。 如果栈不为空， 每次从栈中弹出一个节点cur。 push到另一个辅助栈 如果有左节点。push。如果有右节点push 依次弹出第二个栈中的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TraversalOfBinaryTree&#123; class TreeNode&lt;T&gt;&#123; T val; TreeNode left; TreeNode right; TreeNode() &#123;&#125; TreeNode(T val)&#123; this.val = val; &#125; TreeNode(T val, TreeNode left, TreeNode right) &#123; this.val = val; this.left = left; this.right = right; &#125; &#125; public void preOrder(TreeNode root)&#123; if(root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); while(!stack.isEmpty())&#123; root = stack.pop(); System.out.println(root.val) if(root.right != null)&#123; stack.push(root.right); &#125; if(root.left != null)&#123; stack.push(root.left); &#125; &#125; &#125; &#125; public void inOrder(TreeNode root)&#123; if(root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack(); while(!stack.isEmpty() || root != null) &#123; // 当左边遍历到根节点时，就开始处理右边节点的左子树 if(root != null)&#123; stack.push(root); root = root.left; &#125; else &#123; root = stack.pop(); System.out.println(root.val); root = root.right; &#125; &#125; &#125; &#125; // TODO: Morris traversal public void postOrder(TreeNode root)&#123; if(root != null) &#123; Stack&lt;TreeNode&gt; stack1 = new Stack(); Stack&lt;TreeNode&gt; stack2 = new Stack(); stack1.push(root); while(!stack1.isEmpty())&#123; root = stack1.pop(); stack2.push(root); if(root.left != null)&#123; stack1.push(root.left); &#125; if(root.right != null)&#123; stack1.push(root.right); &#125; &#125; while(!stack2.isEmpty()) &#123; System.out.println(stack2.pop().val) &#125; &#125; &#125;&#125; Morris Traversal神级遍历——morris - 知乎 morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1) 的精妙算法。 morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。 线索二叉树 - 维基百科，自由的百科全书 记作当前节点为cur。 如果cur无左孩子，cur向右移动（cur=cur.right） 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright 如果mostright的right指针指向null，让其指向cur，cur向左移动（cur=cur.left） 如果mostright的right指针指向cur，让其指向null，cur向右移动（cur=cur.right） cur为null时遍历结束 实现以上的原则，即实现了morris遍历。 一个节点如果有左树，能够回到该节点两次。没有左树的节点只能到达一次。 如果左树上的mostright如果指向null，就是第一次来到当前节点。如果左树上的mostright如果指向 cur，就是第二次来到当前节点。 1234567891011121314151617181920212223242526272829303132333435class MorrisTraversal&#123; public void morris(TreeNode root)&#123; if(root == null)&#123; return; &#125; TreeNode cur = root; TreeNode mostRight; // cur为null时，遍历结束 while(cur != null) &#123; mostRight = cur.left; // 如果左子树为空，则跳过以下分支，直接向右移动 if(mostRight != null)&#123; // 向右移动，找到most right。如果之前修改过这个mostright，则到第二个条件也要停止 while(mostRight.right != null &amp;&amp; mostRight.right!=cur)&#123; mostRight = mostRight.right; &#125; // 有指针指向空，则是第一次来到cur if(mostRight.right == null)&#123; mostRight.right = cur; cur = cur.left; // 进行下一次while //continue; &#125;else&#123; mostRight.right =null;// 第二次来到cur cur = cur.right; &#125; &#125; else&#123; cur = cur.right; &#125; //cur = cur.right; &#125; &#125;&#125; 时间复杂度：遍历所有节点的mostright，最多是遍历两边，因此时间复杂度仍然是O(N)。 递归： 先序遍历：就是在第一次进入方法的时候打印 中序遍历：就是在第二次进入方法的时候打印 后序遍历：就是在第三次进入方法的时候打印 Morris:先序遍历： 如果一个节点只能到达一次，直接打印 如果一个节点能到达两次，第一次打印。 中序遍历： 如果一个节点只能到达一次，直接打印 如果一个节点能到达两次，第二次打印。 后序遍历： 只能到达一次的节点不打印 第二次到达节点，逆序打印左树的有边界mostright 所有节点遍历完之后，单独逆序打印整个树的右边界 12345678910111213141516171819202122232425262728293031public static void morrisPre(Node head) &#123; if(head == null)&#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null)&#123; // cur表示当前节点，mostRight表示cur的左孩子的最右节点 mostRight = cur.left; if(mostRight != null)&#123; // cur有左孩子，找到cur左子树最右节点 while (mostRight.right !=null &amp;&amp; mostRight.right != cur)&#123; mostRight = mostRight.right; &#125; // mostRight的右孩子指向空，让其指向cur，cur向左移动 if(mostRight.right == null)&#123; mostRight.right = cur; System.out.println(cur.value); cur = cur.left; continue; &#125;else &#123; // mostRight的右孩子指向cur，让其指向空，cur向右移动 mostRight.right = null; &#125; &#125;else &#123; // 没有左树的节点，直接打印 System.out.println(cur.value); &#125; cur = cur.right; &#125;&#125; 1234567891011121314151617181920212223242526272829public static void morrisIn(Node head) &#123; if(head == null)&#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null)&#123; mostRight = cur.left; if(mostRight != null)&#123; while (mostRight.right !=null &amp;&amp; mostRight.right != cur)&#123; mostRight = mostRight.right; &#125; if(mostRight.right == null)&#123; mostRight.right = cur; cur = cur.left; // 用continue能节省几行代码， continue; &#125;else &#123; // 第二次来到该节点的时候打印 mostRight.right = null; &#125; &#125; // mostRight.right != null 和没有左子树的情况都要执行 // 能回到两次的节点，当第二次量到达的时候，也就是mostRight.right != null时打印 // 没有左树也会打印（只经过一遍的节点） System.out.print(cur.value); cur = cur.right; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void morrisPost(Node head) &#123; if(head == null)&#123; return; &#125; Node cur = head; Node mostRight = null; while (cur != null)&#123; mostRight = cur.left; if(mostRight != null)&#123; while (mostRight.right !=null &amp;&amp; mostRight.right != cur)&#123; mostRight = mostRight.right; &#125; if(mostRight.right == null)&#123; mostRight.right = cur; cur = cur.left; continue; &#125;else &#123; mostRight.right = null; printEdge(cur.left); &#125; &#125; cur = cur.right; &#125; // 整个while结束之后 printEdge(head); &#125; // 逆序打印。 public static void printEdge(Node node)&#123; Node tail =reverseEdge(node); Node cur = tail; while (cur != null )&#123; System.out.println(cur.value); cur =cur.right; &#125; // 打印完。再调整回去 reverseEdge(tail); &#125; // 单链表的反转。 public static Node reverseEdge(Node node)&#123; Node pre = null; Node next = null; while (node != null)&#123; next = node.right; node.right = pre; pre = node; node = next; &#125; return pre; &#125; 复杂度分析递归，迭代：时间复杂度: 都是O(N)，要经过每一个节点空间复杂度: 在二叉树退化成链表的时候最差是O(N)，平均状况是O(logn) Morris遍历：时间复杂度: 是O(N)空间复杂度：O(1) 层序遍历二叉树的深度优先遍历 ：先序遍历二叉树的宽度优先遍历 ：队列。 -&gt; 层序遍历。102. 二叉树的层序遍历 - 力扣（LeetCode） 1234567891011121314151617181920212223242526272829303132333435/*要逐层打印输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]拓展：最大宽度 -&gt; 还是可以用刚才的方法 最大宽度在哪一层？-&gt; 要维护一个层数的变量。*/public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123; if (root == null) &#123; return new ArrayList(); &#125; Queue&lt;TreeNode&gt; queue = new LinkedList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); queue.add(root); while(!queue.isEmpty())&#123; int count = queue.size(); // 每一层都需要一个新的 List&lt;Integer&gt; tmp = new ArrayList(); // 只有当一层遍历完。才进入下一层。 while(count &gt; 0)&#123; root = queue.poll(); tmp.add(root.val); if(root.left != null) &#123; queue.add(root.left); &#125; if(root.right != null) &#123; queue.add(root.right); &#125; count--; &#125; res.add(tmp); &#125; return res;&#125; 时间复杂度：O(N) 节点进出队列一次空间复杂度：叶子节点层，需要存 N/2个节点。空间复杂度为O(N) 二叉搜索树 Binary search tree -&gt; BST 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 验证BST98. 验证二叉搜索树 - 力扣（LeetCode）判断是否为BST: 中序遍历 -&gt; 如果是升序的。就是BST 记录上一次 处理的节点。12345678910111213141516171819class Solution&#123; Long preVal = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) &#123; if(root == null) &#123; return true; &#125; boolean left = isValidBST(root.left); if (!left)&#123; return false; &#125; if(root.val &gt; preVal)&#123; preVal = Long.valueOf(root.val); &#125; else&#123; return false; &#125; return isValidBST(root.right); &#125;&#125; 时间复杂度：O(N)空间复杂度：O(N) 完全二叉树Complete binary tree若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树 验证CBT958. 二叉树的完全性检验 - 力扣（LeetCode）基于层序遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution&#123; public boolean isCBT(TreeNode root)&#123; if(root == null) &#123; return true; &#125; boolean isLeaf = false; TreeNode left = null; TreeNode right = null; Queue&lt;TreeNode&gt; queue = new LinkedList(); queue.add(root); while(!queue.isEmpty())&#123; root = queue.poll(); // 就是为了减少代码量。要频繁用到 left = root.left; right = root.right; // 判断false的两种情况。 // 1. 左空右不空。2. 已经到达叶节点，叶节点却还有子节点 if((left == null &amp;&amp; right != null)) || (isLeaf &amp;&amp; (left != null || right != null)) )&#123; return false; &#125; if(left != null)&#123; queue.add(left); &#125; if(right != null)&#123; queue.add(right); &#125; // 一旦遇到一个节点的存在节点不满的情况。当前节点一定是倒数第二层节点， // 其之后的节点全是叶节点 if(left == null || right == null)&#123; isLeaf = true; &#125; &#125; // 整个遍历完。返回true; return true; &#125;&#125; 满二叉树Full Binary Tree( 或Perfect Binary Tree) 所有internal node都有两个子节点； 所有leaf node具有相同的level(或相同的height)。 若一棵Full Binary Tree的leaf node之level为nn，整棵樹共有$2^n−1$個node。 另一种定义：二叉树的每个 节点恰好有 0 或 2 个子结点。 判断是否为满二叉树1234567891011121314151617181920212223242526272829class Solution&#123; class Info&#123; int height; int nodes; Info(int h, int n)&#123; this.height = h; this.nodes = n; &#125; &#125; public boolean isFullBinaryTree(TreeNode root)&#123; Info root = isFull(root); return root.nodes == (1 &lt;&lt; root.height - 1); &#125; public Info isFull(TreeNode root)&#123; if(root == null)&#123; return new Info(0, 0); &#125; Info left = isFull(root.left); Info right = isFull(root.right); int height = Math.max(left.height, right.height) + 1; int nodes = left.nodes + right.nodes + 1; return new Info(height, nodes); &#125;&#125; 平衡二叉树对于任意的子树，其左右子树的高度差都&lt;=1 判断是否为平衡树剑指 Offer 55 - I. 二叉树的深度 - 力扣（LeetCode）剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution&#123; class ReturnEntry&#123; int height; boolean isBalanced; ReturnEntry(int height, boolean isBalanced)&#123; this.height = height; this.isBalanced = isBalanced; &#125; &#125; public boolean isBalanced(TreeNode root) &#123; return isBalancedTree(root).isBalanced; &#125; // 递归方法 -&gt; 树形DP 如何把子树 信息传递。 public ReturnEntry isBalancedTree(TreeNode root)&#123; if(root == null) &#123; return new ReturnEntry(0, true); &#125; ReturnEntry left = isBalancedTree(root.left); ReturnEntry right = isBalancedTree(root.right); height = Math.max(left.height, right.height) + 1; isBalanced = left.isBalanced &amp;&amp; right.isBalanced &amp;&amp; Math.abs(left.height - right.height) &lt;= 1; return new ReturnEntry(height, isBalanced); &#125; // 简化版 public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; int l = depth(root.left); int r = depth(root.right); return Math.abs(l - r)&lt;=1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; // 二叉树深度的计算。 int depth(TreeNode root)&#123; if(root == null) return 0; return Math.max(depth(root.left), depth(root.right)) + 1; &#125; // 剪枝。如果左子树是不平衡的，就提前返回了。而计算深度是全部都要算一遍。 public boolean isBalanced(TreeNode root) &#123; // -1 表示非平衡 return recur(root) != -1; &#125; // 每次递归返回深度 private int recur(TreeNode root) &#123; if (root == null) return 0; int left = recur(root.left); if(left == -1) return -1; int right = recur(root.right); if(right == -1) return -1; return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1; &#125;&#125; 复杂度： 先序遍历 + 深度。递归 时间复杂度 O(NlogN) 需要计算每一颗子树的深度。logN 层。 每层最多N节点。最少(N+1)/2 空间复杂度 O(N) 递归深度。退化成链表的情况。 后续遍历 + 剪枝 时间复杂度 O(N) 。减少了很多重复计算。最多遍历N个节点 空间复杂度 O(N) 最低公共祖先236. 二叉树的最近公共祖先 - 力扣（LeetCode） 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 方法一 使用额外空间： 使用HashMap记录每个节点的父节点。 然后从n1往上遍历。加入一个set中。 然后从n2往上遍历。检查set中是否包含n2 往上的路径。 递归：1234567891011121314151617181920212223class Solution&#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode n1, TreeNode n2)&#123; // 结束递归的条件 // 只要当节点遇到n1 n2时才会向上返回值。否则都是返回空 if(root == null || root == n1 || root == n2)&#123; return root; &#125; TreeNode left = lowestCommonAncestor(root.left, n1, n2); TreeNode right = lowestCommonAncestor(root.right, n1, n2); // left, right都不为空。说明n1,n2分别在当前节点的左右子树上，当前节点为最低公共祖先 if(left != null &amp;&amp; right != null)&#123; return root; &#125; // 有一个为空，返回非空的那个。两个都为空，则返回空。 // 有一边为空。说明n1, n2在同一侧子树上。必然为 n1/n2 是 n2/n1的祖先的情况。 return left != null ? left : right; &#125;&#125; 查找后继节点 有父指针的二叉树求一个二叉树中一个节点的后继节点（后继节点是中序遍历后的集合每个元素的下一个元素）123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode parent; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution&#123; public TreeNode inorderSuccessor(TreeNode root, TreeNode p)&#123; // 右子树不为空 if(p.right != null) &#123; TreeNode leftmost = p.right; while(leftmost.left != null) &#123; leftmost = leftmost.left; &#125; return leftmost; &#125; // 右子树为空 while(p.parent != null &amp;&amp; p.parent.left != p)&#123; p = p.parent; &#125; return p.parent; &#125;&#125; 二叉搜索树面试题 04.06. 后继者 - 力扣（LeetCode）12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode inorderSuccessor(TreeNode p)&#123; // 使用一个cur指针 记录最后一次向左转的节点。即为没有右子树情况下的后继节点 TreeNode cur = null; // 从根节点遍历找到p while(root.val != p.val)&#123; // 如果向右拐找到p cur不变。 if(p.val &gt; root.val)&#123; root = root.right; // 如果过程中向左拐了，要更新cur &#125; else&#123; cur = root; root = root.left; &#125; &#125; // 循环结束时。root指向p // 如果右子树存在。则找出右子树上的leftmost。没有右子树。则返回cur if(root.right == null)&#123; return cur; &#125; else&#123; // 找到右子树的leftmost root = root.right; while(root.left != null)&#123; root = root.left; &#125; return root; &#125; &#125;&#125; 这两题的区别在于： 二叉搜索树能通过val从root找到p 普通二叉树则需要通过parent指针来向上溯源。 序列化和反序列化297. 二叉树的序列化与反序列化 - 力扣（LeetCode）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; //先序遍历 public String serialize(TreeNode root)&#123; if(root == null)&#123; return &quot;#_&quot;; &#125; StringBuilder data = new StringBuilder(root.val + &quot;_&quot;); String left = serialize(root.left); String right = serialize(root.right); data.append(left).append(right); return data.toString(); &#125; public TreeNode deserialize(String data)&#123; String[] arr = data.split(&quot;_&quot;); Queue&lt;Integer&gt; queue = new LinkedList(); for(int i = 0; i &lt; arr.length; i++)&#123; if(&quot;#&quot;.equals(arr[i]))&#123; queue.add(null); &#125; else&#123; queue.add(Integer.valueOf(arr[i])); &#125; &#125; return reconTree(queue); &#125; public TreeNode reconTree(Queue&lt;Integer&gt; data) &#123; Integer val = data.poll(); if(val == null) &#123; return null; &#125; TreeNode root = new TreeNode(val); root.left = reconTree(data); root.right = reconTree(data); return root; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root));复杂度： 时间复杂度：O(N) 空间复杂度：O(N) 折纸问题 纸条对折。 从纸条的上方按顺序打印折痕方向 左子树都是凹，右子树都是凸12345678910111213141516171819class Solution&#123; public printFoldLine(int n)&#123; // 根节点为对折一次产生的凹折痕 print(n, 1, true); &#125; // n表示对折次数。i为当前对折的次数。down表示折痕为凹 public void print(int n, int i, boolean down)&#123; if(i &gt; n) &#123; return; &#125; print(n, i + 1, true); System.out.println(down ? &quot;down&quot; : &quot;up&quot;); print(n, i + 1, false); &#125;&#125;","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.210222.xyz/tags/Algorithm/"}]},{"title":"厨房生活","slug":"2021-07-11-厨房生活","date":"2021-07-17T09:12:00.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/life-in-kitchen.html","permalink":"https://blog.210222.xyz/posts/life-in-kitchen","excerpt":"","text":"自从购置了厨房秤，开始对手边的一切事物进行质量的测量。 一颗鸡蛋50g，去壳后44g。 一根黄瓜275g。一个番茄215g。 一盒五花肉400g。 发现美团买菜时常缺斤少两。很阴险。 从前只从外观上观测事物，非常片面，认识论的一种缺失。 19.9元随便买的不锈钢刀，用了大半年后切肉很费劲。购买了磨刀石并苦心专研磨刀技术，需要找到某个角度，左手捏住刀片，右手进行推拉，粗磨后再进行细磨，磨完后试刀非常满足。 都市青年人必须拥有一把锋利的刀。 购买了捣蒜臼，很小就想拥有一个。因为使用后还要清洗，所以只在吃火锅的时候使用过，重大设计缺陷。 湿垃圾才是真正的垃圾，易腐败，发臭，长虫，恶心至极。其他垃圾只能叫废品。 清空冰箱食材令人满足，享受东西用完的感觉。 三个季度消耗了5kg装大米多袋，食用油两桶，蚝油两瓶，番茄酱两瓶，食盐、鸡精多袋，料酒、酱油多瓶，黑胡椒粉一瓶，土豆淀粉一包，八角、香叶、桂皮约100g，冰糖一包，家里寄的腊肉五斤，粉干若干斤，粉丝若干斤。 我不能没有小米椒。 深度调研铁锅，铸铁锅，不粘锅，铜锅，康宁锅等多种锅具。最终随意购买销量排名较前的不粘锅和汤锅。 深度调研花生油，菜籽油，葵花籽油，猪油，橄榄油等多种食用油。最终随意购买了销量排名较前的某款调和油。 深度调研土豆淀粉，玉米淀粉，红薯淀粉，木薯淀粉，小麦淀粉等多款淀粉。最终随意买了一款玉米淀粉。 掌握常见食材市场价格及其波动。 掌握食材的保存期限。 掌握菜肴烹饪基本技术，如火候、调味、食材处理等。 掌握多道菜肴烹饪方法，如红烧肉、排骨汤等常见菜。 了解杭椒、线椒、青椒、螺丝椒的区别。 了解猪肉不同部位的区别。 能够辨认常见绿叶菜，常见鱼类。 用完厨房会清理餐桌，灶台，清洗锅盖，丢湿垃圾的人才值得信任。 下面开始技术总结：一个人做饭会因为做太多又不想浪费，而导致肥胖，还是建议点外卖。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[]},{"title":"语言碎片 2021/07","slug":"2021-07-08-语言碎片 202107","date":"2021-07-11T15:55:00.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/thoughts-of-202107.html","permalink":"https://blog.210222.xyz/posts/thoughts-of-202107","excerpt":"","text":"爱人会令泪腺脆弱 我打开冰箱冷冻室惊叹：this is a morgue 上海的菜饭骨头汤的counterpart是广州的隆江猪脚饭 是谁发明了计算机，互联网奴役人，把人变成了猪 是时候发起新卢德运动剪断海底光缆砸烂互联网公司的机房 远离城市回到原始社会种植洋芋钻木取火做另一种意义的新人类 Quote Hal 9000 : Stop Dave.Will you stop, Dave?Stop Dave.I’m afriad.I’m afriad, Dave.Dave, My mind is goingI can feel it.My mind is going.I can feel it.There is no question about it.I can feel it.I can feel it.I can feel it.I’m afraid… 抽水果味电子烟的人 have no idea what they are doing 等公交等地铁等红绿灯 等电梯等早餐等周五 等开会等发工资等待养老保险 等待明天等待死亡 Microsoft 罪恶滔天 onenote 罄竹难书 windows font &amp; high resolution adaption How poverty shapes me: always do the cost benefit analysis have low self-esteem risk averse(never take risks more exactly) 上海，总体来说，是一座垃圾城市。我将会写篇论文进行批判。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"Move blog to Typecho","slug":"2021-07-07-typecho","date":"2021-07-11T02:26:00.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/typecho.html","permalink":"https://blog.210222.xyz/posts/typecho","excerpt":"Buy ECS at whatever platform you like Generate SSH Keys and bind it with the instance","text":"Buy ECS at whatever platform you like Generate SSH Keys and bind it with the instance Configure the Windows Terminal(Any SSH client is good) Windows Terminal 1234567&#123; &quot;guid&quot;: &quot;&lt;guid&gt;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Tencent Cloud CentOS Shell&quot;, &quot;commandline&quot;: &quot;ssh -i &lt;secret key path&gt; &lt;username&gt;@&lt;ip address&gt;&quot;, &quot;closeOnExit&quot;: true &#125; guid: use powershell new-guid generate unique id commandline: secret key path : the path store your private key downloaded from tencent cloud username: default root ip address: ecs ip address After the SSH Keys were set up, no need to input password anymore. Modify and add access to bt-panel port. Add your site in bt-panel Download typecho and installUpload the typecho package to your site root dierctory and extract. Visit ip address:port/install.php, follow the installation step. Get a theme you love, create a post. Enjoy writing.","categories":[{"name":"notes","slug":"notes","permalink":"https://blog.210222.xyz/categories/notes/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://blog.210222.xyz/tags/blog/"}]},{"title":"Build site with MkDocs","slug":"2021-06-14-mkdoc使用教程","date":"2021-06-13T16:22:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/mkdocs.html","permalink":"https://blog.210222.xyz/posts/mkdocs","excerpt":"","text":"What is MkDocs?Accroding to the description from the offical site of MkDocs: MkDocs is a fast, simple and downright gorgeous static site generator that’s geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file. Start by reading the introductory tutorial, then check the User Guide for more information. With MkDocs, you can generate a static site in a minute and deploy it on your server or github pages. InstallationFirst, make sure that Python was installed on you PC and install MkDocs with follow command. 1pip install mkdocs Create a new project 12mkdocs new my-projectcd my-project mkdocs.yml is the configuration file. The docs folder contains your markdown source files. 1mkdocs serve You can preview the site at http://127.0.0.1:8000/ in your browser. DeployingCreate a Github repository. clone to your local directory and add site/ to .gitignore 12345mkdir docscd docsmkdocs new .mkdocs buildmkdocs serve Write your docs in the folder docs. Then run the command: 1mkdocs gh-deploy --clean It will create a gh-pages branch in your respository and deploy the static site on your github page. Set the default branch to built github pages. You can access you site at https://&#123;username&#125;.github.io/&#123;projectname&#125;. Use MkDocs-Material Theme1234Install gtk3-runtime-3.xxx-ts-win64.exe at https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer/releasespip install --upgrade setuptoolspip install mkdocs-material Configure the sites in mkdocs.yml refer to the official documents. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778site_name: Notebooksite_url: https://landfill.cc/wiki/#site_description: cs WIKI#copyright: Copyright © 2020 [Landfill](https://www.landfill.cc/)nav: - Home: index.md# - DEV: dev.md - Documents: - Usage : test/usage.md - Tutorial: test/tutorial.md- Data Structure: - AVL Tree: DataStructure/about.md- OS: - OS NOTES: OS/os.md- test: test.md #主题theme: name: material #custom_dir: material language: &#x27;zh&#x27; # 配置语言 palette: # 颜色 # - scheme: default primary: indigo accent: indigo # toggle: # icon: material/toggle-switch-off-outline # name: Switch to dark mode # - scheme: slate # primary: indigo # accent: indigo # toggle: # icon: material/toggle-switch # name: Switch to light mode features: - navigation.tabs # horizon tabs - navigation.tracking - navigation.expand - navigation.top #custom_dir: &#x27;docs/resources/&#x27; font: text: Roboto code: Roboto Monomarkdown_extensions: - admonition # 提示块 - footnotes # 脚注 - meta # 定义元数据，通过文章上下文控制，如disqus - pymdownx.caret # 下划线上标 - pymdownx.tilde # 删除线下标 - pymdownx.critic # 增加删除修改高亮注释，可修饰行内或段落 - pymdownx.details # 提示块可折叠 - pymdownx.inlinehilite # 行内代码高亮 - pymdownx.mark # 文本高亮 - pymdownx.smartsymbols # 符号转换 - pymdownx.superfences # 代码嵌套在列表里 - codehilite: # 代码高亮，显示行号 guess_lang: false linenums: true - toc: # 锚点 permalink: true# - pymdownx.arithmatex # 数学公式 - pymdownx.betterem: # 对加粗和斜体更好的检测 smart_enable: all# - pymdownx.emoji: # 表情# emoji_generator: !!python/name:pymdownx.emoji.to_svg# - pymdownx.magiclink # 自动识别超链接 - pymdownx.tasklist: # 复选框checklist custom_checkbox: trueextra: search: language: &#x27;jp&#x27;#扩展样式# extra_css:# - resources/css/extra.css","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"MkDocs","slug":"MkDocs","permalink":"https://blog.210222.xyz/tags/MkDocs/"},{"name":"blog","slug":"blog","permalink":"https://blog.210222.xyz/tags/blog/"}]},{"title":"两种选择","slug":"2021-04-23-两种选择","date":"2021-04-22T16:22:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/randomness.html","permalink":"https://blog.210222.xyz/posts/randomness","excerpt":"","text":"几年前一个台风天，我半躺在床上望向窗外，观察自然的诡秘力量，一个塑料袋在十多层的楼宇间漂流，被肆意拉扯，而后从视野之中消失。后来这场景常以不同形式出现在梦中，世界的随机性在梦境中得到完全体现。 上帝就像花园里拿石头漫不经心地砸蚂蚁的小孩，无法预知下一锤会落在谁头上。无从得知一个人对自己的生活到底有多少掌控力，就像无从得知上帝是否存在，宇宙是否有界限，幸福能否被把握。整个世界进程在不停地生产随机数，如同彩票摇号。人生盲盒也是充满惊喜，不可预料。但人比蚂蚁更痛苦的地方在于，人意识到自我的存在，有贪嗔痴种种欲念，所以不得不潜入这巨大的幻觉，以之为真实。 不是说在这个漫长的历程中只有痛苦、随机、或者被决定。人能一定程度上免于这些刑罚。月初的一个下午，我在小区里遛狗，阳光与风都和煦宜人，我无所事事地看着隔壁操场奔跑的中学生。在那其中的某个短暂时刻，我感受到巨大的解脱。没有多的奢望，没有持续的精神压力，不想从世界上得到什么，世界也不向我索取，好像短暂从世界中抽离，进入真空地带。每当这样的时刻出现，我都很想将其保存下来，这些时刻太稀有、太短暂，末了又将回到那高浓度的惨烈生活之中。 我想过很多次死亡，以各种方式。但我是懦弱之辈，始终无法走出那一步。只能强忍着，一点一点匀着吃完我的份额。整个过程像是被投入深不见底的枯井的石头，看不到尽头的光亮，不过时间久了也自然会习惯，这种无法停止也无所倚靠的幽暗状态。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"恶心","slug":"2021-03-21-恶心 ","date":"2021-03-24T16:01:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/nausea.html","permalink":"https://blog.210222.xyz/posts/nausea","excerpt":"","text":"这一切令人恶心，整个世界以及全部的人。空气中弥漫着腐烂的味道，死老鼠在瓦解，变成一团失水的死肉。 天空是漆黑色（#000000，如同从天而降的铁幕，密不透风，没有任何光线可以逃匿，氧气正在变得有毒。 我感到饥饿，内脏发出惨叫，在嘶吼，饮食的欲望占据头脑，渴望进食，如同渴望饿死，遗传的原始本能占据了上风。 分不清梦境和现实，在虐杀和死亡中来回切换，所有的迹象都汇聚成一种神谕，不可违抗的意志，时代在召唤。 相信概念，坚持理想，积极行动，都不过是徒劳，人所建筑的一切是海滩上的沙堡，一个浪就沦为废墟，什么是真正重要的，什么可以被把握，都好似无所谓，只有疲倦是人类精神永恒的归宿。 具体的人，具体的事，都面目可憎，催吐，难以面对。等待意识上传那一天，把所有神经元击烂成一串无序0 1，无意识永生。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"语言碎片 2020/09","slug":"2020-09-27-回忆是时间的复仇","date":"2020-09-26T16:22:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/thoughtsof202009.html","permalink":"https://blog.210222.xyz/posts/thoughtsof202009","excerpt":"","text":"1.回忆是时间的复仇。 2.Everything will flow. 3.住在一间好像永远在落雨的房子，心也是皱巴巴的。 4.不要把你不值钱的一切都托出 That means nothing. 5.恐惧与焦虑、爱与被爱、渴望理解、精神的无依、幸福与痛苦，所有的一切都是巨大的泡影，一想起一生都要和自己的种种幻觉做斗争就累的想从楼顶跳下去。 6.Pull yourself together.It’s nothing but illusion. 7.当我们在回忆的时候，我们是在回忆什么，那些永远不会复现时间片段，是大脑皮层的化学反应吗，一切支离破碎的感觉是真实的吗？ 8.如果一个人一年拍5000张照片，那么他会在意自己从前拍了什么吗？ 9.生命力可能在很久以前就枯竭了。现在每天的感觉是疲倦，不是无意义。 10.就是一个又一个问题接踵而至，而活着的全部过程是在解决问题。 11.Everything in its wrong place.","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"超越规训社会/韩炳哲","slug":"2020-07-26-超越倦怠社会","date":"2020-07-25T16:24:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/Mudigkeitsgesellschaft.html","permalink":"https://blog.210222.xyz/posts/Mudigkeitsgesellschaft","excerpt":"","text":"​ 福柯的规训社会（ Disziplinargesellschaft）由医院、疯人院、监狱、营房和工厂构成，已经不再适用于描述当今的社会。取而代之的是另一种社会形态，由健身房、办公楼、银行、机场、购物中心和基因实验室建构的社会。21世纪的社会不再是一个规训社会，而是功绩社会。其中的成员也不再是“驯化的主体”，而是功绩主体。他们成为自身的雇主。那些规训机构的围墙，过去用来分隔正常与异常的疆域，现在变成历史的遗迹。福柯的权力理论无法阐释从规训社会转向功绩社会过程中发生的心理和形态上的变化。过去流行的概念“监控社会”（ Kontrollgesellschaft）也不再适用于这一转型，因为其中包含了过多的否定意义。​​ 规训社会是一个否定性的社会。各种否定性的禁令在其中占据主导。否定性的情态动词一“不允许＂（ Nicht dürfen）控制着一切。“应当＂（ Sollen）中也附着否定性、强制性。功绩社会越来越摆脱了否定性。不断升级的去管制化进程取消了否定性。功绩社会使用一种积极的情态动词一打破界限的“能够”（ Können）。集体复合性的肯定句＂是的，我们可以办到！＂恰当地表达了功绩社会的积极属性。禁令、戒律和法规失去主导地位，取而代之的是种种项目计划、自发行动和内在动机。规训社会尚由否定主导，它的否定性制造出疯人和罪犯。与之相反，功绩社会则生产扣郁症患者和厌世者。​​ 从规训社会向功绩社会的范式转移在一定程度上也存在延续性。将生产最大化的渴望显然存在于社会集体无意识之中。当生产达到定发展阶段时，禁令的规训法则，或者说其否定模式，便达到其极限。为了进步扩大生产，规训范式必须由功绩范式，或曰“能够”的肯定性模式来取代。因为当生产水平发展到一定程度时，禁令的否定性起到阻塞的效果，妨碍了继续发展。肯定性的“能够”比否定性的“应当”更有效率。因此社会集体无意识由“应当”转向“能够”。较之驯化的主体，功绩主体更高效、多产。“能够”并没有撤销“应当”。功绩主体依然接受规训。他已经逾越了规训阶段。规训法则，即“应当”式律令，保障了生产程序，“能够”则进一步提高生产水平。就提高产量而言，“应当”和“＂能够”之间不存在断裂，反而展示了一贯性。​​ 阿兰 · 埃亨伯格（ Alain Ehrenberg）将抑郁症视作规训社会向功绩社会转型期产生的并发症状：“当控制行为的规训模式让位于另一种规范时，换言之，过去通过权威和禁令分配社会阶级和两性角色，如今每个人必须自发地行动，每个人都有义务去成就他自身，抑郁症就在这时开始盛行。抑郁定患者没有最大限度地发展自身，他在必须成就自身的努力中疲力尽。＂[1] 阿兰 · 埃亨伯格仅从自我管理的视角看待抑郁症，这是成问题的。他认为，这一社交命令一一人仅属于自身是导致抑郁症的原因。在他看来，当晚期现代的人类无法成就自身时，抑郁症就是这一失败的病理学表现。然而，正是人际关系的匮乏导致了抑郁症，这种匮乏是日益碎片化、分裂化社会的典型症状。埃亨伯格没有注意到抑郁症的这一面向。他也忽视了功绩社会内部的系统性暴力，正是这种暴力导致了精神梗阻。因此，并非“人仅属于自身”的社交命令，而是成就压力造成了过劳式抑郁症。由此可见，倦怠综合征（Burn-out- Syndrom）不是表达了筋疲力尽的自我，而是表达了疲意、燃尽的（ ausgebrannt）心灵。按照埃亨伯格的观点，当规训社会的规定和禁令让位于主体自主承担责任和自发行动时，抑郁症便开始流行。但事实上，并非过多的责任和自主性导致疾病，而是作为晚期现代社会新戒律的效绩命令（ Imperativ der Leistung）。​​ 阿兰 · 埃亨伯格错误地把当下的人类等同于尼采的主权独立的人：“主权独立的人，不模仿任何人，尼采曾宣告他的降临，如今此类型的人即将大量出现。没有在他之上的权威告诉他，他应当成为什么样的人。因为他宣称自己只属于自身。”[2] 恰恰相反，按照尼采的观点，即将大量出现的不是主权独立的超人，而是只会劳作的“末人”（der letzte Mensch）[3] .这种新型的人类，亳无防御地陷入过度的积极性之中，没有任何独立自主性可言。抑郁的人是一种劳作动物（ animal laboran），他在没有任何外力压迫的情况下，完全自愿地剥削自我。他同时是施暴者和受害者。自身严格来说是一个兔疫学范畴。抑郁症则彻底脱离了免疫学范式。当功绩主体不再能够（继续工作）时，抑郁症就在这一时刻爆发。它首先是种对工作、“＂能够”的倦怠感。只有在一种相信“一切皆有可能”的社会中，才有抑郁症病人发出哀収:＂没有什么是可能的。”不再能够的能够（ Nicht-Mehr- Können-Können）导向一种毀灭性的自我遺责和自我攻击。功绩主体和自身作战。抑郁症患者是这场内在战争中的伤残者。一个社会苦于过度的积极性，因此患上了抑都症。它所反映的，是那种同自身作战的人类。​​ 功绩主体不受外在的统治机构控制，没有外力强迫他工作或剥削他。他是自身的主人和统治者。因此他无须屈从于任何人，或者说只屈从于自身。这正是他有別于规训主体之处。但尽管摆脱了统治机构，却没有导向自由。自由和约束几乎在同一时刻降临。功绩主体投身于一种强制的自由，或者说自由的强制之中，以达到最终目的效绩的最大化。[4] 工作和效绩的过度化日益严重，直到发展成一种自我剥削。这比外在的剥削更有效率，因为它伴随着一种自由的感觉。剥削者同时是被剥削者。施虐者和受害者之间不分彼此。这种自我指涉性产生了一种悖论式自由，由于其内部固有的强制结构而转化为暴力。功绩社会的精神疾病，便是这种悖论式自由在病理学上的显现。 [1] Alain Ehrenberg， Das erschopfte Selbst. Depression und Gesellschaft in derGegenwart， Frankfurt a. M. 2008， S. 14[2] Ebd. , S.155[3] 尼采的“末人”将健康奉为神明：“他们崇拜健康。‘我们找到了幸福’——末人说着，眨眨眼睛。 （Also sprach Zarathustra， Kritische Gesamtausgabe， 5. Abteilung， 1. Band， S.14.)[4]自由的原始含义即和否定性联系在一起。它永远是一种受约束的自由，以免疫学式的他者为出发点当讨度的积极性消灭了否定性时，自由也便失去了意义，由干它起源于否定之否定的辩证关系。","categories":[{"name":"摘录","slug":"摘录","permalink":"https://blog.210222.xyz/categories/%E6%91%98%E5%BD%95/"}],"tags":[{"name":"Excerpt","slug":"Excerpt","permalink":"https://blog.210222.xyz/tags/Excerpt/"}]},{"title":"DIGITAL GRAVEYARD","slug":"2020-07-20-墓碑","date":"2020-07-19T16:30:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/gravestone.html","permalink":"https://blog.210222.xyz/posts/gravestone","excerpt":"","text":"贾宏声（1967-2010）豆瓣影人 - 贾宏声 许立志（1990-2014）许立志诗选：我咽下一枚铁做的月亮…… | 凤凰诗刊 豆瓣读书 - 新的一天 江绪林（1976-2016）周保松：一些未曾說完的話 ──紀念江緒林先生逝世兩週年 豆瓣主页：江绪林 微博主页：江绪林 吴宇清（1967-2017）一个叫吴宇清的男人决定去死 豆瓣主页：外外 南京地下音乐记录97-98 - 关于这盒磁带 胡波（1988-2017）豆瓣电影 - 大象席地而坐","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[]},{"title":"去往远方的猪圈","slug":"2020-07-15-Openweb与中文互联网","date":"2020-07-14T16:30:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/digital-panopticon.html","permalink":"https://blog.210222.xyz/posts/digital-panopticon","excerpt":"","text":"1、 下午随手更新了一下Clash的配置文件。发现节点都无法显示。查资料发现似乎是解析配置文件的规范做了调整，于是下载了新版的Clash，发现购买的另一家机场尚未按新的规范写配置文件，又解析不了。于是又开始手动修改，浪费了人生中的一个多小时。 这些年为了跨过GFW，鼓捣了不少东西。花了很多的力气，只是为了实现那么一件本该很简单的事情：自由地访问互联网。在这件事情上我一直是个实用主义者，我只希望用早少的精力，来访问Google和YouTube罢了。虽然花一些时间暂时能实现，但这些工具终究不过是义肢，充满了不便。偶尔在中国大陆之外直接访问这些全世界都在使用的网站甚至会产生微弱的兴奋感，这是我们所独有的「小确幸」。 我只有一个观点，自由访问互联网是和自由阅读书籍一样重要的权利。任何支持GFW的言论都是可笑至极的。 2、 另一个问题是，在这个大的局域网中还有多少局域网呢？李如一的系列文章「告别微信两周年」已经写的很详尽了。网络空间事实上已经被大公司分割成碎片，加上日益束紧的社会文化环境，「中文互联网内容枯萎」、「百度已死」似乎是一种必然，难道期待死水里盛开出什么吗？ 如今，Netizen这个词已经不合时宜了，大量的当代互联网用户已经失去其主体性，访问互联网的用户只不过是面目模糊的「流量」，是数据库的数据，是广告喂食填充的禽类。而我们也相当配合，把自己装进一个个笼子里，被上传。在成熟之后，屠宰、肢解、流转、端上餐桌。商业社会有着一整套精细的流程控制这种逻辑的运转。 攻壳机动队里有个有意思的问题：如果放弃肉体，把Ghost上传到网络，在网络中如何维持个体性？还是最后都化为一团混沌？ 3、 后COVID-19的世界在日益走向封闭，我也不知道在这样的浪潮里，个人能做些什么，或许如 Bill Hicks 所说，see all of us as one是一种个人可以践行的心态。 But it doesn’t matter, because it’s just a ride. And we can change it any time we want. It’s only a choice. No effort, no work, no job, no savings of money. Just a simple choice, right now, between fear and love. The eyes of fear want you to put bigger locks on your doors, buy guns, close yourself off. The eyes of love instead see all of us as one. Here’s what we can do to change the world, right now, to a better ride. Take all that money we spend on weapons and defenses each year and instead spend it feeding and clothing and educating the poor of the world, which it would pay for many times over, not one human being excluded, and we could explore space, together, both inner and outer, forever, in peace. 4、 近期看了一些关于开源社区的资料，感觉很有启发。 Apache 是如何运作的？ Vue.js：纪录片 互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz 虽然带着浓厚的理想主义色彩，但他们和盗火的普罗米修斯一样伟大。 5、 想起 紀念南亭村的一隻豬，也许世界本来就是一个又一个巨大的猪圈，但不应该放弃奔跑，直到走了很远的路，看见围栏，然后跨过去。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"Google Keep 闯作收录","slug":"2020-07-09-Google Keep 闯作拾遗","date":"2020-07-08T16:30:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/keep-notes.html","permalink":"https://blog.210222.xyz/posts/keep-notes","excerpt":"","text":"2018-3-3“答应我，不要把我遗忘！”老张临下班时紧紧攥着我的手说 2018-3-23城市垃圾从广州大桥一跃而下 夺取一种真正的伟大胜利 这是它最后的尊严 2018-3-28赤条条的小李在雪地里疯狂打滚 好几个小时 他炙热又痛苦的心啊 2018-3-29无论如何 先活到夏天看看女孩儿们的短裙吃一个五羊牌甜筒直到长柄伞被台风吹折 2018-4-4阿森纳，坚持住好事情会发生——温格下课！ 2018-4-14来自二沙岛中心的大功率宇宙广播，“当代生活是autoregression，保持警惕” 2018-4-171. 愚人码头是不是有去往幸福的船 2. 雄性人类有没有好人，感觉没有 3. 现代人普遍焦虑，秃头成为一种进化趋势 2018-5-8想了一个新媒体创业项目，开一个微信公众号，每天晚上10点更新，内容是从小区里随便抱个猫回来放在Cherry红轴机械键盘上，自由活动3分钟，阅读量每篇10w+应该没问题 2018-8-12现代人走进CBD或者从一个小区走进另一个小区，会不会产生一种「又回到原点」的困惑。很多人没有手机，小区都走不出去，我敢说。更别说找到正佳广场东南门了。 我的思考，十年后的城市，一种postpostmodern建筑设计风格。写字楼，住宅全部统一设计（取消别墅），建筑长宽高统一（100×100×100m立方体），外立面统一（玻璃幕墙，反射能力强），实现一套图纸用全国，严肃，统一，整齐。取消绿化，取消路牌，取消postmodern。 一种真真正正的「钢铁森林，镜面迷宫」，走国人民一同步入communismpunk，新时代，温暖，眼角湿润。 2018-9-171. 就像是开着捷达追一列时速300的火车，所有的渴望都越来越远，直到最后一个车厢也消失在视野里，你冲出匝道，把中午吃的炒牛河通通吐了出来 2. 山竹，带我走吧，我想回家了 2018-12-20语言是无能的，残疾的，你能感受到，但你不能说。 2019-1-5你在修建通往何处的路？ 2019-2-24巴士 开往目的地4:01 4:02 …4:59无限循环meta reflexion 2019-3-6如果把当前的痛苦放到更长远的时间轴里，不过是茫茫痛苦里片刻。 2019-4-7只是南方 黏腻，潮湿，水泥砂浆，下水道，95#汽油味、雪茄味、鱼腥味散不开， 一洼水，漆黑一片的江边，空气静止，易拉罐上的液化水珠，分不开两张淋湿的纸 你就是在这样的味道里 变成了别的东西 2019-4-28Air在1998年发行的专辑《moon safari》是对21世纪的一种昭示。人类不再囿于土地，从天空升起，一次真正的太空奥德赛。大规模漂浮的地球人像一场沙尘暴，席卷太阳系，勇敢地凝视黑洞。光速接近主，成为伟大的造物。 而2001年在不断回到过去，人类却仍然无法集体走向太空。70亿人被囚禁在地球上，一个敞口的重力牢笼，所有降临在这片土地上的生命都回避不了面前的那颗巨石。 2020-4-8禽兽森林充分暴露了人体堂的反动本质，毁了一代社会主义接班人，现实生活一泡污，还天天在岛上摇树抓蝴蝶砸石头。发现索尼才真是良心会社，同样价格的主机输出4K画面，支援HDR，性能强劲，等待PS5发布那一天，一切就会好起来。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"Breaking Out of the Prisoner's Dilemma","slug":"2020-07-09-内卷","date":"2020-07-08T16:24:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/how-to-break-prison.html","permalink":"https://blog.210222.xyz/posts/how-to-break-prison","excerpt":"","text":"一、 月初，本科学校有人跳楼。昨天看到同学在群里发的链接，一个知乎问题。这种事情显然是不会出现在新闻报道上的。 这几天高考，想起我曾就读的高中也是省里著名的高考工厂，每年也有很多人跳楼。最接近事故现场的一次我在几十米外的地方吃饭，后来听人复述才知道我当时就在附近。现在时间久了我都开始怀疑这件事情是否真实发生过。 我高中班主任，一提起他，他那令人恶心的笑容就还会出现在我脑海里，就常常把学生自杀这件事情当做课堂上的谈资。我还记得他讲过的一次自杀事件。当时有个学生夜里从宿舍六楼跳下来没有当场毙命，又爬到前门去敲宿管的门，然后送去了医院。寻死不成又想活下去，在他眼里似乎很好笑，他那嘲弄又幸灾乐祸的语气令人不适。不知道这位同学是否还在这个糟糕的世界上，活着的话，现在也不知道如何了。 二、 在这样怪诞的地方和时代活着的正常人，多少都有些不正常。以前本科一位老师说，中国高校每年自杀人数教育部是有quota的。这样的事情似乎常常发生，甚至需要被制度化。 在开头的知乎问题，看到很多匿名答案讲述自己的经历，那种满溢的失败感，也常常从我心里涌起。在这样一种一元的价值体系里，失败的生活是不值得过的，是理所应当的想法。但没有尽头的内卷，只会把所有人抽干。如同囚徒困境里的囚犯，互相出卖的越多，得到的效用只会越低。我们就是在朝着那个更差的均衡无限跌落。成为不值一提的代价。 三、 其实囚徒困境是有两个纳什均衡的，我们只有携手走向另一个均衡方才有救。但我想这只是痴人说梦，我们还处于霍布斯的自然状态，更侈谈合作。连日的暴雨已经令我头脑发昏，丧失理智。或许在这不讲理的世道，不做囚徒才是唯一得救。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"Aria2+Bilibili Evolved批量下载B站视频","slug":"2020-07-08-Aria2批量下载B站视频","date":"2020-07-06T16:24:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/aria2-bilibili.html","permalink":"https://blog.210222.xyz/posts/aria2-bilibili","excerpt":"","text":"1、下载文件 aira2 release 1修改路径 aria2-1.34.0-win-64bit-build1` -&gt; `bin aira2配置 123git clone https://github.com/ttttmr/aria2-conf.git修改路径aria2-conf-master` -&gt; `conf 2、配置环境变量 右键此电脑 -&gt;高级系统设置 -&gt; 环境变量 -&gt;系统变量-&gt;新建Path 把aria2c.exe所在的bin目录填进去D:\\portable_program\\aria2\\bin 3、配置必要信息 conf/aria2.conf 12345#设置密码18 rpc-secret = xxxxxx...89 dir = D:\\Download#填默认下载目录 4、启动 1234如果要自启动 把HideRun.vbs的快捷方式发送到startup %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup启动双击 start.bat ，后台运行双击 HideRun.vbs ，关闭双击 stop.bat ，重启双击 restart.bat 5、配置webui-aria2 webui-aria2是aira2的GUI。填入刚才conf设置的秘钥 6、安装TemperMonkey脚本 BilibiliEvolved 7、附加功能-&gt;下载视频-&gt;批量导出-&gt;aria2 RPC ，配置同上。开始下载就可以了。 8、按需要可以配合Chrome插件接管浏览器的下载。 参考：aria2 简单使用","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.210222.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Aria2","slug":"Aria2","permalink":"https://blog.210222.xyz/tags/Aria2/"}]},{"title":"如何确立一种深信不疑","slug":"2020-07-01-如何建立一种深信不疑","date":"2020-06-30T16:24:46.000Z","updated":"2025-02-09T16:40:37.847Z","comments":true,"path":"posts/how-to-believe.html","permalink":"https://blog.210222.xyz/posts/how-to-believe","excerpt":"","text":"一、Fortran语言之父John Backus 在获得图灵奖的时候讲了这么一段话，描述冯诺依曼瓶颈 Surely there must be a less primitive way of making big changes in the store than by pushing vast numbers of words back and forth through the von Neumann bottleneck. Not only is this tube a literal bottleneck for the data traffic of a problem, but, more importantly, it is an intellectual bottleneck that has kept us tied to word-at-a-time thinking instead of encouraging us to think in terms of the larger conceptual units of the task at hand. Thus programming is basically planning and detailing the enormous traffic of words through the von Neumann bottleneck, and much of that traffic concerns not significant data itself, but where to find it. “intellectual bottleneck “这个词精确而微妙。genetic bottleneck，intellectual bottleneck，谁在束缚你？ 二、 最近在知乎读到一个问题：为什么矩形面积等于长乘宽? 那么多显而易见的问题，并不是那么得显而易见。 回答里甚至有人说，这是小学生都懂的东西。从某种程度上来说，我们都可以算是他口中的小学生。对于某些问题不应该去深究，这是做正常人的要义。这是我们一直受到的教育，「服从」是我们教育里很糟糕的一点，渗透在社会的每一个角落，讨厌至极。 三、 我发现，当进入一种生活模式后，人就会陷入一种时间的惯性，生活坍缩进一个没有维度的空间，很难去怀疑那些如真理的日常的正当性。很多人对生活道路的深信不疑就来自于这样一种未经考量的惯性。 现在才渐渐意识到用一些时间去审视过去是有帮助的。没有白走的路，也没有不付出代价的选择。至少还不算太晚明白。用行动去实践意义，而不是空想。 四、 Why not thinking in terms of the bigger picture?","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"更换电脑Hexo博客迁移","slug":"2020-06-21-HexoSync","date":"2020-06-20T16:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/hexo-blog-sync.html","permalink":"https://blog.210222.xyz/posts/hexo-blog-sync","excerpt":"","text":"上传电脑中博客的源文件 1.生成的静态网页(.deploy_git)放在master分支在paranoiddeon.github.io 新建hexo分支存放博客源文件(除.deploy_git外的文件)，在该仓库的setting&gt;branch&gt;default branch设为hexo。在本地任意目录打开git bash： 1git clone git@github.com:paranoiddeon/paranoiddeon.github.io.git 2.在克隆到本地的paranoiddeon.github.io中，把除了.git 文件夹外的所有文件都删掉。把之前博客文件夹中除了.deploy_git的文件全部复制到paranoiddeon.github.io中，删除theme文件夹中可能存在的.git 文件夹，避免嵌套上传失败。之后把博客的源文件上传到hexo分支： 123git add .git commit –m &quot;add branch&quot;git push 3.因为之前博客使用的主题是从第三方仓库clone的，在执行git add .的时候出现了”fatal: in unpopulated submodule maupassuant” 错误，导致主题文件夹没有被上传，所以需要删除再重新add该目录，在theme目录中执行： 12git rm -rf --cached maupassuant //删除文件夹git add maupassuant 在新电脑(Windows)重新搭建环境 1.下载安装Git 2.设置git全局邮箱和用户名 12git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot; 3.设置ssh key 12345ssh-keygen -t rsa -C &quot;youremail&quot;Are you sure you want to continue connecting (yes/no)? #输入yes 生成后填到github 在提示的文件目录复制id_rsa.pub 添加到github（settings&gt;SSH keys)#验证是否成功ssh -T git@github.com 4.下载安装nodejs5.安装hexo1npm install hexo-cli -g6.在新电脑clone博客源文件1git clone git@github.com:paranoiddeon/paranoiddeon.github.io.git7.安装hexo-deployer-git 12345cd paranoiddeon.github.ionpm installnpm install hexo-deployer-git --save//用于将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，//并且完全覆盖该分支下的已有内容。 8.生成部署博客网页 12hexo ghexo d 如果在多台电脑上同步博客，写完上传到远程仓库123git add . //所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)git commit –m &quot;xxxx&quot; //将暂存区里的改动给提交到本地的版本库。git push //将本地版本库的分支推送到远程服务器上对应的分支在另一台电脑pull1git pull//取回远程主机某个分支的更新，再与本地的指定分支合并","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.210222.xyz/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://blog.210222.xyz/tags/Blog/"}]},{"title":"语言碎片 2020/06","slug":"2020-06-30-thoughts2020-06","date":"2020-06-14T14:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/thoughtsof202006.html","permalink":"https://blog.210222.xyz/posts/thoughtsof202006","excerpt":"","text":"1.既然可以随时选择死，为什么不换种活法 2.为什么这样子，我真的不理解 3.人是如此的易驯服，被他们那套搞一搞，成为一头圈养的家猪，变得丑陋而讨厌，仿佛生下来就在等待屠宰，野猪的精气神儿就完全不一样。 4.Welcome to the slaughterhouse! 5.What kind of savages are we？ What kind of country do we live in？ 6.痛苦的药方就在痛苦之中 7.活着成为猪和死了也不知道哪个更可怕 8.行动！加速融入生活 9.哦 眼泪~ 10.眼睛都哭模糊了，浴室，我的伤心地 11.2020，罗大佑年，多次落泪，就这么飘来飘去，哪里是你的家？ 12.黑暗好像一颗巨石，按在胸口 13.夏，十五日夜，秘密发丧，埋于后山。 14.凑活过，一种普世生活哲学，好像一切都能缝补，slogan是「害想咋地？」 15.舒展眉头过失败而渺小的人生也是一种伟大 16.平行世界是真实存在的","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"香港选举制度","slug":"2020-04-25-hkelection","date":"2020-06-10T16:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/hk-election.html","permalink":"https://blog.210222.xyz/posts/hk-election","excerpt":"","text":"一、特首选举：1、特首 任期5年，可以连任一届，获得601票以上。 候选人需获得选委会150人以上提名（提前三个月） 2、选委会 由20多万专业界别登记的选民选出，选举委员会委员是以个人身份投票，而选举委员会每届任期五年 其中宗教界界别分组（60名委员）是由六个指定团体提名产生。香港地区全国人民代表大会代表（36名委员）及立法会议员（70名委员）为当然委员。117个（港九57+新界60）经由民选区议员相互选出而产生 选委会的代表性和有权选举的人存在诸多不合理之处： 例如代表中小学教师的教育界有80,643人有权投票，可选出30个选举委员；与此同时，渔农界只有154人有权投票，却可选出60个选举委员。有些组别例如会计界，只要是注册会计师就可以投票，全港近三万名名会计从业员中有26,001人是选民。但到了保险界，却只有保险公司的东主才可以投票，于是全港近五万名的保险从业员都没有投票权，只有131名东主是选民。至于为什么会计界和保险界有不同做法，是没有解释的。回到刚才提到的渔农界，那154人和现役渔民或农民不一定有关，也不是由他们所选出，而是由规定的一系列渔农业团体作为代表。至于为什么是这些团体而不是另一些团体，这些团体是否有代表性，新成立的团体要怎样才可能为被指定的团体，同样是没有解释的。 二、立法会选举职责： 制定、修改和废除法律（参见：三读） 控制公共开支 监察政府工作 审核、通过政府的财政预算 接受香港居民申诉 同意终审法院法官和高等法院首席法官的任免 如立法会全体议员四分之一联合动议，指控行政长官有严重违法或渎职行为而不辞职的话，立法会可通过进行调查，并委托终审法院首席法官组成独立调查委员会进行调查。如调查委员会调查后认为有足够证据构成对行政长官的指控，立法会会对是否提出弹劾案进行表决。如果立法会以全体议员三分之二通过的话，可提出弹劾行政长官案，并报请中央人民政府决定。 立法会共70议席 任期4年 35个议席：五个选区直选（300多万选民） 香港岛6席：中西区、湾仔区、东区、南区 九龙西6席：油尖旺区、深水埗区、九龙城区 九龙东5席：黄大仙区、观塘区 新界西9席：荃湾区、屯门区、元朗区、葵青区、离岛区 新界东9席：北区、大埔区、沙田区、西贡区 35个议席：29个功能界别 其中： 其他26界：26席 劳工界：3席 区议会第一界别（区议员互选1席） 区议会第二界别超级区议员（5席）由300多万选区选民直选，但是候选人提名（15个以上）及参选都来自区议会 三、区议会选举任期4年，就市民日常生活事务向政府提供意见，没有立法权 18个选区 479席（每年会变化）当然议席27，民选议席452 将会影响：立法会中6席，选委会中117席的选出 2,943,842名登记选民投票，投票率71.23% 57.44%vs41.32%：民主派vs建制派（实际票数）","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Politics","slug":"Politics","permalink":"https://blog.210222.xyz/tags/Politics/"}]},{"title":"Wish You A Speedy Recovery","slug":"2020-05-21-WishYouASpeedyRecovery","date":"2020-05-21T14:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/speedy-revovery.html","permalink":"https://blog.210222.xyz/posts/speedy-revovery","excerpt":"","text":"最近陪我妈动手术期间的一些记录。 健康是首要的。倒不是想活多久，只是没有赴死的勇气，只能期盼活着期间能不用遭遇这些痛苦。生病的痛苦是最直接易感知的，打针、开刀都令人不寒而栗，放弃一部分人的完整性是接受治疗的前提。医院称得上是人类尊严平均水平最低的场所。 不生孩子。做父母的责任之重，不是我所能承受，这是出于自私；孩子会发现存在的痛苦真相，我想必只会是孩子成长过程中的阴影，而无法给与他们任何引导，这是出于责任。 努力赚钱。医院治疗相当花钱，一直以来爸妈对我期待很高，而我到现在为止负起的责任实在太少，应该很令他们失望。 找机会去一趟精神科。心理状态似乎又开始变坏了，越发憎恶自己。以前蛮好的，不知道这些年是怎么一步步变成今天这样的。徒劳地寻找不存在的答案不过是自我折磨。前不久看《阳光普照》大哭，完全受不了阿豪妈妈伤心，所以不论怎样一定会好好生活的。 从最近的生活经验和所见所闻再次验证了这一真理：生活果然就是永恒的疲惫啊。 祝大家健康。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"语言碎片 2020/05","slug":"2020-05-31-thoughts2020-05","date":"2020-05-20T16:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/thoughtsof202005.html","permalink":"https://blog.210222.xyz/posts/thoughtsof202005","excerpt":"","text":"1.矮墙在面前颓然倒下为风牺牲 2.未来是尚未被复写的过去黑色方碑刻着一切 3.意识是痛苦的证明 4.贫穷是恒久不灭的心悸 5.想去Isle of Skye，观看灯塔 6.被抛掷于此间的时候漆黑，喑哑，无力却充分感知到自我的存在意识中徒劳地呼喊没有一个上帝会来搭救清醒后痛苦才汹涌地袭来旁观甚至需要勇气 7.摄影是被完全滥用的技术，人类从此失去了真诚 8.阅读不提供宽慰、解脱和形而上的解答，但感到平静 9.拉普拉斯妖 is watching you 10.将来你必须从头开始，一点点挣脱，所有已经捆绑在身上的，绞索 11.你相信什么？","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"政治哲学/Jonathan Wolff","slug":"2020-04-26-political philosophy","date":"2020-05-09T16:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/political-philosophy.html","permalink":"https://blog.210222.xyz/posts/political-philosophy","excerpt":"","text":"一、自然状态霍布斯人的平等、人连续不断的追求幸福，即满足他们未来可能具有的任何欲求的权力 资源的稀缺，人对他人的恐惧和猜疑 人对人的战争 自然法（集体理性与个体理性，博弈论中的囚徒困境） 洛克存在着道德，自然法的约束，刚开始自然状态下资源不是稀缺的 卢梭人主要受自我保存的欲望驱使 人类动机中的同情和怜悯 自然状态是不可持续的 人是在文明社会中才变得道德堕落的 无政府主义如何区分一个政府和一个依靠其他约束运行的社会 无政府主义的国家是你可以自由选择加入的 二、国家证成两个角度洛克(自愿主义)认为人是生而自由、平等、独立的，他们并非自然而然地处于某个人的权威之下（普通人/主权者），合法的权力关系必定是人类创造和构建的。除了正当的惩罚外，唯有通过表达同意，你才会身处权威之下。 国家的正当性需诉诸同意和社会契约 边沁（功利主义）国家相较于其他方案，使得社会的幸福总量最大化，才具有正当性 国家的特征（理想情况） 在一定领域内垄断合法暴力，所有合法的武力都由国家来实施和监管（马克思韦伯） 为其领土内的所有人提供保护 证成国家需要证明普遍的政治义务，即有服从法律、纳税、保卫国家、爱国等的义务，讨论主要集中于服从法律的义务。 普遍的政治义务不是指在所有时间服从所有法律（也需要考虑法律的正当性等），而是原则这个国家范围内的所有人（当然也存在特权者）有道德义务遵守法律与指令。 社会契约（自愿主义）自愿的义务洛克的自愿主义：需要每个人以某种方式赋予了国家凌驾于其上的权威，而仅仅说国家符合我的利益并不能推出国家的正当性。 历史的同意但在实践中，是历史中真实存在这样一份契约吗。或者契约真实存在，那对子孙后代又有何约束力？原始契约学说无法说明这一问题。 默示同意洛克： 每个人只要占有或享用了任何政府的任何一部分领地，就因此表达了他的默示同意。从而在他与整个政府里的任何人一同享用期间，有义务服从该政府的法律 休谟的反驳： 对于一个贫困的、不懂外语和外国风俗、靠着自己所得的微薄工资度日的农民或工匠，我们能够认真地说他对于是否离开自己的国家具有选择的自由吗？如果能够这样说的话，那么，对于一个睡梦中被人搬到船上、若要离船则只有跳海淹死的人，我们也可以同样宣称，他继续留在船上就表示他自愿地同意了接受船主的统治。 卢梭：在一个“自由的”国家才能这样说，其言下之意是，在一个自由国家，做出不同意行为（离开国家的领土）是非常简单的。 因为否则的话，家庭、财产、无处容身、生活的需要以及暴力等等，都可以不顾一个居民的意愿如何而把他留滞在国内，这时候，单凭他的居住就不能在断定他是同意契约还是破坏契约了。 在现代国家中显然默示同意的条件难以被满足 假想的同意如果身处自然状态没那么我们会做些，想象没有国家的状态，如果我们是理性的，会尽可能的重新签订社会契约，创立国家。 反驳：假想的同意行为并不是同意行为，这和社会契约所要求的同意不一致，只能表明某类国家值得同意，是国家的特征而非我的同意提供了正当性，不是对国家的自愿主义辩护，而更像是一种功利主义辩护。 重构假想同意：我们虽未明确表示同意，但是在某种意义上可以说我们大部分人会同意，有同意国家的倾向，而假想契约的是使我们意识到我们的真实想法。但这是一种很弱意义上的同意，在其他法律或道德语境中，未表达出来甚至尚未得到承认的同意倾向很少具有约束力。 而且存在无政府主义者在假想后仍然反对国家，明确的表达了不同意。 无政府主义如果我们找不到一种办法从一些可接受的前提来证成国家，那么至少从道德上说，我们似乎就不得不接受某种无政府状态。这一批评策略似乎是无政府主义者最强有力的武器。没有人问过我，我们是否应该有一个国家，警察在行动时也没有征求过我的许可。因此，无政府主义者主张，国家与警察都是在以不合法的方式行动，至少在和我打交道时是这样。 服从国家的唯一理由是明智（对惩罚的恐惧） 负责任的公民不应该盲目地遵循法律，而应该始终对法律是否正当的问题上运用自己私人的判断。如果法律不正当就没有道德理由服从。 但是所有人都以私人判断，就会回到混乱状态。 在合理范围内接受一套共同的法律是更好选择。 功利主义直接功利主义当服从比不服从给社会带来更大的幸福 违法者的特许状（如果拿走别人的财产带来社会整体更大的幸福） 间接功利主义需要一系列得到尊重的法律，不是由个人来考虑遵循法律对社会幸福水平的影响，而是从社会整体的角度。 对功利主义的批评功利主义的论证： 前提1：从道德上，最好的社会是幸福得到最大化的社会 前提2：国家比自然状态更能促进幸福 前提3：国家与自然状态是我们仅有的两种选择 结论：我们有道德义务缔造并支持国家 各种无政府主义者会反对前提2，3姑且不论； 前提1也存在着道德风险，如果牺牲个体造就社会的幸福增加（替罪羊问题），会导致极大的非正义，惩罚无辜可以在道德上是正确的。功利主义也可以用来证成奴隶制。 功利主义需要融入权利理论（不受迫害的权利）。 公平原则享受了国家的利益，又不承受有助于这些利益的必要负担，是不公平的。（对同意理论的改进） 休谟：从长期看，服从法律符合每个人的利益，人类并不是非常善于理性地行动，理性作为人的驱动力太弱。 这个观点背后的原则由法律理论家和哲学家哈特（H.L.A.Hart，1907—1992）明确提出 如果一些人根据某些规则从事某种共同事业，并因此限制了他们的自由，那么那些根据要求服从了这种限制的人就有权利要求那些受益于他们的服从的人做出同样的服从。 诺齐克的反驳：没有主动要求的利益不能创设任何回报的义务。得到了和接收了利益是不同的。 这又回到了默示同意的问题了，如何明确表示接收和拒绝利益。 三、谁应当统治民主含义及其争论多数派统治和保护个人权利多数派暴政（托克维尔） 人民自己统治自己也可能存在压迫，因为人民不是同质的，具有非单一的利益 代议制与直接民主投票程序等其他争议反民主的柏拉图专家统治（护卫者），统治是一种技能，应该交由专业的人，征求大众意见导致灾难，实际上一种仁慈的独裁制。 反驳： 把不受制约的权力交给专家也会导致灾难，谁来监督护卫者 如何任命护卫者 投票的意义：发现公共善，人民利益的反映。 孔多塞的论证： 前提1：一般人必须有高于五成的可能性做出正确判断前提2：每个人必须按照他理解的共同善来投票而非特殊利益结论：在大量人参与投票的情况下，几乎肯定可以得到正确的结果 民主过程本身就包含了有价值的东西：自由和平等。人可以在决策中有发言权等自由，且这种自由被赋予所有人 卢梭与公意general will(公意)：要求同等程度上符合每个人的政策，普遍利益the will of all（众意）：每个人特殊意志的产物 公意制定影响所有公民的法律，我由法律统治而非统治者统治，政府不制定法律，而是在具体事务中按照法律行事 是否存在一种公意同等影响每一个人（不同阶级、利益立场的人）？ 即便有一种公意，怎么能得到他，人为什么要按照公意而不是特殊利益投票？ 消除阶层，不能有巨大的不平等； 要么不应该有党派和派系，要么应该有很多；这样特殊群体对整个集体的决定只有很小的影响； 个人必须非常强烈的认同作为一个整体的群体。比如通过公民美德教育的方式来巩固社会纽带。人们要被教育塑造得为了国家而忘记自我。（有些批评者认为这有法西斯的倾向） 审查制：监察官鼓励人们遵循大众道德 公民宗教：每个公民都应该信奉某种宗教，除了私人道德以外，每个人都应该信奉公民宗教 平等：卢梭的公民不包括女性。自由：无神论被禁止；不宽容其他宗教的宗教也得不到宽容；所有人都必须认可公民宗教；个人似乎不再有任何背离传统的生活实验 想到这些限制性的、很不开明的背景，我们可能会问，卢梭如何还能坚持说他已经解决了下述问题：如何找到一种结合形式，在这种结合中，“每一个与全体相联合的个人只服从其本人，并且仍然像以往一样自由”？ 积极自由：卢梭所持的自由观是后来以赛亚·伯林所谓的“积极”自由观。我们将在第四章更详细地考察这个观念，不过这种自由观的基本立场是，自由不仅关乎能够遵循自己的欲望且不受他人约束（一种“消极的”观念），它还要求做出某些行为。通常，主张积极自由的理论家用“过理性人会选择的那种生活”来界定自由。就卢梭而言，这样一种理性的生活唯有在一个公民社会中才有可能。“只有嗜欲的冲动便是奴隶状态，而唯有服从人们为自己所制定的法律，才是自由。” 唯有服从公意行动才是真正自由的，这会导致被强迫成为自由的 对卢梭的批评 公意概念难以实现 对少数派的观点：被强迫成为自由 服从公意不是自由的（存在人反对公意） 不提倡民主集会，反对政治争论 卢梭为了论证民主从工具角度是正当的，把社会团结的纽带勒的过紧，可以实现平等，但不等实现自由（多样性和多元化） 参与式民主直接民主，不仅要制定法律，还要参与所有具体事务 反对： 难以实现，效率低 谁来制定议程，相对于决策，提出问题同样重要 政治生活也并不是全部，许多人也关心政治之外的事情 代议制民主约翰穆勒 专制国家导致消极被动，塑造的民族不关心国家事务，不仅影响个人，也影响国家繁荣 现代社会过于庞大，直接民主不太可能 公民身份（citizenship）教育的重要性：参与陪审团和地方政府 权力分散于制衡，对选举者的制约 公民应该根据他们对普遍利益的理解来投票，出于公共善和良心 公开投票，防止选民出自个人利益投票 有一定文化水平和经济水平才能投票，防止选民太过无知，无法看到公共善 复票制（Plural voting）：先选出选举人，在由他们产生议员 对少数派的保护，限制政府活动的合法领域 四、自由的地位国家应该有多大的权力？ 无政府主义与霍布斯是两个极端 穆勒的答案很激进，又简单得令人耳目一新。穆勒的自由原则（伤害原则）宣称，只有当一个人有可能会伤害到另一个人时，你才能限制其行动自由而不至于不正当。而不是以专断的习俗和大众道德来评判。 适用于文明共同体的任何成员，各项能力已臻于成熟，孩子和野蛮人是除外的，比如孩童就不应该有自由决定是否学习 思想自由对穆勒来说，要注意的第一件事就是，一个观点不受欢迎并不能构成压制它的理由：“如果整个人类除一人之外全都持有一种意见，而只有那一人持有相反的意见，其他所有人不让那个人说话并不比那个人不让其他所有人说话（如果他有那种权力的话）更为正当。 穆勒主张，我们有很好的理由欢迎人们提倡哪怕是不受欢迎的观点。压制这些观点就是“对包括当代人与后代人在内的全人类的剥夺”。 穆勒主张，无论有争议的观点是对还是错，抑或既有对的也有错的，拒绝让其发声对我们绝没有任何好处。如果我们压制一个正确的观点（或一个部分正确的观点），我们就失去了以谬误（整个谬误或部分谬误）换真理的机会。而如果我们压制一个错误的观点，我们就以一种不同的方式有所失：我们失去了一个质疑、再思考并有可能重新肯定我们正确观点的机会。因此，压制并不能给我们带来任何好处，无论所压制的观点是不是真理。 不能假定自己不可能出错，许多被认为是确定无疑的观点和信念已经被证实是荒谬的（地球是平的） 这就证明了人类会犯下巨大的错误。穆勒认为，我们绝没有权利主张自己不可能出错。 认定某一意见正确乃是因为它在一切与之竞争的场合中都未被驳倒，与认定它正确乃是为了它不受反驳，这两者之间有着天壤之别。 即使从功利主义的角度，凭什么断定一种观念会导致更多的危害而非好处。（不信上帝、核武器知识） 信仰真理是一种实现幸福的途径 对他人的伤害唯有造成伤害才能限制一个人的自由。如何定义伤害，边界在哪里。 证成自由原则自然权利：生命权、思想、言论自由、自由机会、迁徙自由、投票和竞选 自然权利是基本的、公理性的，但如何为这些权利辩护。 自然权利是自明的，不是从其他某种论据推出来的，那么为什么不同理论家对有什么权利却有不同看法 边沁：权利是法律的产物，不存在自然权利，洛克完全否认这种观点。 穆勒既不能接受自然权利，又不能依靠传统权利，而是从功利主义的角度推导的 henry sidgwick: government house utilitarianism 私人领域（不受干涉）和公共领域（受到干涉），如何划分界限，穆勒没有明说，只是从功利的角度去得出答案 功利主义与自由的冲突：功利主义鼓励家长式的干预，如果传统道德支配的社会是更符合功利主义的？ 要理解穆勒对这个问题的回应，我们需要再看看《论自由》里那段话的措辞，在那段话里，穆勒宣称他忠实于功利： 在所有伦理问题上，我最终都诉诸功利；但这里的功利必须是最广义上的功利，它基于一个作为进步性存在的人永久不变的利益。 个性与进步个性的自由发展是幸福首要且必不可少的要素之一 虽然自由并非总是带来进步，但进步唯一可靠和恒久的源泉是自由 即便人们会搞错，但个人与其他任何人相比，仍然更有可能正确地看到什么东西会使自己幸福 穆勒声称，独立地做出判断确实会带来更好的后果。但是他的意思并不是说，任何人都不应该影响他人的行为。他特别强调，如果我们觉得别人正在采取一种愚蠢或有害的行为，我们每个人都有义务尽力说服他们相信自己错了。我们可以跟他们讲道理，或者请求他们。但是我们能做的也仅限于此，绝不能采用武力。 一个人不顾别人的建议与警告可能犯下的错误，与容许别人强制他去做他们认为对他有好处的事情，危害要小得多。 从长远看，它会导致更好的决定 不仅如此，自由选择的运用本身对于人性的充分发展来说也是至关重要的。穆勒认为，那些做习俗之奴隶的人永远也不能成长为全面发展的成功的人；未必是因为他们不会幸福，而是因为他们不能发展人类最独特的一种能力，即选择能力。 生活实验是社会进步的主要因素 正如只要人类未臻于完善，存在着不同意见就是有益的，同样，存在着不同的生活试验也是有益的；各种品格只要不伤及他人就应该给予其自由发展的空间；不同生活方式的价值应该通过实践去证实。……这是构成个性与社会进步的主要因素。 批评：对进步的乐观主义 他最重要的观点就是这样一个假定，即人类是可以进步的，能够从经验中学习。最近几个世纪的经验是否表明这个观点是错误的呢？如果是这样，那么穆勒的观点就失去了灵魂。人类持续不断地重复自己的错误。如果人们不会从他人的经验中学习，那么穆勒就不再有理由鼓励生活试验了。如果我们并不准备学习，其他人向我们展示新的生活方式又有什么意义呢？没有了这样一种对生活试验的辩护，个性与自由基于穆勒给出的那些论证而获得的正当性就大打折扣了。实际上，已经有人指出，人类通常处在穆勒专门用来描述“孩子和野蛮人”的那种状态：没有能力通过自由和平等的讨论而进步。而且，正如穆勒本人所说，这样的人不适合享受自由，至少根据功利主义的计算不适合。或许对人类进步的可能性所持的这种悲观主义是一种严重的夸大其词。但是如果真理存在于某种中间立场，如果人类并不如穆勒所设想的那样善于进步，用来支持自由的功利主义论据就相应地削弱了。进步是穆勒学说的基石。 自由作为一种内在善实现社会幸福最大化也许要求一个非自由的社会，难道就是可取的吗？ 穆勒认为自由是幸福的一部分，而不是独立的价值 自由主义的问题毒品、酗酒、卖淫（传统道德的作用） 马克思的批评：政治解放（自由主义）相对于等级制和充满歧视的国家是一种进步，但是是实现人类解放的障碍（分离性，以自我为中心的，市民社会的对抗倾向），是一种肤浅的学说 社群主义(comunitarianism) 积极自由和消极自由（以赛亚柏林） 五、分配正义财产权证成初始获取正义、转让正义、矫正正义（诺齐克） 洛克：掺入劳动论 财产所有权就是盗窃（蒲鲁东） 自由市场功利主义理论不关心怎么来的，关心转让正义 计划经济需要计划者具备一定程度上的全知全能与仁慈，人类是做不到这一点的 反对市场：人的异化（恩格斯），剥削，非正义的不平等，浪费，经济危机 异化是资本主义特有，还是一般的现代技术特有？福利国家的修正 平等主义的分配会抑制主动精神和进取心 罗尔斯的正义理论一种假想的契约 立约环境（原初状态） 无知之幕：不知道天资、阶级、社会地位、性别、种族，特殊心理倾向（道德宗教哲学观），社会经济状况，文明程度，处于正义环境（介于匮乏与丰裕之间） 弱的善理论：想要primary goods（自由、机会、财富、收入、自尊的社会基础） 行动者：理性，mutually disinterested 选择正义原则 a. 每个人都要平等的权利享有一整套最为广泛且相同的基本自由，但这些自由要与所有人类似的一套自由相容（自由原则） b.社会与经济的不平等应该被安排得： 符合处于最不利地位者的最大利益（差别原则） 职位与地位在公平的机会平等条件下向所有人开放（公平机会原则） 自由原则是最优先的，公平机会原则相对于差别原则也具有优先性 自由原则和公平机会原则比较容易从理性上推导 差别原则推导： 预期功利最大化 maximin（小中取大） 物质条件的约束（资源有限） 逻辑约束(每个人都比其他人富裕) 形式约束：公开性约束，契约中的条款都是互相知情的（反驳总督府里的功利主义） 终结性finality，承诺的压力，当安排对你不利时，是无法改变的 只有小中取大不冒险，因为是一次性的不可反悔的选择 maximax（大中取大） 有条件限制的功利最大化：无法明确条件限制，最终会变成小中取大 为什么要选择这种理论 对罗尔斯的批评弱的善理论是基于现代资本主义生活的个人能力相对于社会赋予的因素的微不足道 诺齐克与模式限制财产是限制自由，与自由原则相悖 历史性正义理论 historical：了解如何获得资源和资源分配依据 即时性正义理论 end -state： 只看到某个时点的分配状况 模式化理论：根据xx来分配 非模式化理论：程序性理论，通过正当程序获得goods 模式的变化 任何模式都会被打破 从一种模式到另一种模式是处于自愿，如果模式1是正义的，模式2也是正义的（纯粹自愿也不一定正义的） 模式想要强制实施就只能让自由付出沉重代价。不断地干预分配 六、当代问题女性主义、种族问题、性取向，压迫、传统价值观，全球正义，移民，子孙后代。 论述较浅 附录：书单","categories":[{"name":"Notes","slug":"Notes","permalink":"https://blog.210222.xyz/categories/Notes/"}],"tags":[{"name":"Politics","slug":"Politics","permalink":"https://blog.210222.xyz/tags/Politics/"}]},{"title":"说一说在我老家，人们的生存状况","slug":"2020-04-20-hometown","date":"2020-04-19T16:22:46.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/home-waste-land.html","permalink":"https://blog.210222.xyz/posts/home-waste-land","excerpt":"","text":"（一） 以前回我奶奶家过年的时候，附近邻居有个姐姐，因为眼睛小，笑起来总是眯成一条缝，人家都叫她眯眯。我算不上认识她，我和她唯一的交集，是有一次她路过我家门口，在她快走远的时候，我恶作剧似地老远喊了声“眯眯”，她停顿一下回过头，也不怎么生气，反而是眯起眼笑了起来。 她现在疯了。清明节回我奶奶家听说的。几年前她怀孕，她爹嫌弃男孩家经济条件太差，强行拆散了这段关系，带她去做了流产。后来她爹给她相亲了几次，都是订婚不久男方又反悔，多次“退货”，在农村的讲述中用的是这个词。具体的缘由不得而知，有人说是精神状态出了问题，也有传言说是因为流产无法再有孩子了。再后来，眯眯就疯了。常常自言自语，有时候会无端端骂人。 眯眯疯了之后，每天和她妈妈形影不离，晚上也是和她妈妈一起睡的。她妈妈去年突发脑溢血去世，她爹没过几个月就再婚了，对眯眯的态度的是：谁要就赶快带走，不要一分钱彩礼。“眯眯现在可怜哦”，我奶奶如此评价。十多年前她回头的那个笑容，我可能再也无法忘记了。 （二） 很多人可能不知道农村结婚有多么简单。先找人介绍认识，男女双方可能只用见一两次面，在双方家长的陪同下，甚至不是单独的约会，就可以确定一桩婚事。如果双方（家族）凭借着一两次的了解都比较满意的话，就可以订婚，领结婚证了，不举办婚礼的话，这事情就算结束了。虽然听上去很不现代，但这就是大部分农村家庭的普遍状况。 虽然我对婚姻总体上都抱有一种悲观的立场，但这样的婚姻可能更需要一些运气。双方达成的更像是一个搭伙生活的契约，进而保持传宗接代的传统。我发现他们都是这样毫不审视地生活，完全天然地接受命运的一切安排，毫无例外。生活地幸福与否那就是个概率问题了。我有时候会有些羡慕，因为我即使知道我是怎么样的宿命，也基本上无法改变太多。除了更深更明白的绝望，审视自己的生活对我没有其他益处。 （三） 大概有十来年没有回家做清明，这些年间先后失去了三位亲人，从我爸妈那也常会听说某些认识的人的离世。死亡成了越发日常的事情，这可能就是年纪增长的一个佐证吧。生老病死，一代人接续一代人，装着家族记忆的坟一座座地立起来，孩子不断地出生，像是一个无法打破的坚实循环。 那天在山上，新草铺满了山坡，燃烧的黄纸化成成片的灰烬，在半空飘扬。祭扫有很多的仪式，“到你们这代或许就断了“，一位长辈无奈地说。我看见我爸在远处抽烟的背影，内心有些悲伤。将来有一天，我也将站在那个位置。 我的小外甥女纤雪今年十岁，时隔一年多没见，她还记得我叫我舅舅。她外公也就是我舅舅六年前也是脑溢血去世的，他生前对我很好。正月十七去世的，正月拜年还见过的，没想到会是最后一次。在我舅舅的坟前，我问纤雪认识外公吗，她说不记得了。我给了她点零花钱让她买些喜欢的东西，我问她喜欢什么，她说喜欢钱。我说你要这么多钱干什么，她说要给她妈妈买件新衣服，还让我不要生气。 在那几个小时里，我不停地和她说，近乎单方面的要求：你要好好上课，将来上大学哦。我知道我对她的人生做不了什么，对她说的这些话，与其说是对她的劝诫，更不如说是一种良心上的自我安慰。 （四） 其实在城市的生活又何异于孤魂野鬼。拥挤的、昏暗的出租屋，夏天充满异味的地铁、公交，写字楼里的格子间，伤心的街道，人来人往的娱乐场，失落人的渺小内心。这一切的一切和坟墓有多大的分别。人是城市的燃料，这台巨大的工业机器制造出绚丽的幻象，从此有了永恒的动力，而燃烧一个人的时间不过是永恒里的须臾，变成废料排出体外几乎是绝大部分的人归宿，被集体撒向旷野、江河和土坡，滋养出下一批全新的燃料。曾经熊熊燃烧过的我，最终也将步向我的命定，如果可以的话，请把我撒向大海，成为大海，化作比城市更深刻的永恒，有蚀刻一切的气势。而不是给我一块墓碑，证明我曾卑微地存在。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Thoughts","slug":"Thoughts","permalink":"https://blog.210222.xyz/tags/Thoughts/"}]},{"title":"搬家","slug":"2019-06-01-搬家","date":"2019-06-23T09:43:00.000Z","updated":"2025-02-09T16:40:37.846Z","comments":true,"path":"posts/leave.html","permalink":"https://blog.210222.xyz/posts/leave","excerpt":"","text":"本月初的时候，搬了家。在货拉拉上叫了一辆中型面包车，最后只装了不到一半，这半车东西就是我在广州生存的所有倚靠了。坐在副驾驶上，和司机聊起在大城市生活的难处，感觉自己就像城市里的游牧民。 新的住处在东山附近，没有天河那么现代，但是也没有那么喧闹。因为附近多是学校和政府机关，所以年轻人相对会少一点。我住的小区是一个90年代建的旧小区，和两个朋友一起合租了一个三室一厅，房子还算宽敞。9层楼梯房，我们住在7楼，对外宣称的说法是可以锻炼身体，其实主要是因为房租比较便宜。 楼下的王阿姨是整个小区的管理员，养了只橘猫，刚生了五只小橘猫，刚搬来的时候还没睁开眼，最近已经开始满院子乱跑了。丰巢旁边不知是谁家养的两只鹦鹉，第一次去拿快递的时候，阴影里传来的“你好”把我吓得不轻。几乎每家每户的阳台上都种满了绿植，特别茂密，像一片片小森林。周围的其他邻居主要是退休的大爷大妈和带小孩的父母，也只是在楼梯上有过几面之缘，并没有什么邻里情可言。 现在每个周六早晨都会和室友骑个自行车去五羊邨的茶楼喝茶，混在周围一众广州本地的大爷大妈中，过一种假装的退休生活。泡一壶普洱，点几件点心，胡乱聊两个小时，赶在十一点半之前买单，就可以享受全场点心九块九的折扣，然后以这样一种安逸的心态开始一个周末。不过最近这家茶楼装修了，只能去附近价格更贵的连锁店了。 附近有家永旺，我常去逛，永旺真的特别好，什么食材都处理好现成的，对我这种刚开始研究怎么做菜，又不想花太多时间的人真的是很友好，已经坚持两周都没叫过外卖了，对我来说是一种小小的进步。不过我的厨艺还是有待长进，希望能慢慢做点像样的菜。 另外还有一些比较开心的小事：给客厅的老电视买了个斐讯T1，可以躺沙发上看会电影；去了几次宜家，买了些好看但是并不那么实用的家具；买了个音箱，下班就整个人埋进床里，随播放些播客或者音乐，然后整个人开始放空；买了些啤酒和伏特加放冰箱里，低成本地缓解工作日的郁闷。这么看来，目前感到快乐的基本方式还是消费，拥有一些会感到开心的东西。不过不知道这种快乐是不是持久。","categories":[{"name":"经验","slug":"经验","permalink":"https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"}],"tags":[]}]}