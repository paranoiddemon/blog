<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LANDFILL</title>
  
  
  <link href="https://blog.210222.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.210222.xyz/"/>
  <updated>2025-02-09T16:40:37.848Z</updated>
  <id>https://blog.210222.xyz/</id>
  
  <author>
    <name>exit.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Feburary 2025</title>
    <link href="https://blog.210222.xyz/posts/2025-spring-festival"/>
    <id>https://blog.210222.xyz/posts/2025-spring-festival</id>
    <published>2025-02-08T15:52:12.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个散光患者，我基本避开夜间开车。但今天路上堵车就拖到晚上了。各色灯光闪的我头晕目眩。开车的时候就在想象我出车祸死了的场景，其实也没什么遗憾，没有什么一定要活下去的理由，只是依着惯性活着。唯一的担心就是我爸妈会很痛苦，我还在想之后得把各个账户的钱放一个银行卡上，他们知道我的密码。</p><p>过年回去听了很多悲惨的生活。我爸的一个朋友，母亲老年痴呆屎尿失禁需要人照顾，老婆癌症，公司破产了，还有三个小孩在念书；我妈的亲戚的亲戚，一年内死了女婿和孙子。我表姐的儿子自闭症，为了多赚钱打两份工。et cetera，et cetera。各种普遍的痛苦和残酷。根本就没有上帝。对比起来我的不开心好像不值一提。有时候也不知道是不是我忍受痛苦的阈值太低了。</p><p>联想到最近看的罪与罚，拉斯柯尔尼科夫去找索尼亚，面对她的境遇也产生了这样的疑问:『既然她不能投河自尽，那她怎么能久久地处在这种地位而不发疯呢？』 </p><p>上海今天是这个冬季最冷的一天。一回到小区我就感到很抑郁。因为我知道我又要面对我可悲的生活。我前几天心情挺好的，但一回来，吹着冷风，我又不可避免的变悲观。我好像拥有很多，又什么都没有。突然好想回我家的小县城，我曾经觉得那是个破地方。</p><p>假期结束了，又要开始打工了，我从两天前就开始对这件事感到焦虑，大脑不自控的不能平静，平静太奢侈了。回家躺着的两周，我感觉有个大电视还是很好的。但是我租的房子压根没有地方放，但我还是急切的想要一个大电视，或许生活就会好起来。Just get a fucking big television.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一个散光患者，我基本避开夜间开车。但今天路上堵车就拖到晚上了。各色灯光闪的我头晕目眩。开车的时候就在想象我出车祸死了的场景，其实也没什么遗憾，没有什么一定要活下去的理由，只是依着惯性活着。唯一的担心就是我爸妈会很痛苦，我还在想之后得把各个账户的钱放一个银行卡上，他们知道</summary>
      
    
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/categories/Thoughts/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>Emby HW Acceleration on N100 PVE LXC</title>
    <link href="https://blog.210222.xyz/posts/emby-hw-acc"/>
    <id>https://blog.210222.xyz/posts/emby-hw-acc</id>
    <published>2025-01-11T02:52:12.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<p>Reference</p><ul><li><a href="https://emby.media/community/index.php?/topic/126031-hardware-acceleration-with-lxc-on-proxmox-server/">Hardware Acceleration with LXC on Proxmox Server - Linux - Emby Community</a></li><li><a href="https://forum.proxmox.com/threads/intel-n100-igpu-passthrough-to-vm-and-use-with-docker.140370/">Intel N100/iGPU Passthrough to VM and use with Docker | Proxmox Support Forum</a></li></ul><h3 id="On-PVE-host"><a href="#On-PVE-host" class="headerlink" title="On PVE host"></a>On PVE host</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lspci -k</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line">00:02.0 VGA compatible controller: Intel Corporation Alder Lake-N [UHD Graphics]</span><br><span class="line">DeviceName: Onboard - Video</span><br><span class="line">Subsystem: Intel Corporation Alder Lake-N [UHD Graphics]</span><br><span class="line">Kernel driver <span class="keyword">in</span> use: i915</span><br><span class="line">Kernel modules: i915</span><br><span class="line">…</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /dev/dri</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 80 Feb 5 01:16 by-path</span><br><span class="line">crw-rw---- 1 root video 226, 0 Feb 5 01:16 card0</span><br><span class="line">crw-rw---- 1 root render 226, 128 Feb 5 01:16 renderD128</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><ul><li><strong>/dev/dri/cardX</strong><ul><li>每个 <code>cardX</code>（如 <code>card0</code>, <code>card1</code>）表示系统中的一个显卡设备。</li><li>这是应用程序与显卡交互的主要入口。</li></ul></li><li><strong>/dev/dri/renderDXXX</strong><ul><li><code>renderDXXX</code>（如 <code>renderD128</code>, <code>renderD129</code>）是专门为现代应用程序设计的设备节点，主要用于无显示输出的计算任务，例如 GPU 加速的计算、OpenCL 或 Vulkan 等。</li><li>它们与显示器无关，仅用于离屏渲染任务。</li></ul></li><li><strong>/dev/dri/controlDXX</strong><ul><li><code>controlDXX</code> 设备节点通常用于 DRM（Direct Rendering Manager）控制接口，主要供图形服务器（如 Xorg 或 Wayland）使用。</li></ul></li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pve/lxc/101.conf <span class="comment"># add following config to your lxc</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lxc.cgroup2.devices.allow: c 226:0 rwm # 226是显卡设备</span><br><span class="line">lxc.cgroup2.devices.allow: c 226:128 rwm # 次设备号 `128` 通常对应某些特定的 GPU 子设备或驱动（例如渲染设备 `/dev/dri/renderD128`)</span><br><span class="line">lxc.cgroup2.devices.allow: c 29:0 rwm # Framebuffer</span><br><span class="line">lxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dir</span><br><span class="line">lxc.mount.entry: /dev/fb0 dev/fb0 none bind,optional,create=file</span><br></pre></td></tr></table></figure><blockquote><p>[!NOTE]</p><ul><li><strong><code>lxc.cgroup2.devices.allow: c 226:0 rwm</code></strong> - 允许容器访问主机的 GPU 控制设备。</li><li><strong><code>lxc.cgroup2.devices.allow: c 226:128 rwm</code></strong> - 允许容器访问主机的 GPU 渲染设备。</li><li><strong><code>lxc.cgroup2.devices.allow: c 29:0 rwm</code></strong> - 允许容器访问主机的帧缓冲设备。</li><li><strong><code>lxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dir</code></strong> - 挂载主机的 GPU 目录 <code>/dev/dri</code> 到容器。</li><li><strong><code>lxc.mount.entry: /dev/fb0 dev/fb0 none bind,optional,create=file</code></strong> - 挂载主机的帧缓冲设备 <code>/dev/fb0</code> 到容器。</li></ul></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 777 /dev/dri/* <span class="comment"># 所有用户 读写执行权限 </span></span><br></pre></td></tr></table></figure><h3 id="On-LXC"><a href="#On-LXC" class="headerlink" title="On LXC"></a>On LXC</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> usermod -aG video replica  <span class="comment"># add user to group</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG input replica</span><br><span class="line"><span class="built_in">sudo</span> usermod -aG render replica</span><br><span class="line"></span><br><span class="line"><span class="comment"># run emby docker and pass device</span></span><br><span class="line">docker run -d --name=emby --restart=always \</span><br><span class="line">    -v /home/replica/emby/config:/config \</span><br><span class="line">-v /mnt/usb:/mnt/usb \</span><br><span class="line">-v /mnt/sata:/mnt/sata \</span><br><span class="line">-p 8096:8096 -p 8920:8920 \</span><br><span class="line">-e UID=1000 -e GID=100 -e GIDLIST=100 \</span><br><span class="line">--device /dev/dri:/dev/dri \ <span class="comment"># passthrough to docker</span></span><br><span class="line">xinjiawei1/emby_unlockd:stable</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Reference&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://emby.media/community/index.php?/topic/126031-hardware-acceleration-with-lxc-on-proxmox-server/&quot;&gt;H</summary>
      
    
    
    
    <category term="tech" scheme="https://blog.210222.xyz/categories/tech/"/>
    
    
    <category term="homeserver" scheme="https://blog.210222.xyz/tags/homeserver/"/>
    
  </entry>
  
  <entry>
    <title>November 2024</title>
    <link href="https://blog.210222.xyz/posts/november-2024"/>
    <id>https://blog.210222.xyz/posts/november-2024</id>
    <published>2024-11-26T15:57:23.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<hr><p>周末整理了下散落在各种设备&amp;云存储中的照片，意外地发现百度网盘上竟然备份了早年的照片，为我挽回了一些记忆的碎片。我在2024年以100KB/s的带宽，历时近20个小时，终于取回了我的数据。</p><p>我以前一直很鄙夷照片，主张感受当下，拥有好的此刻而不是好的照片。不过现在想法改变了，我发现如果没有照片来保留某些时刻，人的大脑就像缝隙过大的筛子，大部分的细节都如同残渣被过滤掉了。照片能帮助我们抵抗遗忘。</p><hr><p>看完了「非自然死亡」。剧中的法医解剖人和切猪肉差不多。想来也是，人切开来剥皮后都是一团肉，没有比盒马的一盒猪肉高级，人类引以为傲的自我意识也逃离不了身体的消亡。</p><hr><p>看到一些人类中心主义者怒斥流浪猫破坏生态，应该被捕杀。感觉很荒谬。人类作为地球生态的最大破坏者，都还恬不知耻的活在地球上。</p><p>如果人类比其他物种高级，那么有些人类是不是也比另外另外一些人类高级？<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><hr><p>给自己找了很多事情做来填充时间的空白。整理照片，看网络小说，折腾NAS。每天都能忙到半夜，不给大脑留出空暇。</p><hr><p>References:</p><blockquote id="fn_1"><sup>1</sup>. <a href="https://www.youtube.com/watch?v=mqT82oGeax0">“The Superior Human?” - YouTube</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;周末整理了下散落在各种设备&amp;amp;云存储中的照片，意外地发现百度网盘上竟然备份了早年的照片，为我挽回了一些记忆的碎片。我在2024年以100KB/s的带宽，历时近20个小时，终于取回了我的数据。&lt;/p&gt;
&lt;p&gt;我以前一直很鄙夷照片，主张感受当下，拥有好的此刻而不</summary>
      
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>Return to RSS</title>
    <link href="https://blog.210222.xyz/posts/return-to-rss"/>
    <id>https://blog.210222.xyz/posts/return-to-rss</id>
    <published>2022-12-27T09:44:00.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<p>Currently, I have my information sources scattered across different platforms, including newsletters, Telegram channels, Twitter, blogs, and webpages saved in Pocket. </p><p>I used to use Inoreader as an RSS client to subscribe to my RSS sources, but the free plan had many limitations and was also blocked by the China Great Firewall. Therefore, I decided to choose a self-hosted RSS reader. </p><p>The main options included Miniflux, FreshRSS, and Tiny Tiny RSS. I ultimately chose Miniflux because it is lightweight and has all the features I need.</p><h2 id="Install-docker-compose-plugin"><a href="#Install-docker-compose-plugin" class="headerlink" title="Install docker compose plugin"></a>Install docker compose plugin</h2><p><a href="https://docs.docker.com/compose/install/linux/#install-using-the-repository">Install the Compose plugin | Docker Documentation</a><br>If you already have Docker Engine and Docker CLI installed, you can install the Compose plugin from the command line<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-compose-plugin</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure></p><h2 id="Create-docker-compose-yml"><a href="#Create-docker-compose-yml" class="headerlink" title="Create  docker-compose.yml"></a>Create  docker-compose.yml</h2><p><a href="https://miniflux.app/docs/installation.html">Installation Instructions</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir miniflux</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure></p><p> <a href="https://github.com/miniflux/v2/blob/main/contrib/docker-compose/basic.yml">v2/basic.yml at main · miniflux/v2 · GitHub</a><br>Edit your config: port , username, password etc.</p><blockquote><p>When using Docker Compose, it is important to remember not to include the <script type="math/tex">` symbol in your password. If you do need to use `</script> in your password, you will need to escape it using a backslash, like this: <code>\$</code>. This is because <code>$VARIABLE</code> and <code>$&#123;VARIABLE&#125;</code> are used for variable substitution in <code>docker-compose.yml</code>. I learned this the hard way when I used a password generated by Bitwarden and didn’t realize it contained a dollar sign. It took me a while to figure out the issue.”</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">miniflux:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;MINIFLUX_IMAGE:-miniflux/miniflux:latest&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">miniflux</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:8080&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DATABASE_URL=postgres://miniflux:secret@db/miniflux?sslmode=disable</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RUN_MIGRATIONS=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CREATE_ADMIN=1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_USERNAME=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_PASSWORD=test123</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEBUG=1</span></span><br><span class="line">    <span class="comment"># Optional health check:</span></span><br><span class="line">    <span class="comment"># healthcheck:</span></span><br><span class="line">    <span class="comment">#  test: [&quot;CMD&quot;, &quot;/usr/bin/miniflux&quot;, &quot;-healthcheck&quot;, &quot;auto&quot;]</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:15</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_USER=miniflux</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=secret</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">miniflux-db:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;pg_isready&quot;</span>, <span class="string">&quot;-U&quot;</span>, <span class="string">&quot;miniflux&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">30s</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">miniflux-db:</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/commandline/compose_up/">docker compose up | Docker Documentation</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">first start the db.  -d means detached, run <span class="keyword">in</span> the background</span></span><br><span class="line">docker compose up -d db  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and <span class="keyword">then</span> the application.</span></span><br><span class="line">docker compose up -d miniflux</span><br></pre></td></tr></table></figure></p><h2 id="Reverse-Proxy-with-Caddy"><a href="#Reverse-Proxy-with-Caddy" class="headerlink" title="Reverse Proxy with Caddy"></a>Reverse Proxy with Caddy</h2><p>Add CNAME record in the DNS for your domain.<br>Edit Caddyfile and restart caddy service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/caddy/Caddyfile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rss.your.domain </span><br><span class="line">&#123;</span><br><span class="line">    reverse_proxy localhost:port</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Useful-tools-to-work-with-RSS"><a href="#Useful-tools-to-work-with-RSS" class="headerlink" title="Useful tools to work with RSS"></a>Useful tools to work with RSS</h2><ul><li>Convert newsletter to RSS:  <a href="https://kill-the-newsletter.com/">Kill the Newsletter!</a></li><li>Pocket RSS:  <code>https://getpocket.com/users/[username]/feed/all</code>, subscribe with username and password</li><li>RSSHub: <a href="https://github.com/DIYgod/RSSHub">RSSHub</a> is a RSS feed generator to make everything RSSible.</li><li>iOS client: <a href="https://apps.apple.com/us/app/unread-an-rss-reader/id1363637349">Unread</a> is a very beautiful RSS reader for iOS that supports the Fever API</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Currently, I have my information sources scattered across different platforms, including newsletters, Telegram channels, Twitter, blogs, </summary>
      
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="Programming" scheme="https://blog.210222.xyz/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Deploy Code Server on Ubuntu</title>
    <link href="https://blog.210222.xyz/posts/deploy-code-server"/>
    <id>https://blog.210222.xyz/posts/deploy-code-server</id>
    <published>2022-12-14T13:44:00.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/coder/code-server">https://github.com/coder/code-server</a></p><h2 id="1-Intall"><a href="#1-Intall" class="headerlink" title="1. Intall"></a>1. Intall</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install script</span></span><br><span class="line">curl -fsSL https://code-server.dev/install.sh | sh</span><br><span class="line">sudo systemctl enable --now code-server@$USER</span><br></pre></td></tr></table></figure><h2 id="2-Configure"><a href="#2-Configure" class="headerlink" title="2. Configure"></a>2. Configure</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  ~/.config/code-server/config.yaml</span><br></pre></td></tr></table></figure><p>Set <code>0.0.0.0</code> to allow any IP to visit.<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bind-addr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">auth:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">cert:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart code-server@$USER</span><br></pre></td></tr></table></figure><h2 id="3-Reverse-Proxy-with-Caddy"><a href="#3-Reverse-Proxy-with-Caddy" class="headerlink" title="3. Reverse Proxy with Caddy"></a>3. Reverse Proxy with Caddy</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install</span></span><br><span class="line">sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https</span><br><span class="line">curl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#x27; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg</span><br><span class="line">curl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#x27; | sudo tee /etc/apt/sources.list.d/caddy-stable.list</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install caddy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Config</span></span><br><span class="line">vim /etc/caddy/Caddyfile</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code.your.domain</span><br><span class="line">&#123;</span><br><span class="line">    reverse_proxy localhost:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run Caddy as service</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://github.com/caddyserver/dist/blob/master/init/caddy.service</span></span><br><span class="line">vim /etc/systemd/system/caddy.service</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># caddy.service</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For using Caddy with a config file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make sure the ExecStart and ExecReload commands are correct</span></span><br><span class="line"><span class="comment"># for your installation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See https://caddyserver.com/docs/install for instructions.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: This service does not use the --resume flag, so if you</span></span><br><span class="line"><span class="comment"># use the API to make changes, they will be overwritten by the</span></span><br><span class="line"><span class="comment"># Caddyfile next time the service is restarted. If you intend to</span></span><br><span class="line"><span class="comment"># use Caddy&#x27;s API to configure it, add the --resume flag to the</span></span><br><span class="line"><span class="comment"># `caddy run` command or use the caddy-api.service file instead.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=<span class="string">Caddy</span></span><br><span class="line"><span class="attr">Documentation</span>=<span class="string">https://caddyserver.com/docs/</span></span><br><span class="line"><span class="attr">After</span>=<span class="string">network.target network-online.target</span></span><br><span class="line"><span class="attr">Requires</span>=<span class="string">network-online.target</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=<span class="string">notify</span></span><br><span class="line"><span class="attr">User</span>=<span class="string">caddy</span></span><br><span class="line"><span class="attr">Group</span>=<span class="string">caddy</span></span><br><span class="line"><span class="attr">ExecStart</span>=<span class="string">/usr/bin/caddy run --environ --config /etc/caddy/Caddyfile</span></span><br><span class="line"><span class="attr">ExecReload</span>=<span class="string">/usr/bin/caddy reload --config /etc/caddy/Caddyfile --force</span></span><br><span class="line"><span class="attr">TimeoutStopSec</span>=<span class="string">5s</span></span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="string">1048576</span></span><br><span class="line"><span class="attr">LimitNPROC</span>=<span class="string">512</span></span><br><span class="line"><span class="attr">PrivateDevices</span>=<span class="string">yes</span></span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">ProtectSystem</span>=<span class="string">full</span></span><br><span class="line"><span class="attr">AmbientCapabilities</span>=<span class="string">CAP_NET_BIND_SERVICE</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=<span class="string">multi-user.target</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable --now caddy</span><br><span class="line">systemctl status caddy</span><br></pre></td></tr></table></figure><h2 id="4-Set-subdomain-DNS"><a href="#4-Set-subdomain-DNS" class="headerlink" title="4. Set subdomain DNS"></a>4. Set subdomain DNS</h2><p>Add CNAME record in DNS </p><p>Name: code<br>value: your.domain</p><p>It’s all set now. Visit code.your.domain and test.<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/20221214222400.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/coder/code-server&quot;&gt;https://github.com/coder/code-server&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Intall&quot;&gt;&lt;a href=&quot;#1-Intall&quot; class=&quot;</summary>
      
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="Programming" scheme="https://blog.210222.xyz/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 301</title>
    <link href="https://blog.210222.xyz/posts/LC-weekly-contest-301"/>
    <id>https://blog.210222.xyz/posts/LC-weekly-contest-301</id>
    <published>2022-07-11T06:44:00.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p><a href="https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/">6112. 装满杯子需要的最短总时长 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202207111419296.png" alt=""></p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fillCups</span><span class="params">(<span class="type">int</span>[] amount)</span> &#123;</span><br><span class="line">        Arrays.sort(amount);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> amount[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> amount[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        res += min;</span><br><span class="line">        <span class="comment">// 先把max 减到和mid一样</span></span><br><span class="line">        <span class="keyword">while</span>(min &gt;<span class="number">0</span> &amp;&amp; max &gt; mid)&#123;</span><br><span class="line">            max--;</span><br><span class="line">            min--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后再同时减</span></span><br><span class="line">        max -= min/<span class="number">2</span>;</span><br><span class="line">        mid -= (min + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        res += Math.max(max, mid);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>从最大的两个数开始减少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fillCups</span><span class="params">(<span class="type">int</span>[] amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 每次都排序。从最大的两个数开始减。如果中间的数都为0。再加上残余的最大值。</span></span><br><span class="line">            Arrays.sort(amount);</span><br><span class="line">            <span class="keyword">if</span> (amount[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            amount[<span class="number">2</span>]--;</span><br><span class="line">            amount[<span class="number">1</span>]--;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + amount[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>如果 最大值 大于另外两个和。返回最大值<br>如果 最大值小于另外两个和。<br>a &gt;= b &gt;= c<br>当 a &lt;= b +c的时候，每次必然可以拿两个数。<br>当a - 1, b-1, c  最大值仍然为a时， 还是满足a &lt;= b +c这个性质。每次都可以从两边拿<br>当最大值变为c的时候，c同样可以和a一样操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fillCups</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">2</span>] &gt;= a[<span class="number">0</span>] + a[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] + <span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p><a href="https://leetcode.cn/problems/smallest-number-in-infinite-set/">6113. 无限集中的最小数字 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202207111442344.png" alt=""></p><h3 id="提交-1"><a href="#提交-1" class="headerlink" title="提交"></a>提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallestInfiniteSet</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallestInfiniteSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            s[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                res = s[i];</span><br><span class="line">                s[i] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBack</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[num-<span class="number">1</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">            s[num - <span class="number">1</span>] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SmallestInfiniteSet obj = new SmallestInfiniteSet();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.popSmallest();</span></span><br><span class="line"><span class="comment"> * obj.addBack(num);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>使用set存被删除的数。无限集如果数据量大的话，就过不了了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallestInfiniteSet</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallestInfiniteSet</span><span class="params">()</span> &#123;</span><br><span class="line">        set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popSmallest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(set.contains(res))&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBack</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(num)) set.remove(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p><a href="https://leetcode.cn/problems/move-pieces-to-obtain-a-string/">6114. 移动片段得到字符串 - 力扣（LeetCode）</a><br>同 <a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202207111442051.png" alt=""></p><h3 id="提交-2"><a href="#提交-2" class="headerlink" title="提交"></a>提交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canChange</span><span class="params">(String start, String target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> start.length();</span><br><span class="line">        <span class="comment">// L不能超过L的原始位置。只能往左。R也是同理。</span></span><br><span class="line">        <span class="keyword">if</span>(!start.replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).equals(target.replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(i) == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (target.charAt(t) != <span class="string">&#x27;L&#x27;</span>) t++;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; t++) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(i) == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果i 不大于t t移动到下一个位置。继续寻找下一个L R</span></span><br><span class="line">                <span class="keyword">while</span> (target.charAt(t) != <span class="string">&#x27;R&#x27;</span>) t++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; t++) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canChange</span><span class="params">(string start, string target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = start.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; n;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; start[i] == <span class="string">&#x27;_&#x27;</span>)i++;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; target[j] == <span class="string">&#x27;_&#x27;</span>)j++;</span><br><span class="line">            <span class="comment">// 如果分别为L R 显然相对位置不同。返回false</span></span><br><span class="line">            <span class="keyword">if</span>(start[i] != target[j])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// target的L要在更左。R要在更右。</span></span><br><span class="line">            <span class="keyword">if</span>(start[i] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; j &lt; i)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(start[i] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; j &gt; i)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h2><p><a href="https://leetcode.cn/problems/count-the-number-of-ideal-arrays/">6115. 统计理想数组的数目 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202207111443310.png" alt=""></p><h3 id="组合数-DP"><a href="#组合数-DP" class="headerlink" title="组合数 DP"></a>组合数 DP</h3><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202207111129824.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202207111132010.png" alt=""></p><p>n是数组的长度，t是不同元素的个数。<br>如果可以相同，就是计算组合数从n -1个位置里 选出t-1个位置。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXP = <span class="number">16</span>; <span class="comment">// 2^16 &gt; 10000, n &lt;= 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">idealArrays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nlnn 求因数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fac</span>(K + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) </span><br><span class="line">            <span class="comment">// 求的是j的因数的数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt;= K; j += i) </span><br><span class="line">            fac[j].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算子问题的答案</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; f;        </span><br><span class="line">        f.<span class="built_in">resize</span>(K + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">20</span>));</span><br><span class="line">        <span class="comment">// i的最大值为K</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">            <span class="comment">// 以1为结尾只有一种方案</span></span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= MAXP; j++) </span><br><span class="line">            <span class="comment">// t是i的因数。加上子问题的方案书。以因数为结尾。长度减去1的情况</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> t : fac[i]) </span><br><span class="line">                f[i][j] = (f[i][j] + f[t][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求组合数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; C;</span><br><span class="line">        C.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">20</span>));</span><br><span class="line">        C[<span class="number">0</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">0</span>] = C[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= MAXP; j++) </span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计最终答案</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXP; j++) </span><br><span class="line">        <span class="comment">// 以i为最后一个元素。且数组长度为j的数量。组合数-&gt; 计算出元素重复使用的情况</span></span><br><span class="line">            ans = (ans + C[n - <span class="number">1</span>][j - <span class="number">1</span>] * f[i][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        ans = (ans + f[n - <span class="number">1</span>][cnt - <span class="number">1</span>]) % MOD;</span><br><span class="line">        <span class="comment">// 数组长度小于n</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 从起点开始 乘以所有的质因数，小于最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * u &lt;= m; i ++ )</span><br><span class="line">                <span class="built_in">dfs</span>(i * u, cnt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">idealArrays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n, <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        f = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span> &amp;&amp; j &lt;= i; j ++ )</span><br><span class="line">                <span class="comment">// j为0</span></span><br><span class="line">                <span class="keyword">if</span> (!j) f[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 组合数</span></span><br><span class="line">                <span class="keyword">else</span> f[i][j] = (f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">            <span class="comment">// 从1开始搜索 到最大值为止。</span></span><br><span class="line">            <span class="built_in">dfs</span>(i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q1&quot;&gt;&lt;a href=&quot;#Q1&quot; class=&quot;headerlink&quot; title=&quot;Q1&quot;&gt;&lt;/a&gt;Q1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-amount-of-time-to-fill-c</summary>
      
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="Programming" scheme="https://blog.210222.xyz/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Golang Notes</title>
    <link href="https://blog.210222.xyz/posts/go-basic"/>
    <id>https://blog.210222.xyz/posts/go-basic</id>
    <published>2022-06-16T04:00:00.000Z</published>
    <updated>2025-02-09T16:40:37.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-ref"><a href="#0-ref" class="headerlink" title="0. ref"></a>0. ref</h1><p><a href="https://tour.go-zh.org/concurrency/11">Go 语言之旅</a></p><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md">Go web develop</a></p><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Go/new_gopher_tips.md">Halfrost-Field/new_gopher_tips.md at master · halfrost/Halfrost-Field</a></p><p><a href="https://www.topgoer.com/">topgoer · Go语言中文文档</a></p><p><a href="https://geektutu.com/post/hpg-sync-cond.html">Go sync.Cond | Go 语言高性能编程 | 极客兔兔</a></p><p><a href="https://learnku.com/docs/the-way-to-go">《Go 入门指南》 | Go 技术论坛</a></p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>诞生</p><p>类C</p><h1 id="2-Go安装"><a href="#2-Go安装" class="headerlink" title="2. Go安装"></a>2. Go安装</h1><p>windows</p><p>linux</p><h1 id="3-IDE及工具"><a href="#3-IDE及工具" class="headerlink" title="3. IDE及工具"></a>3. IDE及工具</h1><p>Goland From Jetbrains<br>VScode</p><h1 id="4-包，变量和函数"><a href="#4-包，变量和函数" class="headerlink" title="4. 包，变量和函数"></a>4. 包，变量和函数</h1><p>Go语言的基本类型有：</p><ul><li>bool</li><li>string</li><li>int、int8、int16、int32、int64</li><li>uint、uint8、uint16、uint32、uint64、uintptr</li><li>byte // uint8 的别名</li><li>rune // int32 的别名 代表一个 Unicode 码</li><li>float32、float64</li><li>complex64、complex128</li></ul><p>当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。</p><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span> <span class="comment">// 多导入</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Now you have %g problems.\n&quot;</span>, math.Sqrt(<span class="number">7</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>导出名<br>在 Go 中，如果<strong>一个名字以大写字母开头</strong>，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。</p><p>pizza 和 pi 并未以大写字母开头，所以它们是未导出的。<br>在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//fmt.Println(math.pi) // undefined: math.pi</span></span><br><span class="line">fmt.Println(math.Pi)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常量、变量"><a href="#常量、变量" class="headerlink" title="常量、变量"></a>常量、变量</h2><p>:= 初始化赋值</p><p>var 关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 变量名 变量类型</span></span><br><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="comment">// 单个声明</span></span><br><span class="line">   <span class="keyword">var</span> a, b *<span class="type">int</span>  </span><br><span class="line">   fmt.Println(a, b)  </span><br><span class="line">   c := <span class="number">10</span>  </span><br><span class="line">   b = &amp;c  </span><br><span class="line">   fmt.Println(b)  <span class="comment">//0xc00000a0e0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量声明</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    c []<span class="type">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span></span><br><span class="line">    e <span class="keyword">struct</span> &#123;</span><br><span class="line">            x <span class="type">int</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 简化。名字 := 表达式</span></span><br><span class="line">     a:= <span class="number">1</span></span><br><span class="line">     b:= <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p><p>常量可以是字符、字符串、布尔值或数值。</p><p>常量不能用 <code>:=</code> 语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>true false</p><p>== != &amp;&amp; || !</p><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/image-20210720231630540.png" alt="image-20210720231630540"></p><p>float32的精度是小数点后七位  有效数字为2^23次方 只有七位数</p><p>float64是小数点后15位</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">表达式 T(v) 将值 v 转换为类型 T。</span><br><span class="line"></span><br><span class="line">一些关于数值的转换：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = <span class="type">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br><span class="line">或者，更加简单的形式：</span><br><span class="line"></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="type">float64</span>(i)</span><br><span class="line">u := <span class="type">uint</span>(f)</span><br></pre></td></tr></table></figure><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p><p>当右值声明了类型时，新变量的类型与其相同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">j := i <span class="comment">// j 也是一个 int</span></span><br></pre></td></tr></table></figure><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>           <span class="comment">// int</span></span><br><span class="line">f := <span class="number">3.142</span>        <span class="comment">// float64</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/yinzhengjie/p/7680829.html">golang格式化输出-fmt包用法详解</a></p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64 (32 位实数和虚数) complex128 (64 位实数和虚数)</p><p>byte</p><p>Go提供了两种大小的复数类型：complex64和complex128，分别由float32和float64组成。内置函数complex从指定的实部和虚部构建复数，内置函数real和imag用来获取复数的实部和虚部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y)                 <span class="comment">// &quot;(-5+10i)&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y))           <span class="comment">// &quot;-5&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y))           <span class="comment">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>%s</p><p>strings 和 strcov包</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><code>*p</code>  取出地址中的值</p><p><code>&amp;a</code> 获得指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;a1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//var p *string</span></span><br><span class="line"><span class="comment">//p = &amp;a</span></span><br><span class="line">p := &amp;a</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, *p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p&quot;</span>, &amp;p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0xf43c30</span></span><br><span class="line"><span class="comment">//a1</span></span><br><span class="line"><span class="comment">//0xc000006028</span></span><br></pre></td></tr></table></figure><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p>go语句结尾不需要分号</p><p>Go支持C语言风格的 <code>/* */</code>块注释，也支持C＋＋风格的 <code>//</code>行注释。 当然，行注释更通用，块注释主要用于针对包的详细说明或者屏蔽大块的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// &amp; 获取变量的内存地址</span></span><br><span class="line"><span class="comment">// * 获取指针变量的值。即内存地址是的值。</span></span><br><span class="line">k := <span class="number">1</span></span><br><span class="line">m := &amp;k</span><br><span class="line">fmt.Println(k)  <span class="comment">// 1</span></span><br><span class="line">fmt.Println(m)  <span class="comment">// 0xc0000be008  &amp;k是内存地址</span></span><br><span class="line">fmt.Println(*m) <span class="comment">// 1 *pointer是读取内存地址的值。</span></span><br><span class="line"><span class="comment">// fmt.Println(*k) 这种写法的会编译错误 Invalid Indirect *运算符不能用在字面量上。 只能指向指针变量</span></span><br><span class="line"></span><br><span class="line">*m = <span class="number">10</span></span><br><span class="line">fmt.Println(m)  <span class="comment">// 0xc00000a0a8</span></span><br><span class="line">fmt.Println(k) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line">fmt.Println(Vertex&#123;x: <span class="number">1</span>,y:<span class="number">2</span>&#125;) <span class="comment">// &#123;1, 2&#125;</span></span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">v:=Vertex&#123;<span class="number">10</span>,<span class="number">23</span>&#125;</span><br><span class="line">fmt.Println(v.x)  <span class="comment">// 10</span></span><br><span class="line">fmt.Println(v.y)  <span class="comment">// 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。</span></span><br><span class="line"><span class="comment">// 不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pointer是个指针。理论上应该(*pointer).x 但是这两种写法都是一样的。 (*pointer).x与 *pointer.x的区别。</span></span><br><span class="line">pointer := &amp;v</span><br><span class="line">fmt.Println((*pointer).x)</span><br><span class="line">fmt.Println(pointer.x)</span><br><span class="line"><span class="comment">// var关键字的作用：</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">v2 = Vertex&#123;x: <span class="number">1</span>&#125;<span class="comment">// 如果只赋值一个另一个会为初始化值</span></span><br><span class="line">v3 = Vertex&#123;&#125;</span><br><span class="line">v4 = Vertex&#123;y: <span class="number">1</span>&#125;  <span class="comment">// 如果使用了name:value就不用顺序。</span></span><br><span class="line">p = &amp;Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">// 特殊的前缀 &amp; 返回一个指向结构体的指针。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Println(v1, p , v2, v3, v4)  <span class="comment">// &#123;1 2&#125; &amp;&#123;1 2&#125; &#123;1 0&#125; &#123;0 0&#125; &#123;0 1&#125;</span></span><br><span class="line">fmt.Println(p.x) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(*p)  <span class="comment">// &#123;1 2&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Vertex type定义结构体</span></span><br><span class="line"><span class="comment"> 一个结构体（struct）就是一组字段（field）。</span></span><br><span class="line"><span class="comment">struct中的属性通过.访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="comment">// go的类型在后面。</span></span><br><span class="line">x <span class="type">int</span></span><br><span class="line">y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h2><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p><p>表达式: <code>var a [10]int</code>  会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p><p>数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">3</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a) <span class="comment">//[0 0]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [  ]</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">b[<span class="number">1</span>] = <span class="string">&quot;world=&quot;</span></span><br><span class="line">b[<span class="number">2</span>] = <span class="string">&quot;fuck&quot;</span></span><br><span class="line"><span class="comment">// 如果后面还有元素 就会跟上空格。如果是最后一个元素就不会有空格 [hello world= fuck]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [hello world ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化赋值。其实和java差不多。就是类型后置了</span></span><br><span class="line">c := [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(c) <span class="comment">// [1 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 slice</h2><p><a href="https://www.cnblogs.com/sparkdev/p/10704614.html">Golang 入门 : 切片(slice) - sparkdev - 博客园</a></p><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p><p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p><p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：<br><code>a[low : high]</code></p><p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p><p><code>a[1:4]</code>表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 前include 后exclude</span></span><br><span class="line">b := a[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">fmt.Println(b) <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">fmt.Println(c)</span><br><span class="line"><span class="keyword">var</span> d []<span class="type">int</span> = a[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment">// Type can be omitted</span></span><br><span class="line">fmt.Println(d) <span class="comment">// [1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e []<span class="type">int</span></span><br><span class="line">fmt.Println(e) <span class="comment">// [] 默认为空。和其他的类型的初始化值一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f []*<span class="type">int</span></span><br><span class="line">fmt.Println(f)  <span class="comment">// 切片会打印 []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g [<span class="number">2</span>]*<span class="type">int</span></span><br><span class="line">fmt.Println(g) <span class="comment">// 数组会打印 [&lt;nil&gt; &lt;nil&gt;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切片就像数组的引用<br>切片并不存储任何数据，它只是描述了底层数组中的一段。<br>更改切片的元素会修改其底层数组中对应的元素。<br>与它共享底层数组的切片都会观测到这些修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">names := [<span class="number">4</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;John&quot;</span>,</span><br><span class="line"><span class="string">&quot;Paul&quot;</span>,</span><br><span class="line"><span class="string">&quot;George&quot;</span>,</span><br><span class="line"><span class="string">&quot;Ringo&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(names)</span><br><span class="line"></span><br><span class="line">a := names[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">b := names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;XXX&quot;</span> <span class="comment">// 切片的b[0] 在数组中是索引1位置</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">fmt.Println(names)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**[John Paul George Ringo]</span></span><br><span class="line"><span class="comment">[John Paul] [Paul George]</span></span><br><span class="line"><span class="comment">[John XXX] [XXX George]</span></span><br><span class="line"><span class="comment">[John XXX George Ringo]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>切片文法<br>切片文法类似于没有长度的数组文法。<br>这是一个数组文法：<br><code>[3]bool&#123;true, true, false&#125;</code><br>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：<br><code>[]bool&#123;true, true, false&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="type">int</span></span><br><span class="line">b <span class="type">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[2 3 5 7 11 13]</span></span><br><span class="line"><span class="comment">[true false true true false true]</span></span><br><span class="line"><span class="comment">[&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切片的默认行为<br>在进行切片时，你可以利用它的默认行为来忽略上下界。<br>切片下界的默认值为 0，上界则是该切片的长度。</p><p>对于数组<br><code>var a [10]int</code><br>来说，以下切片是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">    <span class="comment">// :不能省略</span></span><br><span class="line">s = s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>切片的长度与容量</strong><br>切片拥有 长度 和 容量。</p><p>切片的长度len就是它所包含的元素个数。</p><p>切片的容量cap是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p><p>切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。<br>你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">a:= [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">b:= a[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Println(b) <span class="comment">//[2]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span> ,<span class="built_in">len</span>(b), <span class="string">&quot;cap:&quot;</span>, <span class="built_in">cap</span>(b)) <span class="comment">//len: 1 cap: 4</span></span><br><span class="line"><span class="comment">//:= 只有初始化声明的时候才使用</span></span><br><span class="line">b = a[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(b) <span class="comment">//[3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span> ,<span class="built_in">len</span>(b), <span class="string">&quot;cap:&quot;</span>, <span class="built_in">cap</span>(b)) <span class="comment">//len: 3 cap: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切片的零值是 <code>nil</code>。<br>nil 切片的长度和容量为 0 且没有底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>用 make 创建切片</strong></p><p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p><p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p><p>a := make([]int, 5)  // len(a)=5</p><p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>) </span><br><span class="line">printSlice(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// 第一个参数为len 第二个参数为cap</span></span><br><span class="line">printSlice(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">printSlice(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(<span class="string">&quot;d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="type">string</span>, x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s len=%d cap=%d %v\n&quot;</span>,</span><br><span class="line">s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a len=5 cap=5 [0 0 0 0 0]</span></span><br><span class="line"><span class="comment">b len=0 cap=5 []</span></span><br><span class="line"><span class="comment">c len=2 cap=5 [0 0]</span></span><br><span class="line"><span class="comment">d len=3 cap=3 [0 0 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>切片的切片。和二维数组差不多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个井字板（经典游戏）</span></span><br><span class="line">board := [][]<span class="type">string</span>&#123;</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个玩家轮流打上 X 和 O</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>向切片追加元素<br>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。</p><p><code>func append(s []T, vs ...T) []T</code><br>append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。<br>append 的结果是一个包含原切片所有元素加上新添加元素的切片。</p><p>当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p><p><a href="https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质 - Go 语言博客</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/tour/pic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pic() Pic是一个结构体 返回一个[][]uint8</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pic</span><span class="params">(dx, dy <span class="type">int</span>)</span></span> [][]<span class="type">uint8</span> &#123;</span><br><span class="line"><span class="comment">// 使用make 创建dy长度的外层切片。里面是[]uint8的切片</span></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="type">uint8</span>, dy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x:= <span class="keyword">range</span> a&#123;</span><br><span class="line"><span class="comment">// 使用循环赋值</span></span><br><span class="line"><span class="comment">// 初始化内层slice</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">uint8</span>, dx) <span class="comment">// 内层长度为dx</span></span><br><span class="line"><span class="keyword">for</span> y:= <span class="keyword">range</span> b&#123;</span><br><span class="line">b[y] = <span class="type">uint8</span>(x^y) <span class="comment">// 还要使用uint8进行转换。</span></span><br><span class="line">&#125;</span><br><span class="line">a[x] = b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pic.Show(Pic)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p><p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p><p>可以将下标或值赋予 <code>_</code> 来忽略它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若你只需要索引，忽略第二个变量即可。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="comment">// Printf和Println不同</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d : %d \n&quot;</span>, i, v)</span><br><span class="line"><span class="comment">/*0 : 1</span></span><br><span class="line"><span class="comment">1 : 2</span></span><br><span class="line"><span class="comment">2 : 3</span></span><br><span class="line"><span class="comment">3 : 4</span></span><br><span class="line"><span class="comment">4 : 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Redundant &#x27;_&#x27; expression。可以直接不写第二个</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;-------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 但是如果要省略第一个参数就必须要写_  第一个是索引，第二个是数组中变量的copy</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">fmt.Println(reflect.TypeOf(v)) <span class="comment">//int reflect包  反射</span></span><br><span class="line">p1 := &amp;v; <span class="comment">//0xc00000a0e0</span></span><br><span class="line">p2 := &amp;a[i]</span><br><span class="line">fmt.Println(p1)  <span class="comment">// 0xc00000a0e0</span></span><br><span class="line">fmt.Println(p2)  <span class="comment">// 0xc00000c510</span></span><br><span class="line">fmt.Println(p1 == p2) <span class="comment">// false 可以看到是元素的copy。内存地址不同。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d \n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。<br><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>]) <span class="comment">// &#123;40.68433 -74.39967&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>map的文法与结构体相似，不过必须有键名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m) <span class="comment">// map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="comment">// 可以省略Vertex</span></span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>:    &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// map[keyType]valueType</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">m1 = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m1) <span class="comment">// map[1:1]</span></span><br><span class="line"></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="comment">// 需要后面带个，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m2) <span class="comment">// map[a:1 b:2]</span></span><br><span class="line"><span class="comment">// 修改key的值</span></span><br><span class="line">m2[<span class="string">&quot;a&quot;</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(m2) <span class="comment">// map[a:3 b:2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取key值</span></span><br><span class="line">fmt.Println(m2[<span class="string">&quot;a&quot;</span>]) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除key</span></span><br><span class="line"><span class="built_in">delete</span>(m2,<span class="string">&quot;a&quot;</span>) <span class="comment">// 不返回东西</span></span><br><span class="line">fmt.Println(m2) <span class="comment">// map[b:2]</span></span><br><span class="line"></span><br><span class="line">elem, ok := m2[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">fmt.Println(elem) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(ok) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">m3:= <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="number">1</span>:<span class="string">&quot;a&quot;</span>,</span><br><span class="line"><span class="number">2</span>:<span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">elem1, ok1 := m3[<span class="number">3</span>] <span class="comment">// 如果前面声明，则elem的类型为int。Cannot assign string to elem (type int) in multiple assignment</span></span><br><span class="line">fmt.Println(elem1) <span class="comment">// 如果不存在其零值和value类型的零值一致</span></span><br><span class="line">fmt.Println(ok1) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;golang.org/x/tour/wc&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span> <span class="comment">// 不需要, 但是包名要引号 </span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func 结构体中的函数，往结构体中传入参数string。有点类似class 后面map[string]int是返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WordCount</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 初始化一个map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 获取分割后的string数组。 Fields和Split的区别</span></span><br><span class="line">strs := strings.Fields(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> strs&#123;</span><br><span class="line"><span class="comment">// if赋值和判断一起写</span></span><br><span class="line"><span class="keyword">if</span> elem, ok:= m[v]; ok &#123;</span><br><span class="line">elem++ <span class="comment">// go中++不能在左边。只能作为语句不能做为表达式</span></span><br><span class="line">m[v] = elem</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">m[v] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wc.Test(WordCount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>func Fields(s string) []string</code><br>Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning <strong>an array of substrings</strong> of s or an empty list if s contains only white space.</p><p><code>func Split(s, sep string) []string</code><br><strong>Split slices</strong> s into all substrings separated by sep and <strong>returns a slice of the substrings</strong> between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;a man a plan a canal panama&quot;</span>, <span class="string">&quot;a &quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot; xyz &quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, strings.Split(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Bernardo O&#x27;Higgins&quot;</span>))</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</span></span><br><span class="line"><span class="comment">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</span></span><br><span class="line"><span class="comment">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</span></span><br><span class="line"><span class="comment">[&quot;&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h2><p>函数可以将其他函数调用作为它的参数，只要这个被调用函数的返回值个数、返回值类型和返回值的顺序与调用函数所需求的实参是一致的，例如：</p><p>假设 f1 需要 3 个参数 <code>f1(a, b, c int)</code>，同时 f2 返回 3 个参数 <code>f2(a, b int) (int, int, int)</code>，就可以这样调用 f1：<code>f1(f2(a, b))</code>。</p><p><strong>Go不允许函数重载</strong>，Go 语言不支持这项特性的主要原因是函数重载需要进行多余的类型匹配影响性能；没有重载意味着只是一个简单的函数调度。所以你需要给不同的函数使用不同的名字，我们通常会根据函数的特征对函数进行命名</p><p><code>type binOp func(int, int) int</code>  定义函数类型<br>如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加 &amp; 符号，比如 &amp;variable）传递给函数，这就是按引用传递，比如 Function(&amp;arg1)，此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。（译者注：指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。）</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x int, y int 可以缩写为 x, y int </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数也是值。它们可以像其它值一样传递。</p><p>函数值可以用作函数的参数或返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1 是func(float64, float64) float64类型的参数。 compute 的返回值是float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(f1 <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>, x, y <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line"><span class="comment">// 调用f1, 和操作数 x y</span></span><br><span class="line"><span class="keyword">return</span> f1(x,y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// hypotenuse 斜边</span></span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算3, 4的斜边  传入的函数必须符合定义的类型 func(float64, float64) float64</span></span><br><span class="line">fmt.Println(compute(hypot, <span class="number">3</span>, <span class="number">4</span>))  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 计算2的3次方</span></span><br><span class="line">fmt.Println(compute(math.Pow, <span class="number">2</span>, <span class="number">3</span>))  <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包 closure"></a>闭包 closure</h3><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p><p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为空， 返回值为函数，func(int) int 函数传入一个int，返回阳一个int </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>闭包练习</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个“返回int的函数”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">pre1:= <span class="number">0</span></span><br><span class="line">pre2:= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">tmp:= pre1</span><br><span class="line"><span class="comment">// 可以同时赋值。</span></span><br><span class="line"><span class="comment">// 要优先计算出所有右值，然后再从左到右依次赋值 右边的计算会先进行。之后才会赋值</span></span><br><span class="line">pre1,pre2 = pre2, (pre1 + pre2)</span><br><span class="line"><span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := fibonacci()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p><p>以下是一个简单的列表，我们会在后面的章节中对它们进行逐个深入的讲解。</p><div class="table-container"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>用来分配内存，返回Type本身(只能应用于slice, map, channel)<code>&lt;br&gt;</code>用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数（详见第 4.2 节），在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real、imag</td><td>用于创建和操作复数（详见第 4.5.2.2 节）</td></tr></tbody></table></div><h2 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h2><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>位运算</p><p>算术运算符</p><p>++ —只能用于后缀</p><p>逻辑运算符</p><blockquote><p>优先级     运算符<br>7      ^ !<br>6      * / % &lt;&lt; &gt;&gt; &amp; &amp;^<br>5      + - | ^<br>4      == != &lt; &lt;= &gt;= &gt;<br>3      &lt;-<br>2      &amp;&amp;<br>1      ||</p></blockquote><h2 id="fmt-print"><a href="#fmt-print" class="headerlink" title="fmt print"></a>fmt print</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Print:   输出到控制台(不接受任何格式化，它等价于对每一个操作数都应用 %v)</span><br><span class="line">         fmt.Print(str)</span><br><span class="line">Println: 输出到控制台并换行</span><br><span class="line">         fmt.Println(tmp)</span><br><span class="line">Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量</span><br><span class="line">         fmt.Printf(&quot;%d&quot;,a)</span><br><span class="line">Sprintf：格式化并返回一个字符串而不带任何输出。</span><br><span class="line">         s := fmt.Sprintf(&quot;a %s&quot;, &quot;string&quot;) fmt.Printf(s)</span><br><span class="line">Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout。</span><br><span class="line">         fmt.Fprintf(os.Stderr, “an %s\n”, “error”)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/youngsailor/article/details/120369225">Go语言fmt.Printf使用指南（占位符总结）格式化打印 加精！！！_youngsailor的博客-CSDN博客</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%v: 以默认的方式打印变量的值（万能占位符，如果不知道变量是什么类型，用%v即可，go语言会自动为你识别）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%+d 带符号的整型</span><br><span class="line"></span><br><span class="line">%d 正号不带。负数还是会带</span><br><span class="line">%q 打印单引号</span><br><span class="line">%q 字符串带双引号，字符串中的引号带转义符</span><br></pre></td></tr></table></figure><h2 id="named-return"><a href="#named-return" class="headerlink" title="named return"></a>named return</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于在函数一开始就申明了变量x y z</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y, z <span class="type">int</span>) &#123;</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line">z = <span class="number">4</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>)) <span class="comment">// 1 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于在函数一开始就申明了变量x y。 return空的时候，就会返回声明的值</p><p>Go’s return values may be named. If so, they are treated as variables defined at the top of the function.</p><p>These names should be used to document the meaning of the return values.</p><p>A <code>return</code> statement without arguments returns the named return values. This is known as a “naked” return.</p><p>Naked return statements should be used only in short functions, as with the example shown here. They can harm readability in longer functions.</p><h1 id="5-控制结构"><a href="#5-控制结构" class="headerlink" title="5. 控制结构"></a>5. 控制结构</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// do something else  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// catch-all or default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键字 if 和 else 之后的左大括号 <code>&#123;</code> 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 <code>&#125;</code> 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</p><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value, ok := readData(); ok &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在if语句中进行初始化</p><p>使用_丢弃返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (v <span class="type">float64</span>, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123; <span class="keyword">return</span> &#125; <span class="comment">// error case</span></span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(f),<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := mySqrt(<span class="number">25.0</span>)</span><br><span class="line">    fmt.Println(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h2><p>不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fall through</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        f() <span class="comment">// 当 i == 0 时函数也会被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换if else</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i &lt; <span class="number">0</span>:</span><br><span class="line">        f1()</span><br><span class="line">    <span class="keyword">case</span> i == <span class="number">0</span>:</span><br><span class="line">        f2()</span><br><span class="line">    <span class="keyword">case</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>如果想要重复执行某些语句，Go 语言中您只有 for 结构可以使用。没有while</p><h3 id="普通for"><a href="#普通for" class="headerlink" title="普通for"></a>普通for</h3><p>和java一样 除了没有()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;This is the %d iteration\n&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类似while"><a href="#类似while" class="headerlink" title="类似while"></a>类似while</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;The variable i is now: %d\n&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>条件语句是可以被省略的，如 <code>i:=0; ; i++</code> 或 <code>for &#123; &#125;</code> 或 <code>for ;; &#123; &#125;</code>（<code>;;</code> 会在使用 gofmt 时被移除）：这些循环的本质就是无限循环。最后一个形式也可以被改写为 <code>for true &#123; &#125;</code>，但一般情况下都会直接写 <code>for &#123; &#125;</code></p><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;Go is a beautiful language!&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The length of str is: %d\n&quot;</span>, <span class="built_in">len</span>(str))</span><br><span class="line">    <span class="keyword">for</span> pos, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Character on position %d is: %c \n&quot;</span>, pos, char)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    str2 := <span class="string">&quot;Chinese: 日本語&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;The length of str2 is: %d\n&quot;</span>, <span class="built_in">len</span>(str2))</span><br><span class="line">    <span class="keyword">for</span> pos, char := <span class="keyword">range</span> str2 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;character %c starts at byte position %d\n&quot;</span>, char, pos)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(<span class="string">&quot;index int(rune) rune    char bytes&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, <span class="type">rune</span> := <span class="keyword">range</span> str2 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%-2d      %d      %U &#x27;%c&#x27; % X\n&quot;</span>, index, <span class="type">rune</span>, <span class="type">rune</span>, <span class="type">rune</span>, []<span class="type">byte</span>(<span class="type">string</span>(<span class="type">rune</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/image-20210725142005366.png" alt="image-20210725142005366"></p><h2 id="break-continue"><a href="#break-continue" class="headerlink" title="break continue"></a>break continue</h2><p>嵌套的循环体，break 只会退出最内层的循环</p><h2 id="标签-goto"><a href="#标签-goto" class="headerlink" title="标签 goto"></a>标签 goto</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">LABEL1:</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">4</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> LABEL1</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i is: %d, and j is: %d\n&quot;</span>, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i:=<span class="number">0</span></span><br><span class="line">    HERE:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> HERE</span><br></pre></td></tr></table></figure><p>goto is not encouraged</p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。<br>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">后进先出</span></span><br><span class="line"><span class="comment">counting</span></span><br><span class="line"><span class="comment">done</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="6-方法和接口"><a href="#6-方法和接口" class="headerlink" title="6. 方法和接口"></a>6. 方法和接口</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。</p><p>方法就是一类带特殊的 <strong>接收者</strong> （receiver)参数的函数。</p><p>方法的接收者在它自己的参数列表内，位于 <code>func</code> 关键字和方法名之间。</p><p>在此例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型为Vertex。变量名为v 即为方法的接收者/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当初始化任意一个Vertex，都将可以调用这个方法</span></span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v2有点像是结构体Vertex的实例</span></span><br><span class="line">v2:= Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(v2.Abs()) <span class="comment">//2.23606797749979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通的函数 <code>func  funcName(arg1, arg2 argType) (returnType)</code></p><h3 id="方法-vs-函数"><a href="#方法-vs-函数" class="headerlink" title="方法 vs 函数"></a>方法 vs 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入方法的receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通的函数。传入一个v</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以为非结构体类型声明方法。</p><p>在此例中，我们看到了一个带 <code>Abs</code> 方法的数值类型 <code>MyFloat</code>。</p><p>接收者的类型定义和方法声明必须在同一包内；不能为内建类型（因为type是其他包内定义的类型）声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.Sqrt2) <span class="comment">// Sqrt2是math包定义的常量 不是函数</span></span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针-vs-值-接收者"><a href="#指针-vs-值-接收者" class="headerlink" title="指针 vs 值 接收者"></a>指针 vs 值 接收者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale1(f <span class="type">float64</span>) &#123;</span><br><span class="line"><span class="comment">// 指针 可以直接通过.访问。 等同于 (*v).X = (*v).X* f 这么写比较麻烦。可以直接.</span></span><br><span class="line"><span class="comment">// v是指针类型  *v 就能访问值。  a是值类型。&amp;a 就能访问指针。 &amp;a是指针类型</span></span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Scale2(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v1 := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v2 := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 指针接收者的方法可以修改接收者指向的值。也就是修改v1指向的原始值</span></span><br><span class="line">v1.Scale1(<span class="number">10</span>) </span><br><span class="line"><span class="comment">// 若使用值接收者，那么 `Scale` 方法会对原始 `Vertex` 值的副本进行操作。也就是&#123;3, 4&#125;</span></span><br><span class="line">v2.Scale2(<span class="number">10</span>) </span><br><span class="line">fmt.Println(v1.Abs()) <span class="comment">// 50</span></span><br><span class="line">fmt.Println(v2.Abs()) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// Scale函数中入参是一个Vertex指针。所以必须传入一个*Vertex</span></span><br><span class="line">Scale(&amp;v, <span class="number">10</span>)</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScaleFunc</span><span class="params">(v *Vertex, f <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// Scale方法传入 值 或者 指针都可以</span></span><br><span class="line"><span class="comment">// ScaleFunc 则必须传入指针 *Vertex</span></span><br><span class="line"><span class="comment">// Go 会将语句 `v.Scale(2)` 解释为 `(&amp;v).Scale(2)`。即值类型 会被自动转成指针类型</span></span><br><span class="line">v.Scale(<span class="number">2</span>)</span><br><span class="line">ScaleFunc(&amp;v, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p := &amp;Vertex&#123;<span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">p.Scale(<span class="number">3</span>)</span><br><span class="line">ScaleFunc(p, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(v, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;值  -&gt; 指针类型</span></span><br><span class="line"><span class="comment">// *指针 -&gt; 值</span></span><br></pre></td></tr></table></figure><p>同样的事情也发生在相反的方向。</p><p>接受一个值作为参数的函数必须接受一个指定类型的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">fmt.Println(AbsFunc(v))  <span class="comment">// OK</span></span><br><span class="line">fmt.Println(AbsFunc(&amp;v)) <span class="comment">// 编译错误！</span></span><br></pre></td></tr></table></figure><p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v Vertex</span><br><span class="line">fmt.Println(v.Abs()) <span class="comment">// OK</span></span><br><span class="line">p := &amp;v</span><br><span class="line">fmt.Println(p.Abs()) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p>这种情况下，方法调用 <code>p.Abs()</code> 会被解释为 <code>(*p).Abs()</code>。 p是指针。 会自动转成值</p><p>方法二者才都可以</p><pre><code>- 接收者是值。可以传入值或者指针- 接收者是指针。可以传入值或者指针</code></pre><p>函数则必须匹配。</p><pre><code>- 声明的参数类型是值就传入值。是指针就传入指针</code></pre><p>使用指针接收者的原因有二：</p><p>首先，方法能够修改其接收者指向的值。<br>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。<br>如果接收者为值。则每次调用会复制struct</p><p>在本例中，<code>Scale</code> 和 <code>Abs</code> 接收者的类型为 <code>*Vertex</code>，即便 <code>Abs</code> 并不需要修改其接收者。</p><p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口类型</strong> 是由一组方法签名定义的集合。<br>接口类型的变量可以保存任何实现了这些方法的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 定义了一系列的方法签名。</span></span><br><span class="line"><span class="comment">// 只要实现了该方法就是实现了接口</span></span><br><span class="line">Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line"><span class="comment">// a = v // Vertex does not implement Abser (Abs method has pointer receiver)</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的receiver是 *Vertex 不是Vertex。因此Vertex不能赋值给var a Abser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">i = T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>interface value<br>类似Java中的多态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span></span> M() &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义为接口I 实际上底层是实际的类型，调用接口方法，会去调用其底层类型的方法</span></span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">describe(i) <span class="comment">// (&amp;&#123;Hello&#125;, *main.T)  i是一个T指针。类型是指针</span></span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = F(math.Pi)</span><br><span class="line">describe(i) <span class="comment">// (3.141592653589793, main.F) F是重命名的值类型</span></span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i) <span class="comment">// %v 占位符  %T打印类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>底层值为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"><span class="comment">// 如果不处理空值，会空指针。</span></span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T <span class="comment">// t是一个指针，但是并没有初始化，因此t是nil</span></span><br><span class="line">i = t</span><br><span class="line">describe(i) <span class="comment">// (&lt;nil&gt;, *main.T) 类型还是有的</span></span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接口自身为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i) <span class="comment">// (&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>指定了零个方法的接口值被称为 <strong>空接口</strong>：<br><code>interface&#123;&#125;</code></p><p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p><p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code> 可接受类型为 <code>interface&#123;&#125;</code> 的任意数量的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(&lt;nil&gt;, &lt;nil&gt;)</span></span><br><span class="line"><span class="comment">(42, int)</span></span><br><span class="line"><span class="comment">(hello, string)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p><strong>类型断言</strong> 提供了访问接口值底层具体值的方式。<br><code>t := i.(T)</code><br>该语句断言接口值 <code>i</code> 保存了具体类型 <code>T</code>，并将其底层类型为 <code>T</code> 的值赋予变量 <code>t</code>。</p><p>若 <code>i</code> 并未保存 <code>T</code> 类型的值，该语句就会触发一个恐慌。<br>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。<br><code>t, ok := i.(T)</code></p><p>若 <code>i</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。<br>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="type">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello true</span></span><br><span class="line"><span class="comment">0 false 如果不能强转，会返回类型的零值</span></span><br><span class="line"><span class="comment">panic: interface conversion: interface &#123;&#125; is string, not float64</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h3><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// v 的类型为 T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// v 的类型为 S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 没有匹配，v 与 i 的类型相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p><p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p><p>相当于type的switch case</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Twice 21 is 42</span></span><br><span class="line"><span class="comment">&quot;hello&quot; is 5 bytes long</span></span><br><span class="line"><span class="comment">I don&#x27;t know about type bool!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Stringer接口"><a href="#Stringer接口" class="headerlink" title="Stringer接口"></a>Stringer接口</h3><p><a href="https://go-zh.org/pkg/fmt/"><code>fmt</code></a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer"><code>Stringer</code></a> 是最普遍的接口之一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于重写toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arthur Dent (42 years)</span></span><br><span class="line"><span class="comment">//Zaphod Beeblebrox (9001 years)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>练习</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数组类型</span></span><br><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 给 IPAddr 添加一个 &quot;String() string&quot; 方法 注意是String() Stringer是接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipAddr IPAddr)</span></span> String() <span class="type">string</span>&#123;</span><br><span class="line"><span class="comment">// Springf返回的是字符串。而不是在控制台打印</span></span><br><span class="line"><span class="keyword">return</span>  fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, ipAddr[<span class="number">0</span>],ipAddr[<span class="number">1</span>],ipAddr[<span class="number">2</span>],ipAddr[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line"><span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line"><span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h3><p>错误处理</p><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p><p>与 <code>fmt.Stringer</code> 类似，<code>error</code> 类型是一个内建接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（与 <code>fmt.Stringer</code> 类似，<code>fmt</code> 包在打印值时也会满足 <code>error</code>。）</p><p>通常函数会返回一个 <code>error</code> 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code> 来进行错误处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure><p><code>error</code> 为 nil 时表示成功；非 nil 的 <code>error</code> 表示失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">When time.Time</span><br><span class="line">What <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写Error。如果Error()返回值不为空。则需要进行错误处理。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">time.Now(),</span><br><span class="line"><span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><h1 id="7-并发"><a href="#7-并发" class="headerlink" title="7. 并发"></a>7. 并发</h1><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>goroutine 是由 Go 运行时管理的轻量级线程。</p><p>go f(x, y, z)</p><p>会启动一个新的 Go 程并执行</p><pre><code>f(x, y, z)</code></pre><p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p><p>goroutine在<strong>相同的地址空间中运行</strong>，因此在访问共享的内存时必须进行同步。<a href="https://go-zh.org/pkg/sync/"><code>sync</code></a> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一页）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印的结果，world可能在后面</span></span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p><p>ch &lt;- v    // 将 v 发送至信道 ch。<br>v := &lt;-ch  // 从 ch 接收值并赋予 v。</p><p>（“箭头”就是数据流的方向。）</p><p>和映射与切片一样，信道在使用前必须创建：</p><p>ch := make(chan int)</p><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p><p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 将和送入 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// 从 c 中接收  接收没有先后顺序吗？ 为什么是一个c</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -5 17 12</span></span><br><span class="line"><span class="comment">// 17 -5 12 也会出现这种情况。两个函数不一定哪一个先执行。执行完的会先把值传递给c。</span></span><br></pre></td></tr></table></figure><p><strong>带缓冲的信道</strong></p><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p><p>ch := make(chan int, 100)</p><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p><p>修改示例填满缓冲区，然后看看会发生什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fatal error: all goroutines are asleep - deadlock! 如果缓存为2</span></span><br></pre></td></tr></table></figure><p> <strong>range 和 close</strong></p><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p><p>v, ok := &lt;-ch</p><p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p><p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p><p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p><p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>) <span class="comment">// c是x的值</span></span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c) <span class="comment">// cap(c) c的容量</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">34</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> <strong>select 语句</strong></p><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p><p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span> <span class="comment">// 前面的执行完才会执行。quit chan有值 值是多少都可以</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p><p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">&quot;tick.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-boom:</span><br><span class="line">fmt.Println(<span class="string">&quot;BOOM!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;    .&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p><p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p><p>这里涉及的概念叫做 <em>互斥（mutual</em>exclusion）<em> ，我们通常使用 </em>互斥锁（Mutex）* 这一数据结构来提供这种机制。</p><p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p><ul><li><code>Lock</code></li><li><code>Unlock</code></li></ul><p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p><p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">v   <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line"><span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><a href="https://www.ququ123.xyz/2022/04/golang_wait_group_principle/">sync.WaitGroup 详解</a></p><ol><li>main 协程通过调用 <code>wg.Add(delta int)</code> 设置 worker 协程的个数，然后创建 worker 协程；</li><li>worker 协程执行结束以后，都要调用 <code>wg.Done()</code>；</li><li>main 协程调用 <code>wg.Wait()</code> 且被 block，直到所有 worker 协程全部执行结束后返回。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-ref&quot;&gt;&lt;a href=&quot;#0-ref&quot; class=&quot;headerlink&quot; title=&quot;0. ref&quot;&gt;&lt;/a&gt;0. ref&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://tour.go-zh.org/concurrency/11&quot;&gt;Go 语言之旅&lt;</summary>
      
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="Programming" scheme="https://blog.210222.xyz/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>How to Become a Programmer</title>
    <link href="https://blog.210222.xyz/posts/be-a-programmer"/>
    <id>https://blog.210222.xyz/posts/be-a-programmer</id>
    <published>2022-06-12T04:00:00.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p>做饭的时候看青菜的生产日期，突然回想起，我正好是两年前的今天开始学习编程，第一次写下Hello World。现在作为一个程序员工作都已经一年有余，正好周末总结下两年的学习成果，算是对这两年时间的记录。</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><ol><li>Java<br>目前的工作语言，主要写Web后端。比较熟悉，语言特性，API，JVM多少都有些了解。当时看的是 <a href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷Java入门视频教程</a> ，讲的很好很易懂。并不比很多大学老师讲的差，注重实用性，细节且全面，对于两年前初学编程的我来说非常好的教程。</li><li>JavaScript/TypeScript<br>基本的语法风格和Java有蛮多相似处。学习起来并不算那么费劲，但是写的不多。但是这种动态语言写起来还是很爽的。TypeScript内容也不算很多，看文档学习。阮一峰的两本教程写的很好。<a href="https://wangdoc.com/javascript/">JavaScript 教程 - 网道</a> 和<a href="https://wangdoc.com/es6/">ES6 教程 - 网道</a>。现在学习新的技术，看文档效率会高一些。偶尔也会看视频学习。<br>学了一些React，或许有时间自己写个Side Project。Vue和Angular看过点文档，公司在用Angular。很少写前端。</li><li>Go<br>最近学习分布式系统，需要用Go，看了<a href="https://go.dev/tour/welcome/1">A Tour of Go</a>，最近在用Go刷题，熟悉下语法。还是要多写。</li><li>Python<br>看了Github上的教程 <a href="https://github.com/jackfrued/Python-100-Days">jackfrued/Python-100-Days: Python - 100天从新手到大师</a>。一直没咋用，都快忘了。</li><li>Haskell<br>其实还看了点函数式语言，看了点Haskell教程，<a href="http://learnyouahaskell.com/introduction">Introduction - Learn You a Haskell for Great Good!</a> 但是并没有坚持下去，之后有机会再学学看。</li></ol><h2 id="CS基础"><a href="#CS基础" class="headerlink" title="CS基础"></a>CS基础</h2><p>毕竟不是科班出身。很多基础课程该补还是得补。学的东西可能才达到普通CS本科生30-40%的水平吧，道阻且长。</p><ol><li>操作系统<br>主要看了 <a href="https://www.bilibili.com/video/BV1uW411f72n?spm_id_from=333.337.search-card.all.click&amp;vd_source=8e1a20c85a51789c4d1b6ca3da3184a3">清华 操作系统原理</a> ，最近看了一些南京大学的操作系统课程讲的会比较深入一些。书读完了OSTEP <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a>，已经有中文版了。</li><li>编译器<br>本来在看Engineering a  compiler。看了三章实在是过于抽象。又找到了 <a href="http://craftinginterpreters.com/">Crafting Interpreters</a>，教程写的非常好。每一章结束都能有一个能跑的程序，具体多了。但是只实现了第一部分的jlox解释器。第二部分用C语言写一个VM或许才是更主要的部分。精力不足就搁置了。</li><li>体系结构<br>看了<a href="https://book.douban.com/subject/4822685//">编码 (豆瓣)</a>，非常好的一本书，想要理解计算机是怎么运作的，CPU是如何计算的，这是一本非常简明易懂的书。还有CSAPP也是很著名了，我还没有看完。</li><li>计算机网络<br>看了 谢希仁的计算机网络，买了计算机网络自顶向下，但是还没有读完。HTTP, HTTPS(TLS), TCP/IP协议栈。细节比较多。</li><li>数据结构和算法<br>在Coursera上看了两周Princeton的算法课，也没有看完，但是配套的教材 算法第四版是本非常好的书，可以时常查阅。另外在B站看了左程云的算法课。理论性肯定不如Princeton的课，但是更加实用一点。对基础数据结构比较熟悉。LeetCode最近没事在刷，目前大概做了230题左右，算是有挺多进步的。</li><li>数据库原理<br>之前在看CMU的Andy Pavlo的课<a href="https://15445.courses.cs.cmu.edu/fall2021/">CMU 15-445/645 :: Intro to Database Systems (Fall 2021)</a>，但是课程也只看了五周左右，看到Buffer Pool部分。之后找时间再继续看吧。</li><li>分布式系统<br>在学习MIT的 <a href="https://pdos.csail.mit.edu/6.824/schedule.html">6.824 Schedule: Spring 2022</a> 希望能坚持把Lab都做完。<br>DDIA基本读完了。非常好的分布式系统的书。</li></ol><h2 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h2><ol><li>Git<br>现在对git算是能比较用的娴熟，之前还是很多都不懂。主要看的 <a href="https://git-scm.com/book/en/v2">Git - Book</a></li><li>CI/CD<br>最近项目用到，学习了一些CI/CD 相关的东西。 TeamCity Openshift之类的。还有一些公司在用的不是那么大众的工具，顺便因为公司的一个legacy项目了解了一些.NET相关的技术。</li><li>其他一些Web框架，中间件，类库。大概是知道怎么用吧，原理还有很多不懂的，不列举了。学会看文档，很多东西学起来也快。</li><li>设计模式，软件工程等</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>最重要的能力其实是，善于使用搜索引擎，不要用百度，尽量使用英文搜索。自己解决问题，收集信息。</li><li>需要持续不断学习，保持好奇心，保持折腾，持之以恒。有时候也挺辛苦的</li><li>注意身体健康。容易久坐和熬夜。多运动，少坐，保持良好的习惯</li><li>有时候不能把眼光局限在那一点地方，Think outside the box</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做饭的时候看青菜的生产日期，突然回想起，我正好是两年前的今天开始学习编程，第一次写下Hello World。现在作为一个程序员工作都已经一年有余，正好周末总结下两年的学习成果，算是对这两年时间的记录。&lt;/p&gt;
&lt;h2 id=&quot;编程语言&quot;&gt;&lt;a href=&quot;#编程语言&quot; cl</summary>
      
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="Programming" scheme="https://blog.210222.xyz/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Fundamentals</title>
    <link href="https://blog.210222.xyz/posts/binary-tree-basics"/>
    <id>https://blog.210222.xyz/posts/binary-tree-basics</id>
    <published>2022-03-12T09:12:00.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt;&#123;</span><br><span class="line">    T val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p>递归, 迭代, Morris -&gt; 实现二叉树的先序、中序、后序遍历。</p><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>递归序。每次递归调用结束会返回到当前方法的调用处。</p><p>序是根节点在的位置。根的相对位置决定序。</p><ul><li>先序遍历：对于每一颗子树来说。都是<strong>根左右</strong>的顺序。</li><li>中序遍历：<strong>左根右</strong> </li><li>后序遍历：<strong>左右根</strong></li></ul><p>递归序。每次递归调用结束会返回到当前方法的调用处。<br>第一次进入节点root。第一次进入方法。<br>递归调用root.left。递归结束会回到原方法<br>递归调用root.right。递归结束会回到原方法</p><p>所以会三次进入当前调用方法的栈。</p><ul><li>先序遍历：就是在第一次进入方法的时候打印</li><li>中序遍历：就是在第二次进入方法的时候打印</li><li>后序遍历：就是在第三次进入方法的时候打印<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 递归方式遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeRecurTraversal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// println可以换成任意方法调用，来操作节点</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left);</span><br><span class="line">        postorder(root.right);</span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h3><p>所有的递归都可以改写成非递归。<br>因为递归是程序语言在隐式地帮你压栈。</p><p><a href="https://www.zhihu.com/question/58400144">什么样的编程语言会不支持递归呢？ - 知乎</a><br><a href="https://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化 - 阮一峰的网络日志</a><br><a href="https://juejin.cn/post/6963679314101403679#heading-22">Java尾递归 - 掘金</a></p><blockquote><p> Java在编译器层面没有优化尾递归调用<br> <a href="https://softwareengineering.stackexchange.com/questions/272061/why-doesnt-java-have-optimization-for-tail-recursion-at-all">Why doesn’t Java have optimization for tail-recursion at all? </a><br>As explained by Brian Goetz (Java Language Architect at Oracle) in this <a href="https://www.youtube.com/watch?v=2y5Pv4yN0b0&amp;t=1h02m18s">video</a>:<br>“in jdk classes […] there are a number of security sensitive methods that rely on counting stack frames between jdk library code and calling code to figure out who’s calling them.”</p><p>Anything that changed the number of frames on the stack would break this and would cause an error. He admits this was a stupid reason, and so the JDK developers have since replaced this mechanism.</p><p>He further then mentions that it’s not a priority, but that tail recursion will eventually get done.</p><p>N.B. This applies to HotSpot and the OpenJDK, other VMs may vary.</p><p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E6%80%BB%E7%BB%93">第 4 章: 柯里化（curry） · 函数式编程指北</a><br><a href="https://stackoverflow.com/questions/6134278/does-java-support-currying">functional programming - Does Java support Currying? - Stack Overflow</a></p></blockquote><p>使用栈实现。<br><a href="https://segmentfault.com/a/1190000019076869">Stack，ArrayDeque，LinkedList的区别 - SegmentFault 思否</a><br>Java不要使用Stack，Deprecated。使用Deque。</p><ul><li>先序遍历</li></ul><ol><li>如果头不为空。初始化栈。压入栈。</li><li>如果栈不为空，<ol><li>每次从栈中弹出一个节点cur。</li><li>打印(处理)cur</li><li>如果有右节点。push。如果有左节点push</li></ol></li><li>当栈空时，处理结束</li></ol><ul><li>中序遍历</li></ul><ol><li>如果头不为空。初始化栈。压入栈。</li><li>如果栈不为空，或者root不为null<ol><li>root不为空，push，把左边节点都push。</li><li>直到root为空。就开始弹出节点。每弹出一个节点就打印值。</li><li>然后去到右边节点。继续处理这个节点的左边界。</li></ol></li><li>直到栈空了，并且root为null<br>先左再头。再去到右树的先左再头。不断循环。</li></ol><ul><li>后序遍历</li></ul><ol><li>如果头不为空 初始化两个栈，压入栈。</li><li>如果栈不为空，<ol><li>每次从栈中弹出一个节点cur。</li><li>push到另一个辅助栈</li><li>如果有左节点。push。如果有右节点push</li></ol></li><li>依次弹出第二个栈中的元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TraversalOfBinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;T&gt;&#123;</span><br><span class="line">        T val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(T val)&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(T val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">          <span class="built_in">this</span>.val = val;</span><br><span class="line">          <span class="built_in">this</span>.left = left;</span><br><span class="line">          <span class="built_in">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">            stack.push(root);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                System.out.println(root.val)</span><br><span class="line">                <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当左边遍历到根节点时，就开始处理右边节点的左子树</span></span><br><span class="line">                <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.push(root);</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = stack.pop();</span><br><span class="line">                    System.out.println(root.val);</span><br><span class="line">                    root = root.right;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Morris traversal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">            Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line">            stack1.push(root);</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                root = stack1.pop();</span><br><span class="line">                stack2.push(root);</span><br><span class="line">                <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack1.push(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack1.push(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack2.isEmpty()) &#123;</span><br><span class="line">                System.out.println(stack2.pop().val)</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Morris-Traversal"><a href="#Morris-Traversal" class="headerlink" title="Morris Traversal"></a>Morris Traversal</h3><p><a href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris - 知乎</a></p><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为<strong>O(1)</strong> 的精妙算法。  </p><p>morris遍历利用的是树的叶节点左右孩子为空（<strong>树的大量空闲指针</strong>），实现空间开销的极限缩减。</p><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">线索二叉树 - 维基百科，自由的百科全书</a></p><p><strong>记作当前节点为cur。</strong></p><ol><li>如果cur无左孩子，cur向右移动（cur=cur.right）</li><li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright<ol><li>如果mostright的right指针指向null，让其指向cur，cur向左移动（cur=cur.left）</li><li>如果mostright的right指针指向cur，让其指向null，cur向右移动（cur=cur.right）</li></ol></li><li>cur为null时遍历结束</li></ol><p>实现以上的原则，即实现了morris遍历。<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715237.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203270715310.png" alt=""></p><p>一个节点如果有左树，能够回到该节点两次。没有左树的节点只能到达一次。</p><p>如果左树上的mostright如果指向null，就是第一次来到当前节点。<br>如果左树上的mostright如果指向 cur，就是第二次来到当前节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MorrisTraversal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        TreeNode mostRight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cur为null时，遍历结束</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="comment">// 如果左子树为空，则跳过以下分支，直接向右移动</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 向右移动，找到most right。如果之前修改过这个mostright，则到第二个条件也要停止</span></span><br><span class="line">                <span class="keyword">while</span>(mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right!=cur)&#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  有指针指向空，则是第一次来到cur</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="comment">// 进行下一次while</span></span><br><span class="line">                    <span class="comment">//continue;</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mostRight.right =<span class="literal">null</span>;<span class="comment">// 第二次来到cur</span></span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur = cur.right;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<br>遍历所有节点的mostright，最多是遍历两边，因此时间复杂度仍然是O(N)。</p><p>递归：</p><ul><li>先序遍历：就是在第一次进入方法的时候打印</li><li>中序遍历：就是在第二次进入方法的时候打印</li><li>后序遍历：就是在第三次进入方法的时候打印</li></ul><p>Morris:<br>先序遍历：</p><ol><li>如果一个节点只能到达一次，直接打印</li><li>如果一个节点能到达两次，第一次打印。</li></ol><p>中序遍历：</p><ol><li>如果一个节点只能到达一次，直接打印</li><li>如果一个节点能到达两次，第二次打印。</li></ol><p>后序遍历：</p><ol><li>只能到达一次的节点不打印</li><li>第二次到达节点，逆序打印左树的有边界mostright</li><li>所有节点遍历完之后，单独逆序打印整个树的右边界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// cur表示当前节点，mostRight表示cur的左孩子的最右节点</span></span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur有左孩子，找到cur左子树最右节点</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight的右孩子指向空，让其指向cur，cur向左移动</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                System.out.println(cur.value);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mostRight的右孩子指向cur，让其指向空，cur向右移动</span></span><br><span class="line">                mostRight.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有左树的节点，直接打印</span></span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisIn</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="comment">// 用continue能节省几行代码， </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第二次来到该节点的时候打印</span></span><br><span class="line">                mostRight.right = <span class="literal">null</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mostRight.right != null 和没有左子树的情况都要执行</span></span><br><span class="line">        <span class="comment">// 能回到两次的节点，当第二次量到达的时候，也就是mostRight.right != null时打印</span></span><br><span class="line">        <span class="comment">// 没有左树也会打印（只经过一遍的节点）</span></span><br><span class="line">        System.out.print(cur.value);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morrisPost</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">           mostRight = cur.left;</span><br><span class="line">           <span class="keyword">if</span>(mostRight != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span> (mostRight.right !=<span class="literal">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                   mostRight = mostRight.right;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                   mostRight.right = cur;</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                   printEdge(cur.left);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 整个while结束之后</span></span><br><span class="line">       printEdge(head);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 逆序打印。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span>reverseEdge(node);</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span> )&#123;</span><br><span class="line">           System.out.println(cur.value);</span><br><span class="line">           cur =cur.right;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 打印完。再调整回去</span></span><br><span class="line">       reverseEdge(tail);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单链表的反转。</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseEdge</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">           next = node.right;</span><br><span class="line">           node.right = pre;</span><br><span class="line">           pre = node;</span><br><span class="line">           node = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>递归，迭代：<br>时间复杂度: 都是O(N)，要经过每一个节点<br>空间复杂度: 在二叉树退化成链表的时候最差是O(N)，平均状况是O(logn)</p><p>Morris遍历：<br>时间复杂度: 是O(N)<br>空间复杂度：O(1)</p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树的深度优先遍历 ：先序遍历<br>二叉树的宽度优先遍历 ：队列。      -&gt;   层序遍历。<br><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要逐层打印</span></span><br><span class="line"><span class="comment">输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment">输出：[[3],[9,20],[15,7]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">拓展：最大宽度 -&gt; 还是可以用刚才的方法 </span></span><br><span class="line"><span class="comment">最大宽度在哪一层？-&gt; 要维护一个层数的变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">// 每一层都需要一个新的</span></span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 只有当一层遍历完。才进入下一层。</span></span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root = queue.poll();</span><br><span class="line">            tmp.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N) 节点进出队列一次<br>空间复杂度：叶子节点层，需要存 N/2个节点。空间复杂度为O(N)</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p> Binary search tree -&gt; BST<br> 若它的左子树不空，则左子树上所有结点的值均<strong>小于</strong>它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值； 它的左、右子树也分别为二叉排序树</p><h3 id="验证BST"><a href="#验证BST" class="headerlink" title="验证BST"></a>验证BST</h3><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树 - 力扣（LeetCode）</a><br>判断是否为BST: 中序遍历 -&gt; 如果是升序的。就是BST</p><p>记录上一次 处理的节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">preVal</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="keyword">if</span> (!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; preVal)&#123;</span><br><span class="line">            preVal = Long.valueOf(root.val);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：O(N)<br>空间复杂度：O(N)</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>Complete binary tree<br>若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树为完全二叉树</p><h3 id="验证CBT"><a href="#验证CBT" class="headerlink" title="验证CBT"></a>验证CBT</h3><p><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验 - 力扣（LeetCode）</a><br>基于层序遍历<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203122319982.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCBT</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeaf</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            root = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 就是为了减少代码量。要频繁用到</span></span><br><span class="line">            left = root.left;</span><br><span class="line">            right = root.right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断false的两种情况。</span></span><br><span class="line">            <span class="comment">// 1. 左空右不空。2. 已经到达叶节点，叶节点却还有子节点</span></span><br><span class="line">            <span class="keyword">if</span>((left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)) </span><br><span class="line">            || (isLeaf &amp;&amp; (left != <span class="literal">null</span> || right != <span class="literal">null</span>)) </span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 一旦遇到一个节点的存在节点不满的情况。当前节点一定是倒数第二层节点，</span></span><br><span class="line">            <span class="comment">// 其之后的节点全是叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span>)&#123;</span><br><span class="line">                isLeaf = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 整个遍历完。返回true;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p><strong>Full Binary Tree</strong>( 或Perfect Binary Tree)</p><ul><li>所有internal node都有两个子节点；</li><li>所有leaf node具有相同的level(或相同的height)。</li><li>若一棵Full Binary Tree的leaf node之level为nn，整棵樹共有$2^n−1$個node。</li></ul><p>另一种定义：二叉树的每个 节点恰好有 0 或 2 个子结点。</p><h3 id="判断是否为满二叉树"><a href="#判断是否为满二叉树" class="headerlink" title="判断是否为满二叉树"></a>判断是否为满二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="type">int</span> nodes;</span><br><span class="line">        Info(<span class="type">int</span> h, <span class="type">int</span> n)&#123;</span><br><span class="line">            <span class="built_in">this</span>.height = h;</span><br><span class="line">            <span class="built_in">this</span>.nodes = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFullBinaryTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">root</span> <span class="operator">=</span> isFull(root);</span><br><span class="line">        <span class="keyword">return</span> root.nodes == (<span class="number">1</span> &lt;&lt; root.height - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">isFull</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> isFull(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> isFull(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(left.height, right.height) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nodes</span> <span class="operator">=</span> left.nodes + right.nodes + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height, nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>对于任意的子树，其左右子树的高度差都&lt;=1</p><h3 id="判断是否为平衡树"><a href="#判断是否为平衡树" class="headerlink" title="判断是否为平衡树"></a>判断是否为平衡树</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度 - 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ReturnEntry</span>&#123;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="type">boolean</span> isBalanced;</span><br><span class="line"></span><br><span class="line">        ReturnEntry(<span class="type">int</span> height, <span class="type">boolean</span> isBalanced)&#123;</span><br><span class="line">            <span class="built_in">this</span>.height = height;</span><br><span class="line">            <span class="built_in">this</span>.isBalanced = isBalanced;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isBalancedTree(root).isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方法 -&gt; 树形DP 如何把子树 信息传递。</span></span><br><span class="line">    <span class="keyword">public</span> ReturnEntry <span class="title function_">isBalancedTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnEntry</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReturnEntry</span> <span class="variable">left</span> <span class="operator">=</span> isBalancedTree(root.left);</span><br><span class="line">        <span class="type">ReturnEntry</span> <span class="variable">right</span> <span class="operator">=</span> isBalancedTree(root.right);</span><br><span class="line"></span><br><span class="line">        height = Math.max(left.height, right.height) + <span class="number">1</span>;</span><br><span class="line">        isBalanced = left.isBalanced &amp;&amp; right.isBalanced</span><br><span class="line">        &amp;&amp; Math.abs(left.height - right.height) &lt;= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnEntry</span>(height, isBalanced);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化版</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(l - r)&lt;=<span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树深度的计算。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剪枝。如果左子树是不平衡的，就提前返回了。而计算深度是全部都要算一遍。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// -1 表示非平衡</span></span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次递归返回深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：</p><ol><li>先序遍历 + 深度。递归<ol><li>时间复杂度 O(NlogN) 需要计算每一颗子树的深度。logN 层。 每层最多N节点。最少(N+1)/2</li><li>空间复杂度 O(N) 递归深度。退化成链表的情况。</li></ol></li><li>后续遍历 + 剪枝<ol><li>时间复杂度 O(N) 。减少了很多重复计算。最多遍历N个节点</li><li>空间复杂度  O(N) </li></ol></li></ol><h2 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>方法一 使用额外空间：</p><ol><li>使用HashMap记录每个节点的父节点。</li><li>然后从n1往上遍历。加入一个set中。</li><li>然后从n2往上遍历。检查set中是否包含n2 往上的路径。</li></ol><p>递归：<br><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121522264.png" alt="lca"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode n1, TreeNode n2)</span>&#123;</span><br><span class="line">        <span class="comment">// 结束递归的条件</span></span><br><span class="line">        <span class="comment">// 只要当节点遇到n1 n2时才会向上返回值。否则都是返回空</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == n1 || root == n2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, n1, n2);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, n1, n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// left, right都不为空。说明n1,n2分别在当前节点的左右子树上，当前节点为最低公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有一个为空，返回非空的那个。两个都为空，则返回空。</span></span><br><span class="line">        <span class="comment">// 有一边为空。说明n1, n2在同一侧子树上。必然为 n1/n2 是 n2/n1的祖先的情况。</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找后继节点"><a href="#查找后继节点" class="headerlink" title="查找后继节点"></a>查找后继节点</h2><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121710824.png" alt=""></p><h3 id="有父指针的二叉树"><a href="#有父指针的二叉树" class="headerlink" title="有父指针的二叉树"></a>有父指针的二叉树</h3><p>求一个二叉树中一个节点的后继节点（后继节点是中序遍历后的集合每个元素的下一个元素）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode parent;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span>&#123;</span><br><span class="line">        <span class="comment">// 右子树不为空</span></span><br><span class="line">        <span class="keyword">if</span>(p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftmost</span> <span class="operator">=</span> p.right;</span><br><span class="line">            <span class="keyword">while</span>(leftmost.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                leftmost = leftmost.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> leftmost;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p.parent != <span class="literal">null</span> &amp;&amp; p.parent.left != p)&#123;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉搜索树-1"><a href="#二叉搜索树-1" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><a href="https://leetcode-cn.com/problems/successor-lcci/">面试题 04.06. 后继者 - 力扣（LeetCode）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode p)</span>&#123;</span><br><span class="line">        <span class="comment">// 使用一个cur指针 记录最后一次向左转的节点。即为没有右子树情况下的后继节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从根节点遍历找到p</span></span><br><span class="line">        <span class="keyword">while</span>(root.val != p.val)&#123;</span><br><span class="line">            <span class="comment">// 如果向右拐找到p cur不变。</span></span><br><span class="line">            <span class="keyword">if</span>(p.val &gt; root.val)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="comment">// 如果过程中向左拐了，要更新cur</span></span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = root;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环结束时。root指向p</span></span><br><span class="line">        <span class="comment">// 如果右子树存在。则找出右子树上的leftmost。没有右子树。则返回cur</span></span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 找到右子树的leftmost</span></span><br><span class="line">            root = root.right;</span><br><span class="line">            <span class="keyword">while</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两题的区别在于：</p><ul><li>二叉搜索树能通过val从root找到p</li><li>普通二叉树则需要通过parent指针来向上溯源。</li></ul><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#_&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(root.val + <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> serialize(root.left);</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> serialize(root.right);</span><br><span class="line">        data.append(left).append(right);</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;#&quot;</span>.equals(arr[i]))&#123;</span><br><span class="line">                queue.add(<span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                queue.add(Integer.valueOf(arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reconTree(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">reconTree</span><span class="params">(Queue&lt;Integer&gt; data)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> data.poll();</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        root.left = reconTree(data);</span><br><span class="line">        root.right = reconTree(data);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure><br>复杂度：</p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h2 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h2><blockquote><p>纸条对折。 从纸条的上方按顺序打印折痕方向</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/202203121905335.png" alt=""><br>左子树都是凹，右子树都是凸<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">printFoldLine</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">// 根节点为对折一次产生的凹折痕</span></span><br><span class="line">        print(n, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n表示对折次数。i为当前对折的次数。down表示折痕为凹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">boolean</span> down)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        print(n, i + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(down ? <span class="string">&quot;down&quot;</span> : <span class="string">&quot;up&quot;</span>);</span><br><span class="line"></span><br><span class="line">        print(n, i + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="Algorithm" scheme="https://blog.210222.xyz/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>厨房生活</title>
    <link href="https://blog.210222.xyz/posts/life-in-kitchen"/>
    <id>https://blog.210222.xyz/posts/life-in-kitchen</id>
    <published>2021-07-17T09:12:00.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/image-20210717170919873.png" alt="enjoy obesity"></p><span id="more"></span><p>自从购置了厨房秤，开始对手边的一切事物进行质量的测量。</p><p>一颗鸡蛋50g，去壳后44g。</p><p>一根黄瓜275g。一个番茄215g。</p><p>一盒五花肉400g。</p><p>发现美团买菜时常缺斤少两。很阴险。</p><p>从前只从外观上观测事物，非常片面，认识论的一种缺失。</p><p>19.9元随便买的不锈钢刀，用了大半年后切肉很费劲。购买了磨刀石并苦心专研磨刀技术，需要找到某个角度，左手捏住刀片，右手进行推拉，粗磨后再进行细磨，磨完后试刀非常满足。</p><p>都市青年人必须拥有一把锋利的刀。</p><p>购买了捣蒜臼，很小就想拥有一个。因为使用后还要清洗，所以只在吃火锅的时候使用过，重大设计缺陷。</p><p>湿垃圾才是真正的垃圾，易腐败，发臭，长虫，恶心至极。其他垃圾只能叫废品。</p><p>清空冰箱食材令人满足，享受东西用完的感觉。</p><p>三个季度消耗了5kg装大米多袋，食用油两桶，蚝油两瓶，番茄酱两瓶，食盐、鸡精多袋，料酒、酱油多瓶，黑胡椒粉一瓶，土豆淀粉一包，八角、香叶、桂皮约100g，冰糖一包，家里寄的腊肉五斤，粉干若干斤，粉丝若干斤。</p><p>我不能没有小米椒。</p><p>深度调研铁锅，铸铁锅，不粘锅，铜锅，康宁锅等多种锅具。最终随意购买销量排名较前的不粘锅和汤锅。</p><p>深度调研花生油，菜籽油，葵花籽油，猪油，橄榄油等多种食用油。最终随意购买了销量排名较前的某款调和油。</p><p>深度调研土豆淀粉，玉米淀粉，红薯淀粉，木薯淀粉，小麦淀粉等多款淀粉。最终随意买了一款玉米淀粉。</p><p>掌握常见食材市场价格及其波动。</p><p>掌握食材的保存期限。</p><p>掌握菜肴烹饪基本技术，如火候、调味、食材处理等。</p><p>掌握多道菜肴烹饪方法，如红烧肉、排骨汤等常见菜。</p><p>了解杭椒、线椒、青椒、螺丝椒的区别。</p><p>了解猪肉不同部位的区别。</p><p>能够辨认常见绿叶菜，常见鱼类。</p><p>用完厨房会清理餐桌，灶台，清洗锅盖，丢湿垃圾的人才值得信任。</p><p>下面开始技术总结：一个人做饭会因为做太多又不想浪费，而导致肥胖，还是建议点外卖。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/image-20210717170919873.png&quot; alt=&quot;enjoy obesity&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>语言碎片 2021/07</title>
    <link href="https://blog.210222.xyz/posts/thoughts-of-202107"/>
    <id>https://blog.210222.xyz/posts/thoughts-of-202107</id>
    <published>2021-07-11T15:55:00.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/image-20210711235022656.png" alt="2001: A Space Odyssey"></p><span id="more"></span><ol><li><p>爱人会令泪腺脆弱</p></li><li></li></ol><p>我打开冰箱冷冻室惊叹：this is a morgue</p><ol><li><p>上海的菜饭骨头汤的counterpart是广州的隆江猪脚饭</p></li></ol><ol><li><p>是谁发明了计算机，互联网<br>奴役人，把人变成了猪</p></li></ol><p>是时候发起新卢德运动<br>剪断海底光缆<br>砸烂互联网公司的机房</p><p>远离城市<br>回到原始社会<br>种植洋芋<br>钻木取火<br>做另一种意义的新人类</p><ol><li><p><a href="https://www.youtube.com/watch?v=HH37JTBpi2A">Quote Hal 9000 </a>:</p></li></ol><p>Stop Dave.<br>Will you stop, Dave?<br>Stop Dave.<br>I’m afriad.<br>I’m afriad, Dave.<br>Dave, My mind is going<br>I can feel it.<br>My mind is going.<br>I can feel it.<br>There is no question about it.<br>I can feel it.<br>I can feel it.<br>I can feel it.<br>I’m afraid<br>… </p><ol><li><p>抽水果味电子烟的人 have no idea what they are doing</p></li></ol><ol><li><p>等公交<br>等地铁<br>等红绿灯</p></li></ol><p>等电梯<br>等早餐<br>等周五</p><p>等开会<br>等发工资<br>等待养老保险</p><p>等待明天<br>等待死亡</p><ol><li><p>Microsoft 罪恶滔天</p></li></ol><ul><li>onenote 罄竹难书</li><li>windows font &amp; high resolution adaption</li></ul><ol><li><p>How poverty shapes me:</p></li></ol><ul><li>always do the cost benefit analysis</li><li>have low self-esteem</li><li>risk averse(never take risks more exactly)</li></ul><ol><li><p>上海，总体来说，是一座垃圾城市。我将会写篇论文进行批判。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/paranoiddemon/picbed@master/imgs/image-20210711235022656.png&quot; alt=&quot;2001: A Space Odyssey&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>Move blog to Typecho</title>
    <link href="https://blog.210222.xyz/posts/typecho"/>
    <id>https://blog.210222.xyz/posts/typecho</id>
    <published>2021-07-11T02:26:00.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Buy ECS at whatever platform you like</li><li><p>Generate SSH Keys and bind it with the instance</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210710153016663.png" alt="image-20210710153016663"></p></li><li><p>Configure the Windows Terminal(Any SSH client is good)</p></li></ol><p><a href="https://sspai.com/post/59380">Windows Terminal</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;guid&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tencent Cloud CentOS Shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ssh -i &lt;secret key path&gt; &lt;username&gt;@&lt;ip address&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;closeOnExit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>            </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>guid: use powershell  <code>new-guid</code> generate unique id</p><p>commandline:</p><ul><li>secret key path : the path store your private key downloaded from tencent cloud</li><li>username: default root </li><li>ip address: ecs ip address </li></ul></blockquote><p>After the SSH Keys were set up, no need to input password anymore.</p><ol><li>Modify and add access to bt-panel port.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210710153719508.png" alt="image-20210710153719508"></p><ol><li>Add your site in bt-panel</li></ol><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210711101351603.png" alt="image-20210711101351603"></p><ol><li>Download typecho and install<br>Upload the typecho package to your site root dierctory and extract. Visit <code>ip address:port/install.php</code>, follow the installation step.</li><li>Get a theme you love, create a post. Enjoy writing.</li></ol>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;Buy ECS at whatever platform you like&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generate SSH Keys and bind it with the instance&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="https://blog.210222.xyz/categories/notes/"/>
    
    
    <category term="blog" scheme="https://blog.210222.xyz/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Build site with MkDocs</title>
    <link href="https://blog.210222.xyz/posts/mkdocs"/>
    <id>https://blog.210222.xyz/posts/mkdocs</id>
    <published>2021-06-13T16:22:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-MkDocs"><a href="#What-is-MkDocs" class="headerlink" title="What is MkDocs?"></a>What is MkDocs?</h2><p>Accroding to the description from the offical site of MkDocs: </p><blockquote><p>MkDocs is a <strong>fast</strong>, <strong>simple</strong> and <strong>downright gorgeous</strong> static site generator that’s geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file. Start by reading the <a href="https://www.mkdocs.org/getting-started/">introductory tutorial</a>, then check the <a href="https://www.mkdocs.org/user-guide/">User Guide</a> for more information.</p></blockquote><p>With MkDocs, you can generate a static site in a minute and deploy it on your server or github pages.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>First, make sure that Python was installed on you PC and install MkDocs with follow command.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mkdocs</span><br></pre></td></tr></table></figure><p>Create a new project</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdocs new my-project</span><br><span class="line">cd my-project</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210614210231958.png" alt="image-20210614210231958"></p><p><code>mkdocs.yml</code> is the configuration file. The <code>docs</code> folder contains your markdown source files.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdocs serve</span><br></pre></td></tr></table></figure><p>You can preview the site at <code>http://127.0.0.1:8000/</code> in your browser.</p><h2 id="Deploying"><a href="#Deploying" class="headerlink" title="Deploying"></a>Deploying</h2><p>Create a Github repository. clone to your local directory and add <code>site/</code> to <code>.gitignore</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir docs</span><br><span class="line">cd docs</span><br><span class="line">mkdocs new .</span><br><span class="line">mkdocs build</span><br><span class="line">mkdocs serve</span><br></pre></td></tr></table></figure><p>Write your docs in the folder <code>docs</code>. Then run the command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdocs gh-deploy --clean</span><br></pre></td></tr></table></figure><p>It will create a <code>gh-pages</code> branch in your respository and deploy the static site on your github page. Set the default branch to built github pages.</p><p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210619154133068.png" alt="image-20210619154133068" style="zoom: 67%;" /></p><p>You can access you site at <code>https://&#123;username&#125;.github.io/&#123;projectname&#125;</code>.</p><h2 id="Use-MkDocs-Material-Theme"><a href="#Use-MkDocs-Material-Theme" class="headerlink" title="Use MkDocs-Material Theme"></a>Use MkDocs-Material Theme</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Install gtk3-runtime-3.xxx-ts-win64.exe at https://github.com/tschoonj/GTK-for-Windows-Runtime-Environment-Installer/releases</span><br><span class="line"></span><br><span class="line">pip install --upgrade setuptools</span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure><p>Configure the sites in <code>mkdocs.yml</code> refer to the <a href="https://squidfunk.github.io/mkdocs-material/setup/changing-the-colors/">official documents</a>.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_name:</span> <span class="string">Notebook</span></span><br><span class="line"><span class="attr">site_url:</span> <span class="string">https://landfill.cc/wiki/</span></span><br><span class="line"><span class="comment">#site_description: cs WIKI</span></span><br><span class="line"><span class="comment">#copyright: Copyright © 2020 [Landfill](https://www.landfill.cc/)</span></span><br><span class="line"><span class="attr">nav:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">Home:</span> <span class="string">index.md</span></span><br><span class="line"><span class="comment">#  - DEV: dev.md </span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Documents:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Usage :</span> <span class="string">test/usage.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Tutorial:</span> <span class="string">test/tutorial.md</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Data Structure:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">AVL Tree:</span> <span class="string">DataStructure/about.md</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">OS:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">OS NOTES:</span> <span class="string">OS/os.md</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">test:</span> <span class="string">test.md</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#主题</span></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">material</span></span><br><span class="line">  <span class="comment">#custom_dir: material</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">&#x27;zh&#x27;</span>  <span class="comment"># 配置语言</span></span><br><span class="line">  <span class="attr">palette:</span>  <span class="comment"># 颜色</span></span><br><span class="line">    <span class="comment"># - scheme: default</span></span><br><span class="line">    <span class="attr">primary:</span> <span class="string">indigo</span></span><br><span class="line">    <span class="attr">accent:</span> <span class="string">indigo</span></span><br><span class="line">    <span class="comment">#   toggle:</span></span><br><span class="line">    <span class="comment">#     icon: material/toggle-switch-off-outline</span></span><br><span class="line">    <span class="comment">#     name: Switch to dark mode</span></span><br><span class="line">    <span class="comment"># - scheme: slate</span></span><br><span class="line">    <span class="comment">#   primary: indigo</span></span><br><span class="line">    <span class="comment">#   accent: indigo</span></span><br><span class="line">    <span class="comment">#   toggle:</span></span><br><span class="line">    <span class="comment">#     icon: material/toggle-switch</span></span><br><span class="line">    <span class="comment">#     name: Switch to light mode</span></span><br><span class="line">  <span class="attr">features:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">navigation.tabs</span> <span class="comment"># horizon tabs </span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">navigation.tracking</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">navigation.expand</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">navigation.top</span></span><br><span class="line">  <span class="comment">#custom_dir: &#x27;docs/resources/&#x27;</span></span><br><span class="line">  <span class="attr">font:</span></span><br><span class="line">    <span class="attr">text:</span> <span class="string">Roboto</span></span><br><span class="line">    <span class="attr">code:</span> <span class="string">Roboto</span> <span class="string">Mono</span></span><br><span class="line"></span><br><span class="line"><span class="attr">markdown_extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">admonition</span>  <span class="comment"># 提示块</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">footnotes</span>  <span class="comment"># 脚注</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">meta</span>  <span class="comment"># 定义元数据，通过文章上下文控制，如disqus</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.caret</span>  <span class="comment"># 下划线上标</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.tilde</span>  <span class="comment"># 删除线下标</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.critic</span>  <span class="comment"># 增加删除修改高亮注释，可修饰行内或段落</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.details</span>  <span class="comment"># 提示块可折叠</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.inlinehilite</span>  <span class="comment"># 行内代码高亮</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.mark</span>  <span class="comment"># 文本高亮</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.smartsymbols</span>  <span class="comment"># 符号转换</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.superfences</span>  <span class="comment"># 代码嵌套在列表里</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">codehilite:</span>    <span class="comment"># 代码高亮，显示行号</span></span><br><span class="line">      <span class="attr">guess_lang:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">linenums:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">toc:</span>  <span class="comment"># 锚点</span></span><br><span class="line">      <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#  - pymdownx.arithmatex  # 数学公式</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pymdownx.betterem:</span>  <span class="comment"># 对加粗和斜体更好的检测</span></span><br><span class="line">      <span class="attr">smart_enable:</span> <span class="string">all</span></span><br><span class="line"><span class="comment">#  - pymdownx.emoji:  # 表情</span></span><br><span class="line"><span class="comment">#      emoji_generator: !!python/name:pymdownx.emoji.to_svg</span></span><br><span class="line"><span class="comment">#  - pymdownx.magiclink  # 自动识别超链接</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">pymdownx.tasklist:</span>  <span class="comment"># 复选框checklist</span></span><br><span class="line">      <span class="attr">custom_checkbox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">extra:</span></span><br><span class="line">  <span class="attr">search:</span></span><br><span class="line">    <span class="attr">language:</span> <span class="string">&#x27;jp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展样式</span></span><br><span class="line"><span class="comment"># extra_css:</span></span><br><span class="line"><span class="comment">#   - resources/css/extra.css</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Build site with MkDocs and deploy on github pages.</summary>
    
    
    
    <category term="Notes" scheme="https://blog.210222.xyz/categories/Notes/"/>
    
    
    <category term="MkDocs" scheme="https://blog.210222.xyz/tags/MkDocs/"/>
    
    <category term="blog" scheme="https://blog.210222.xyz/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>两种选择</title>
    <link href="https://blog.210222.xyz/posts/randomness"/>
    <id>https://blog.210222.xyz/posts/randomness</id>
    <published>2021-04-22T16:22:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210711133758023.png" alt="img"></p><p>几年前一个台风天，我半躺在床上望向窗外，观察自然的诡秘力量，一个塑料袋在十多层的楼宇间漂流，被肆意拉扯，而后从视野之中消失。后来这场景常以不同形式出现在梦中，世界的随机性在梦境中得到完全体现。</p><p>上帝就像花园里拿石头漫不经心地砸蚂蚁的小孩，无法预知下一锤会落在谁头上。无从得知一个人对自己的生活到底有多少掌控力，就像无从得知上帝是否存在，宇宙是否有界限，幸福能否被把握。整个世界进程在不停地生产随机数，如同彩票摇号。人生盲盒也是充满惊喜，不可预料。但人比蚂蚁更痛苦的地方在于，人意识到自我的存在，有贪嗔痴种种欲念，所以不得不潜入这巨大的幻觉，以之为真实。</p><p>不是说在这个漫长的历程中只有痛苦、随机、或者被决定。人能一定程度上免于这些刑罚。月初的一个下午，我在小区里遛狗，阳光与风都和煦宜人，我无所事事地看着隔壁操场奔跑的中学生。在那其中的某个短暂时刻，我感受到巨大的解脱。没有多的奢望，没有持续的精神压力，不想从世界上得到什么，世界也不向我索取，好像短暂从世界中抽离，进入真空地带。每当这样的时刻出现，我都很想将其保存下来，这些时刻太稀有、太短暂，末了又将回到那高浓度的惨烈生活之中。</p><p>我想过很多次死亡，以各种方式。但我是懦弱之辈，始终无法走出那一步。只能强忍着，一点一点匀着吃完我的份额。整个过程像是被投入深不见底的枯井的石头，看不到尽头的光亮，不过时间久了也自然会习惯，这种无法停止也无所倚靠的幽暗状态。</p>]]></content>
    
    
    <summary type="html">整个过程像是被投入深不见底的枯井的石头。</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>恶心</title>
    <link href="https://blog.210222.xyz/posts/nausea"/>
    <id>https://blog.210222.xyz/posts/nausea</id>
    <published>2021-03-24T16:01:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/Snipaste_2021-03-25_00-46-17.png" alt="Dead Pool"></p><p>这一切令人恶心，整个世界以及全部的人。空气中弥漫着腐烂的味道，死老鼠在瓦解，变成一团失水的死肉。</p><p>天空是漆黑色（#000000，如同从天而降的铁幕，密不透风，没有任何光线可以逃匿，氧气正在变得有毒。 </p><p>我感到饥饿，内脏发出惨叫，在嘶吼，饮食的欲望占据头脑，渴望进食，如同渴望饿死，遗传的原始本能占据了上风。 </p><p>分不清梦境和现实，在虐杀和死亡中来回切换，所有的迹象都汇聚成一种神谕，不可违抗的意志，时代在召唤。</p><p>相信概念，坚持理想，积极行动，都不过是徒劳，人所建筑的一切是海滩上的沙堡，一个浪就沦为废墟，什么是真正重要的，什么可以被把握，都好似无所谓，只有疲倦是人类精神永恒的归宿。 </p><p>具体的人，具体的事，都面目可憎，催吐，难以面对。等待意识上传那一天，把所有神经元击烂成一串无序0 1，无意识永生。</p>]]></content>
    
    
    <summary type="html">这一切令人恶心</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>语言碎片 2020/09</title>
    <link href="https://blog.210222.xyz/posts/thoughtsof202009"/>
    <id>https://blog.210222.xyz/posts/thoughtsof202009</id>
    <published>2020-09-26T16:22:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/photo_2020-09-27_23-03-41.jpg" alt="Revenge of Memories"></p><p>1.<br>回忆是时间的复仇。</p><p>2.<br>Everything will flow.</p><p>3.<br>住在一间好像永远在落雨的房子，心也是皱巴巴的。</p><p>4.<br>不要把你不值钱的一切都托出 That means nothing. </p><p>5.<br>恐惧与焦虑、爱与被爱、渴望理解、精神的无依、幸福与痛苦，所有的一切都是巨大的泡影，一想起一生都要和自己的种种幻觉做斗争就累的想从楼顶跳下去。</p><p>6.<br>Pull yourself together.It’s nothing but illusion.</p><p>7.<br>当我们在回忆的时候，我们是在回忆什么，那些永远不会复现时间片段，是大脑皮层的化学反应吗，一切支离破碎的感觉是真实的吗？</p><p>8.<br>如果一个人一年拍5000张照片，那么他会在意自己从前拍了什么吗？</p><p>9.<br>生命力可能在很久以前就枯竭了。现在每天的感觉是疲倦，不是无意义。</p><p>10.<br>就是一个又一个问题接踵而至，而活着的全部过程是在解决问题。</p><p>11.<br>Everything in its wrong place.</p>]]></content>
    
    
    <summary type="html">胡言乱语inbox，查重率&lt;2%</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>超越规训社会/韩炳哲</title>
    <link href="https://blog.210222.xyz/posts/Mudigkeitsgesellschaft"/>
    <id>https://blog.210222.xyz/posts/Mudigkeitsgesellschaft</id>
    <published>2020-07-25T16:24:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p>​      <img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210711134239121.png" alt="image-20210711134239121"></p><p>  福柯的规训社会（ Disziplinargesellschaft）由医院、疯人院、监狱、营房和工厂构成，已经不再适用于描述当今的社会。取而代之的是另一种社会形态，由健身房、办公楼、银行、机场、购物中心和基因实验室建构的社会。21世纪的社会不再是一个规训社会，而是功绩社会。其中的成员也不再是“驯化的主体”，而是功绩主体。他们成为自身的雇主。那些规训机构的围墙，过去用来分隔正常与异常的疆域，现在变成历史的遗迹。福柯的权力理论无法阐释从规训社会转向功绩社会过程中发生的心理和形态上的变化。过去流行的概念“监控社会”（ Kontrollgesellschaft）也不再适用于这一转型，因为其中包含了过多的否定意义。<br>​<br>​       规训社会是一个否定性的社会。各种否定性的禁令在其中占据主导。否定性的情态动词一“不允许＂（ Nicht dürfen）控制着一切。“应当＂（ Sollen）中也附着否定性、强制性。功绩社会越来越摆脱了否定性。不断升级的去管制化进程取消了否定性。功绩社会使用一种积极的情态动词一打破界限的“能够”（ Können）。集体复合性的肯定句＂是的，我们可以办到！＂恰当地表达了功绩社会的积极属性。禁令、戒律和法规失去主导地位，取而代之的是种种项目计划、自发行动和内在动机。规训社会尚由否定主导，它的否定性制造出疯人和罪犯。与之相反，功绩社会则生产扣郁症患者和厌世者。<br>​<br>​        从规训社会向功绩社会的范式转移在一定程度上也存在延续性。将生产最大化的渴望显然存在于社会集体无意识之中。当生产达到定发展阶段时，禁令的规训法则，或者说其否定模式，便达到其极限。为了进步扩大生产，规训范式必须由功绩范式，或曰“能够”的肯定性模式来取代。因为当生产水平发展到一定程度时，禁令的否定性起到阻塞的效果，妨碍了继续发展。肯定性的“能够”比否定性的“应当”更有效率。因此社会集体无意识由“应当”转向“能够”。较之驯化的主体，功绩主体更高效、多产。“能够”并没有撤销“应当”。功绩主体依然接受规训。他已经逾越了规训阶段。规训法则，即“应当”式律令，保障了生产程序，“能够”则进一步提高生产水平。就提高产量而言，“应当”和“＂能够”之间不存在断裂，反而展示了一贯性。<br>​<br>​        阿兰 · 埃亨伯格（ Alain Ehrenberg）将抑郁症视作规训社会向功绩社会转型期产生的并发症状：“当控制行为的规训模式让位于另一种规范时，换言之，过去通过权威和禁令分配社会阶级和两性角色，如今每个人必须自发地行动，每个人都有义务去成就他自身，抑郁症就在这时开始盛行。抑郁定患者没有最大限度地发展自身，他在必须成就自身的努力中疲力尽。＂[1] 阿兰 · 埃亨伯格仅从自我管理的视角看待抑郁症，这是成问题的。他认为，这一社交命令一一人仅属于自身是导致抑郁症的原因。在他看来，当晚期现代的人类无法成就自身时，抑郁症就是这一失败的病理学表现。然而，正是人际关系的匮乏导致了抑郁症，这种匮乏是日益碎片化、分裂化社会的典型症状。埃亨伯格没有注意到抑郁症的这一面向。他也忽视了功绩社会内部的系统性暴力，正是这种暴力导致了精神梗阻。因此，并非“人仅属于自身”的社交命令，而是成就压力造成了过劳式抑郁症。由此可见，倦怠综合征（Burn-out- Syndrom）不是表达了筋疲力尽的自我，而是表达了疲意、燃尽的（ ausgebrannt）心灵。按照埃亨伯格的观点，当规训社会的规定和禁令让位于主体自主承担责任和自发行动时，抑郁症便开始流行。但事实上，并非过多的责任和自主性导致疾病，而是作为晚期现代社会新戒律的效绩命令（ Imperativ der Leistung）。<br>​<br>​        阿兰 · 埃亨伯格错误地把当下的人类等同于尼采的主权独立的人：“主权独立的人，不模仿任何人，尼采曾宣告他的降临，如今此类型的人即将大量出现。没有在他之上的权威告诉他，他应当成为什么样的人。因为他宣称自己只属于自身。”[2] 恰恰相反，按照尼采的观点，即将大量出现的不是主权独立的超人，而是只会劳作的“末人”（der  letzte Mensch）[3] .这种新型的人类，亳无防御地陷入过度的积极性之中，没有任何独立自主性可言。抑郁的人是一种劳作动物（ animal laboran），他在没有任何外力压迫的情况下，完全自愿地剥削自我。他同时是施暴者和受害者。自身严格来说是一个兔疫学范畴。抑郁症则彻底脱离了免疫学范式。当功绩主体不再能够（继续工作）时，抑郁症就在这一时刻爆发。它首先是种对工作、“＂能够”的倦怠感。只有在一种相信“一切皆有可能”的社会中，才有抑郁症病人发出哀収:＂没有什么是可能的。”不再能够的能够（ Nicht-Mehr- Können-Können）导向一种毀灭性的自我遺责和自我攻击。功绩主体和自身作战。抑郁症患者是这场内在战争中的伤残者。一个社会苦于过度的积极性，因此患上了抑都症。它所反映的，是那种同自身作战的人类。<br>​<br>​        功绩主体不受外在的统治机构控制，没有外力强迫他工作或剥削他。他是自身的主人和统治者。因此他无须屈从于任何人，或者说只屈从于自身。这正是他有別于规训主体之处。但尽管摆脱了统治机构，却没有导向自由。自由和约束几乎在同一时刻降临。功绩主体投身于一种强制的自由，或者说自由的强制之中，以达到最终目的效绩的最大化。[4] 工作和效绩的过度化日益严重，直到发展成一种自我剥削。这比外在的剥削更有效率，因为它伴随着一种自由的感觉。剥削者同时是被剥削者。施虐者和受害者之间不分彼此。这种自我指涉性产生了一种悖论式自由，由于其内部固有的强制结构而转化为暴力。功绩社会的精神疾病，便是这种悖论式自由在病理学上的显现。</p><hr><p>[1] Alain Ehrenberg， Das erschopfte Selbst. Depression und Gesellschaft in derGegenwart， Frankfurt a. M. 2008， S. 14<br>[2] Ebd. , S.155<br>[3] 尼采的“末人”将健康奉为神明：“他们崇拜健康。‘我们找到了幸福’——末人说着，眨眨眼睛。 （Also sprach Zarathustra， Kritische Gesamtausgabe， 5. Abteilung， 1. Band， S.14.)<br>[4]自由的原始含义即和否定性联系在一起。它永远是一种受约束的自由，以免疫学式的他者为出发点当讨度的积极性消灭了否定性时，自由也便失去了意义，由干它起源于否定之否定的辩证关系。</p>]]></content>
    
    
    <summary type="html">倦怠社会摘录</summary>
    
    
    
    <category term="摘录" scheme="https://blog.210222.xyz/categories/%E6%91%98%E5%BD%95/"/>
    
    
    <category term="Excerpt" scheme="https://blog.210222.xyz/tags/Excerpt/"/>
    
  </entry>
  
  <entry>
    <title>DIGITAL GRAVEYARD</title>
    <link href="https://blog.210222.xyz/posts/gravestone"/>
    <id>https://blog.210222.xyz/posts/gravestone</id>
    <published>2020-07-19T16:30:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/image-20210711133525227.png" alt="May the god be with you"></p><h2 id="贾宏声（1967-2010）"><a href="#贾宏声（1967-2010）" class="headerlink" title="贾宏声（1967-2010）"></a>贾宏声（1967-2010）</h2><p><a href="https://movie.douban.com/celebrity/1274399/">豆瓣影人 - 贾宏声</a></p><h2 id="许立志（1990-2014）"><a href="#许立志（1990-2014）" class="headerlink" title="许立志（1990-2014）"></a>许立志（1990-2014）</h2><p><a href="http://book.ifeng.com/fukan/shikan/detail_2015_02/04/14251062_0.shtml">许立志诗选：我咽下一枚铁做的月亮…… | 凤凰诗刊</a></p><p><a href="https://book.douban.com/subject/26342533//">豆瓣读书 - 新的一天</a></p><h2 id="江绪林（1976-2016）"><a href="#江绪林（1976-2016）" class="headerlink" title="江绪林（1976-2016）"></a>江绪林（1976-2016）</h2><p><a href="https://theinitium.com/article/20180219-opinion-chowpochung-jiangxulin/">周保松：一些未曾說完的話 ──紀念江緒林先生逝世兩週年</a></p><p><a href="https://www.douban.com/people/jiangxulin/">豆瓣主页：江绪林</a></p><p><a href="https://weibo.com/u/1880142780">微博主页：江绪林</a></p><h2 id="吴宇清（1967-2017）"><a href="#吴宇清（1967-2017）" class="headerlink" title="吴宇清（1967-2017）"></a>吴宇清（1967-2017）</h2><p><a href="https://new.qq.com/omn/20181112/20181112A0RE7G.html">一个叫吴宇清的男人决定去死</a></p><p><a href="https://www.douban.com/people/2038558/">豆瓣主页：外外</a></p><p><a href="https://music.douban.com/review/2695461/">南京地下音乐记录97-98 - 关于这盒磁带</a></p><h2 id="胡波（1988-2017）"><a href="#胡波（1988-2017）" class="headerlink" title="胡波（1988-2017）"></a>胡波（1988-2017）</h2><p><a href="https://movie.douban.com/subject/27172891/">豆瓣电影 - 大象席地而坐</a></p>]]></content>
    
    
    <summary type="html">记录一些名字，和生活的理由</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>去往远方的猪圈</title>
    <link href="https://blog.210222.xyz/posts/digital-panopticon"/>
    <id>https://blog.210222.xyz/posts/digital-panopticon</id>
    <published>2020-07-14T16:30:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/paranoiddemon/picbed/imgs/7jlM3TEeOFthskf.png" alt="pig float in the sky"></p><p>1、</p><p>下午随手更新了一下Clash的配置文件。发现节点都无法显示。查资料发现似乎是解析配置文件的规范做了调整，于是下载了新版的Clash，发现购买的另一家机场尚未按新的规范写配置文件，又解析不了。于是又开始手动修改，浪费了人生中的一个多小时。</p><p>这些年为了跨过GFW，鼓捣了不少东西。花了很多的力气，只是为了实现那么一件本该很简单的事情：自由地访问互联网。在这件事情上我一直是个实用主义者，我只希望用早少的精力，来访问Google和YouTube罢了。虽然花一些时间暂时能实现，但这些工具终究不过是义肢，充满了不便。偶尔在中国大陆之外直接访问这些全世界都在使用的网站甚至会产生微弱的兴奋感，这是我们所独有的「小确幸」。</p><p>我只有一个观点，自由访问互联网是和自由阅读书籍一样重要的权利。任何支持GFW的言论都是可笑至极的。</p><p>2、</p><p>另一个问题是，在这个大的局域网中还有多少局域网呢？李如一的系列文章「<a href="https://blog.yitianshijie.net/2018/02/27/2nd-anniversary-of-ditching-wechat/">告别微信两周年</a>」已经写的很详尽了。网络空间事实上已经被大公司分割成碎片，加上日益束紧的社会文化环境，「中文互联网内容枯萎」、「百度已死」似乎是一种必然，难道期待死水里盛开出什么吗？</p><p>如今，Netizen这个词已经不合时宜了，大量的当代互联网用户已经失去其主体性，访问互联网的用户只不过是面目模糊的「流量」，是数据库的数据，是广告喂食填充的禽类。而我们也相当配合，把自己装进一个个笼子里，被上传。在成熟之后，屠宰、肢解、流转、端上餐桌。商业社会有着一整套精细的流程控制这种逻辑的运转。</p><p>攻壳机动队里有个有意思的问题：如果放弃肉体，把Ghost上传到网络，在网络中如何维持个体性？还是最后都化为一团混沌？</p><p>3、</p><p>后COVID-19的世界在日益走向封闭，我也不知道在这样的浪潮里，个人能做些什么，或许如 <a href="https://www.youtube.com/watch?v=KgzQuE1pR1w">Bill Hicks 所说</a>，see all of us as one是一种个人可以践行的心态。</p><blockquote><p>But it doesn’t matter, because it’s just a ride. And we can change it any time we want. It’s only a choice. No effort, no work, no job, no savings of money. Just a simple choice, right now, between fear and love. The eyes of fear want you to put bigger locks on your doors, buy guns, close yourself off. The eyes of love instead see all of us as one. Here’s what we can do to change the world, right now, to a better ride. Take all that money we spend on weapons and defenses each year and instead spend it feeding and clothing and educating the poor of the world, which it would pay for many times over, not one human being excluded, and we could explore space, together, both inner and outer, forever, in peace.</p></blockquote><p>4、</p><p>近期看了一些关于开源社区的资料，感觉很有启发。</p><blockquote><p><a href="http://opensourceway.community/posts/foundation_introduce/how_apache_works/">Apache 是如何运作的？</a></p><p><a href="https://www.youtube.com/watch?v=OrxmtDw4pVI&amp;list=WL&amp;index=15&amp;t=692s">Vue.js：纪录片</a></p><p><a href="https://www.bilibili.com/video/av16549975/">互联网之子  The Internet’s Own Boy: The Story of Aaron Swartz</a></p></blockquote><p>虽然带着浓厚的理想主义色彩，但他们和盗火的普罗米修斯一样伟大。</p><p>5、</p><p>想起 <a href="https://www.youtube.com/watch?v=pY7AT10-J_w">紀念南亭村的一隻豬</a>，也许世界本来就是一个又一个巨大的猪圈，但不应该放弃奔跑，直到走了很远的路，看见围栏，然后跨过去。</p>]]></content>
    
    
    <summary type="html">如何在日渐封闭的数字世界和物理世界保持开放？</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
  <entry>
    <title>Google Keep 闯作收录</title>
    <link href="https://blog.210222.xyz/posts/keep-notes"/>
    <id>https://blog.210222.xyz/posts/keep-notes</id>
    <published>2020-07-08T16:30:46.000Z</published>
    <updated>2025-02-09T16:40:37.847Z</updated>
    
    <content type="html"><![CDATA[<h4 id="2018-3-3"><a href="#2018-3-3" class="headerlink" title="2018-3-3"></a>2018-3-3</h4><p>“答应我，不要把我遗忘！”老张临下班时紧紧攥着我的手说</p><h4 id="2018-3-23"><a href="#2018-3-23" class="headerlink" title="2018-3-23"></a>2018-3-23</h4><p>城市垃圾从广州大桥一跃而下</p><p>夺取一种真正的伟大胜利</p><p>这是它最后的尊严</p><h4 id="2018-3-28"><a href="#2018-3-28" class="headerlink" title="2018-3-28"></a>2018-3-28</h4><p>赤条条的小李在雪地里疯狂打滚</p><p>好几个小时</p><p>他炙热又痛苦的心啊</p><h4 id="2018-3-29"><a href="#2018-3-29" class="headerlink" title="2018-3-29"></a>2018-3-29</h4><p>无论如何 先活到夏天<br>看看女孩儿们的短裙<br>吃一个五羊牌甜筒<br>直到长柄伞被台风吹折</p><h4 id="2018-4-4"><a href="#2018-4-4" class="headerlink" title="2018-4-4"></a>2018-4-4</h4><p>阿森纳，坚持住<br>好事情会发生——温格下课！</p><h4 id="2018-4-14"><a href="#2018-4-14" class="headerlink" title="2018-4-14"></a>2018-4-14</h4><p>来自二沙岛中心的大功率宇宙广播，“当代生活是autoregression，保持警惕” </p><h4 id="2018-4-17"><a href="#2018-4-17" class="headerlink" title="2018-4-17"></a>2018-4-17</h4><p>1.</p><p>愚人码头<br>是不是有去往幸福的船</p><p>2.</p><p>雄性人类有没有好人，感觉没有</p><p>3.</p><p>现代人普遍焦虑，秃头成为一种进化趋势</p><h4 id="2018-5-8"><a href="#2018-5-8" class="headerlink" title="2018-5-8"></a>2018-5-8</h4><p>想了一个新媒体创业项目，开一个微信公众号，每天晚上10点更新，内容是从小区里随便抱个猫回来放在Cherry红轴机械键盘上，自由活动3分钟，阅读量每篇10w+应该没问题</p><h4 id="2018-8-12"><a href="#2018-8-12" class="headerlink" title="2018-8-12"></a>2018-8-12</h4><p>现代人走进CBD或者从一个小区走进另一个小区，会不会产生一种「又回到原点」的困惑。很多人没有手机，小区都走不出去，我敢说。更别说找到正佳广场东南门了。</p><p>我的思考，十年后的城市，一种postpostmodern建筑设计风格。写字楼，住宅全部统一设计（取消别墅），建筑长宽高统一（100×100×100m立方体），外立面统一（玻璃幕墙，反射能力强），实现一套图纸用全国，严肃，统一，整齐。取消绿化，取消路牌，取消postmodern。</p><p>一种真真正正的「钢铁森林，镜面迷宫」，走国人民一同步入communismpunk，新时代，温暖，眼角湿润。</p><h4 id="2018-9-17"><a href="#2018-9-17" class="headerlink" title="2018-9-17"></a>2018-9-17</h4><p>1.</p><p>就像是开着捷达追一列时速300的火车，所有的渴望都越来越远，直到最后一个车厢也消失在视野里，你冲出匝道，把中午吃的炒牛河通通吐了出来 </p><p>2.</p><p>山竹，带我走吧，我想回家了 </p><h4 id="2018-12-20"><a href="#2018-12-20" class="headerlink" title="2018-12-20"></a>2018-12-20</h4><p>语言是无能的，残疾的，你能感受到，但你不能说。</p><h4 id="2019-1-5"><a href="#2019-1-5" class="headerlink" title="2019-1-5"></a>2019-1-5</h4><p>你在修建通往何处的路？</p><h4 id="2019-2-24"><a href="#2019-2-24" class="headerlink" title="2019-2-24"></a>2019-2-24</h4><p>巴士 开往目的地<br>4:01 4:02 …4:59<br>无限循环<br>meta reflexion </p><h4 id="2019-3-6"><a href="#2019-3-6" class="headerlink" title="2019-3-6"></a>2019-3-6</h4><p>如果把当前的痛苦放到更长远的时间轴里，不过是茫茫痛苦里片刻。</p><h4 id="2019-4-7"><a href="#2019-4-7" class="headerlink" title="2019-4-7"></a>2019-4-7</h4><p>只是南方 </p><p>黏腻，潮湿，水泥砂浆，下水道，95#汽油味、雪茄味、鱼腥味散不开，</p><p>一洼水，漆黑一片的江边，空气静止，易拉罐上的液化水珠，分不开两张淋湿的纸</p><p>你就是在这样的味道里 变成了别的东西</p><h4 id="2019-4-28"><a href="#2019-4-28" class="headerlink" title="2019-4-28"></a>2019-4-28</h4><p>Air在1998年发行的专辑《moon safari》是对21世纪的一种昭示。人类不再囿于土地，从天空升起，一次真正的太空奥德赛。大规模漂浮的地球人像一场沙尘暴，席卷太阳系，勇敢地凝视黑洞。光速接近主，成为伟大的造物。</p><p>而2001年在不断回到过去，人类却仍然无法集体走向太空。70亿人被囚禁在地球上，一个敞口的重力牢笼，所有降临在这片土地上的生命都回避不了面前的那颗巨石。</p><h4 id="2020-4-8"><a href="#2020-4-8" class="headerlink" title="2020-4-8"></a>2020-4-8</h4><p>禽兽森林充分暴露了人体堂的反动本质，毁了一代社会主义接班人，现实生活一泡污，还天天在岛上摇树抓蝴蝶砸石头。发现索尼才真是良心会社，同样价格的主机输出4K画面，支援HDR，性能强劲，等待PS5发布那一天，一切就会好起来。</p>]]></content>
    
    
    <summary type="html">大量阅读锤片的后遗症，在重新努力说人话。</summary>
    
    
    
    <category term="经验" scheme="https://blog.210222.xyz/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Thoughts" scheme="https://blog.210222.xyz/tags/Thoughts/"/>
    
  </entry>
  
</feed>
